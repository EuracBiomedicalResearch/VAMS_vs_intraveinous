---
title: "Differential abundance analysis, semi-targeted approach"
subtitle: "Positive polarity"
author: "Christa Malfertheiner"
date: "15 June 2021"
output:
  BiocStyle::html_document:
    toc: true
    number_sections: false
    toc_float: true
bibliography: references.bib
csl: biomed-central.csl
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

```{r setup, echo = FALSE, results = "asis", warning = FALSE}
library(BiocStyle)
BiocStyle::markdown()
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

<!--
**Modified**: `r file.info("differential_abundance_pos.Rmd")$mtime`<br />
**Compiled**: `r date()`
-->

```{r parameters, echo = FALSE, warning = FALSE}
## Set general parameters
polarity <- "POS" # specify "POS" or "NEG"
p.cut <- 0.05     # cut-off for significance.
m.cut <- 0.7      # cut-off for log2 fold change

set.seed(123)

## Setting golden ratio to save images
phi <- (1+sqrt(5))/2

FILE_NAME <- "differential_abundance_pos"

## Define paths:
IMAGE_PATH <- paste0("images/", FILE_NAME, "/")
if (dir.exists(IMAGE_PATH)) unlink(IMAGE_PATH, recursive = TRUE, force = TRUE)
dir.create(IMAGE_PATH, recursive = TRUE, showWarnings = FALSE)

RDATA_PATH <- paste0("data/RData/", FILE_NAME, "/")
dir.create(RDATA_PATH, recursive = TRUE, showWarnings = FALSE)

RESULT_PATH <- paste0("data/results/", FILE_NAME, "/")
dir.create(RESULT_PATH, recursive = TRUE, showWarnings = FALSE)
```

# Introduction

In this document we perform the differential abundance analysis of the features
previously identified for the *MitYOU* project, with the aim of identifying
significant features. This task is performed by hypothesis testing, where we
try to identify which metabolites have the most different concentrations
between venous blood samples, capillary blood samples, plasma samples and RBCs. 
The analysis comprises feature pre-filtering, exploratory analysis and 
differential abundance analysis; these steps are firstly carried out on the 
whole dataset and subsequently only on a subset of features that are 
unambiguously assigned to known compounds.


# Data import

First, we load the required packages and the data, after preprocessing and
normalization. The end result of these steps is a `SummarizedExperiment` that
contains aligned data, where features are grouped (after correspondence), and
that have undergone gap filling, normalization by the median, linear fitting and 
per-feature between-batch normalization to remove any unwanted variability. 
The `SummarizedExperiment` lets us store all the information regarding the 
normalization steps in the form of `assays`, which we are still able to access 
to proceed with the analysis.

```{r load-data, echo = FALSE, warning = FALSE}
library(xcms)
library(limma)
library(pheatmap)
library(writexl)
library(SummarizedExperiment)
library(RColorBrewer)
library(MsFeatures)
library(CompMetaboTools)
library(pander)
library(MetaboAnnotation)

load("data/RData/vams_normalization_pos/res_pos.RData")
res_pos$sample_pair <- paste0(res_pos$source, ".", res_pos$sample)
```

It is important now to remove the `POOL` samples from the dataset, because the
analysis has to be performed only on study samples; the `POOL` samples, though
are still required to evaluate the goodness of the detected features, therefore
they will be stored in a separate `SummarizedExperiment` object that can be
accessed when needed.

We also assign the colours as seen before.

```{r split-qc, echo = TRUE}
res_qc <- res_pos[, res_pos$source == "all"]
res_pos <- res_pos[, res_pos$source != "all"]
res_pos$source <- factor(as.character(res_pos$source))
res_pos$sex <- factor(as.character(res_pos$sex))

col_source <- brewer.pal(5, name = "Set1")
names(col_source) <- c("RBC",           #' red
                       "plasma",        #' blue
                       "all",           #' green
                       "capillary",     #' purple
                       "venous")        #' orange

col_sex <- brewer.pal(4, name = "Set1") [c(1, 2, 3)]
names(col_sex) <- c("F",           # red
                    "M",           # blue
                    "POOL")        # green

## Setting golden ratio to save images
phi <- (1+sqrt(5))/2
```

The samples used in this analysis are listed below.

```{r, echo = FALSE, results = "asis"}
tab <- colData(res_pos)[, c("source", "sex", "age")]
pandoc.table(as.data.frame(tab), style = "rmarkdown",
             caption = "Samples used in this analysis")
```

# Semi-targeted analysis

First, we restrict the analysis to a set of known compounds, whose mass-to-charge
ratio and retention time have been previously measured from the pure standards.
To start, a table of standards is loaded in the document, then a search in the
m/z and retention time dimensions is carried out to match the features found
before to these compounds. Subsequently, EICs for all the assigned features are
plotted and visually inspected: this step is necessary to accurately pair the
detected peaks to the standards. When the list of assigned standards is
complete, we perform a differential abundance analysis on the subset of
features.

First, we load the information on the standards, with the aim of identifying
features potentially matching these and plotting the EICs for all of these.

```{r known-cmps, message = FALSE, warning = FALSE}
## Extract known compunds
library("MetaboCoreUtils")
library(Rdisop)
std_info <- read.table(
    "https://raw.githubusercontent.com/EuracBiomedicalResearch/lcms-standards/master/data/standards_dilution.txt",
    sep = "\t", header = TRUE, as.is = TRUE)
std_info <- std_info[!is.na(std_info[, "POS"]), ]
rownames(std_info) <- 1:nrow(std_info)
std_info$mzneut = NA
std_info$mz_ion = NA
for (i in seq(nrow(std_info))) {
    if (grepl("C", std_info$formula[i])) {
        std_info$mzneut[i] <- getMolecule(
            as.character(std_info$formula[i]))$exactmass
    } else {
        std_info$mzneut[i] = as.numeric(std_info$formula[i])
    }
    ## Calculate also the m/z
    std_info$mz_ion[i] <- mass2mz(
        std_info$mzneut[i], adduct = std_info[i, "POS"])[1, 1]
}
std_info <- std_info[!is.na(std_info$mz_ion), ]
std_info <- std_info[order(std_info$name), ]

dr <- paste0(IMAGE_PATH, "/standards/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)

##load data_pos

load("data/RData/vams_normalization_pos/data_pos_filled.RData")
pData(data_pos) <- as.data.frame(pData(data_pos))

## Subset to the samples we're currently analyzing.
tmp <- filterFile(data_pos, match(res_pos$mzML_file, data_pos$mzML_file),
                  keepFeatures = TRUE)

rowData(res_pos)$ft <- row.names(res_pos)
par <- MzRtParam(tolerance = 0, ppm = 40, toleranceRt = 30)
mo <- matchMz(res_pos, std_info, param = par, mzColumn = c("mzmed", "mz_ion"), 
               rtColumn = c("rtmed", "RT"))
mo <- mo[whichQuery(mo)]
mo <- pruneTarget(mo)
## Try to identify all features potentially matching these.

mD <- matchedData(mo, c("ft", "target_name", "target_RT", "target_mz_ion" ))
mtchd_ft <- unique(mD$ft)
chrs <- featureChromatograms(tmp, features = mtchd_ft, expandRt = 7, filled = TRUE)
sample_colors <- col_source[tmp$source]
for (i in seq_len(nrow(mD))) {
  chr <- chrs[match(mD$ft[i], mtchd_ft), ]
  pks <- chromPeaks(chr)
  fl <- mD$target_name[i]
  png(paste0(dr, fl, "-", mD$ft[i], ".png"),
      width = 10, height = 8, units = "cm", res = 300, pointsize = 6)
  plot(chr, col = "#00000040",
       peakCol = paste0(sample_colors[pks[, "column"]], 50),
       peakBg = paste0(sample_colors[pks[, "column"]], 10))
  abline(v = mD$target_RT[i])
  legend("topleft", legend = c(mD$ft[i], fl,
                               paste0("rt: ", mD$target_RT[i]),
                               paste0("mz: ", mD$target_mz_ion[i])))
  dev.off()
}
```

The EICs have been manually inspected and the best matching feature has been
manually assigned to the corresponding standard. Some features found a better
match than others, such as xyz; in this case, in fact, there is a single
peak detected, with high intensity, that is well within the theoretical m/z
range and it is very close to the theoretical retention time.

```{r assign-feature-metabolite, echo = FALSE, warning = FALSE, message = FALSE}
## This is the tricky manual thing:
## - Got through all plots for all standards and if there is one feature
##   that clearly matches (i.e. retention time close to the expected retention
##   time and a single peak present in the wider rt range) assign it.

keep <- rbind(c("1-Methylhistidine", "FT0293"),
              c("3-Methylhistidine", "FT0293"), # same as 1-Methylhistidine
              c("5-Oxoproline", "FT0154"),
              c("Acetylcarnitine", "FT0415"),
              c("Acetyl-Glucosamine", "FT0518"),
              c("Acetylhistidine", "FT0384"),
              c("ADMA", "FT0407"),
              c("Alanine", "FT0051"),
              c("alpha-Aminoadipic acid", "FT0268"),
              c("alpha-Lactose", "FT1330"), # or FT1331
              c("AMP", "FT1197"),
              c("Arginine", "FT0307"),
              c("Asparagine", "FT0162"),
              ## c("Betaine", "FT0111/FT0112"),
              c("C4 Carnitine", "FT0486"),
              c("C5 Carnitine", "FT0527"), # rt shifted 10s
              c("Caffeine", "FT0378"),
              c("Carnosine", "FT0472"),
              ## c("Choline", "FT0072"),
              c("Citrulline", "FT0312"),
              ## c("Corticosterone", "FT1193"), # rt shifted 10s
              ##c("Creatine", "FT0159/FT0160"),
              ##c("Creatinine", "FT0099/FT0100"),
              c("Cystine", "FT0507"),
              c("dGMP", "FT1198"),
              c("Fructose", "FT0402"), # same as glucose and mannose
              c("Galactitol", "FT0420"), # same as sorbitol
              c("Gluconic Acid", "FT0460"),
              c("Glucose", "FT0402"), # same as Fructose
              c("Glutamine", "FT0215"),
              c("Glutathione Oxidized", "FT3342"), # same as Glu. Reduced
              c("Glutathione Reduced", "FT3342"), # same as Glu. Oxidized
              c("Glycero-phosphocholine", "FT0581"),
              c("Glycine", "FT0031"),
              c("Histidine", "FT0249"),
              c("Homocysteine", "FT0178"),
              c("Hydroxyproline", "FT0158"),
              c("Hypoxanthine", "FT0182"),
              c("Isoleucine", "FT0161"),
              c("L-Aspartic Acid", "FT0168"), # or FT0169
              c("L-Carnitine", "FT0270"), 
              c("L-Cysteine", "FT0123"),
              c("Leucine", "FT0161"),
              ##c("Levodopa", "FT0384"), # found with ppm = 50
              c("L-Glutamic Acid", "FT0220"),
              c("Lysine", "FT0216"),
              c("Mannose", "FT0402"), # same as Fructose and Glucose
              c("Methionine", "FT0226"),
              c("Methioninesulfoxide", "FT0280"), 
              ## c("Myoinositol", "FT0402"), # detected as FT0820 and FT0821 - same as fructose, glucose and mannose
              c("N-Acetylornithine", "FT0306"),
              c("NAD", "FT3776"),
              c("Niacinamide", "FT0134"),
              c("Ornithine", "FT0165"),
              c("Palmitoylcarnitine", "FT1588"), # or FT1589
              c("Phenylalanine", "FT0281"),
              ##c("Phenylethylamine", "FT0129"),
              ##c("Phosphocreatine", "FT0436"),
              c("Phosphorylcholine", "FT0338"),
              c("Phosphorylethanolamine", "FT0201"),
              ##c("Pipecolic acid", "FT0155"),
              ## c("Proline", "FT0107/FT106"),
              ##c("Putrescine", "FT0024"),
              c("SAH", "FT1481"),
              c("SAMe", "FT1583"),
              c("SDMA", "FT0407"),
              c("Serine", "FT0079"),
              c("Sorbitol", "FT0420"), # same as galactitol
              c("Sphingosine-1-phosphate", "FT1451"),
              c("Sphingosine", "FT0843"),
              c("Sucrose", "FT1331"), # or FT1330
              c("Taurine", "FT0146"),
              c("Threonine", "FT0117"),
              c("Tryptophan", "FT0422"),
              c("Tyrosine", "FT0328"),
              c("Valine", "FT0112"))

mo <- keepMatches(mo, queryValues = keep[, 2], 
                  targetValues = keep[, 1], 
                  queryColname = "ft", targetColname = "target_name")
mo <- mo[whichQuery(mo)]
mo <- pruneTarget(mo) # Probably it's not very useful but since these two lines
# are used one ofter the other we could create a function e.g. reduceMatched 
# that does the two things

mD <- matchedData(mo, c("ft", paste0("target_", c("name", "RT", "mzneut", 
                                                 "mz_ion", "HMDB.code"))))
colnames(mD) <- c("feature", "name", "RT", "mzneut", "mz_ion", "HMDB.code")
dups <- mD$feature[duplicated(mD$feature)]
for (dup in dups) {
    idx <- which(mD$feature == dup)
    mD$HMDB.code[idx[1]] <- paste0(mD$HMDB.code[idx], collapse = ";")
    mD$name[idx[1]] <- paste0(mD$name[idx], collapse = ";")
    mD$feature[idx[-1]] <- NA
}
mD <- mD[!is.na(mD$feature), ]
rownames(mD) <- mD$feature
```

A total of `r sum(nrow(mD))` standards have been identified. The features
identified and the corresponding metabolite are summarized in this table:

```{r result-table-ft-std, echo = FALSE, results = "asis"}
## Write result table
mD <- mD[order(mD$name), ]
pandoc.table(as.data.frame(mD[, 1:4]), style = "rmarkdown",
             caption = "Features assigned to known compounds")
```

Next, only the features assigned to the standards are taken into consideration
and are subsetted in the `std_res` object.

```{r std-subset, echo = FALSE}
# std_res <- res_pos[rownames(res_pos) %in% mD$feature, ]
# rowData(std_res) <- cbind(rowData(std_res),
#                           mD[rownames(std_res), c("name", "HMDB.code")])
std_res <- query(mo)
rowData(std_res) <- cbind(rowData(std_res),
                          mD[rownames(std_res), c("name", "HMDB.code")])
```

The subsetting reduced the number of features to `r length(std_res)`. 


A PCA analysis is then performed on the subset to verify whether anything has
changed and if any similarities among the samples are visible or not.

```{r standards-pca-all, echo = FALSE}
pc <- prcomp(t(log2(assay(std_res, "normalized_filled_imputed"))),
                 center = TRUE, scale. = FALSE)
```

```{r standards-pca-plot, fig.path = IMAGE_PATH, fig.cap = "PCA of the samples based on intensities of known compounds.", fig.width = 7 * phi, fig.height = 7, echo = FALSE}
par(mfrow = c(1, 2))
plot_pca(pc, col = paste0(col_source[as.character(std_res$source)], 90),
         pc_x = 1, pc_y = 2, labels = std_res$differentiation)
plot_pca(pc, col = paste0(col_source[as.character(std_res$source)], 90),
         pc_x = 3, pc_y = 4)
legend("topleft", col = col_source, legend = names(col_source),
       title = "phenotype", pch = 16, ncol = 2)
```

In the PC1 plot, capillary and RBC samples cluster together. Plasma samples 
clusters independently of all other sample sources. In PC3 one can not 
differentiate between the matrices.


```{r std_id-samples, echo = FALSE, results = "asis"}
idx <- pc$x[, 1] > 10
tab <- colData(std_res)[which(idx), c("source", "age", "sex")]
pandoc.table(as.data.frame(tab), style = "rmarkdown",
             caption = "samples: PC1>10")

idx <- pc$x[, 2] < -5
tab <- colData(std_res)[which(idx), c("source", "age", "sex")]
pandoc.table(as.data.frame(tab), style = "rmarkdown",
             caption = "samples: PC2<-5")
```

We then create a data set for each sample source:

```{r source-subset, echo = FALSE}
res_cap = std_res[, std_res$source == "capillary"]
res_ven = std_res[, std_res$source == "venous"]
res_plas = std_res[, std_res$source == "plasma"]

```

Next, we want to see the clustering for each data set. Male and female samples
are represented by rectangles and circles. We start with the capillary set:

```{r PCA-std-capillary, fig.path = IMAGE_PATH, fig.width = 7 * phi, fig.height = 7, fig.cap = "PCA for capillary blood samples. Circles and rectangles indicate male or female samples.", echo = FALSE}

pc_raw_capillary <- prcomp(t(log2(assay(res_cap, "normalized_filled_imputed"))),
                           scale = FALSE, center = TRUE)

pch <- rep(21, ncol(res_cap))
pch[res_cap$sex == "M"] <- 22
par(mfrow = c(1, 2))
plot_pca(pc_raw_capillary, col = paste0(col_sex[as.character(res_cap$sex)], 80),
         pc_x = 1, pc_y = 2, main = "capillary samples, M/F",
         pch = pch, labels = res_cap$sample)
plot_pca(pc_raw_capillary, col = paste0(col_sex[as.character(res_cap$sex)], 80),
         pc_x = 3, pc_y = 4, main = "capillary samples, M/F",
         pch = pch, labels = res_cap$sample)
legend("topleft", col = col_sex, legend = names(col_sex), pch = 16,
       cex = 0.4)

```

In the capillary samples, we see some differences between male and female 
samples. Also, the replicates cluster nearly together in the PC1.

We then generate the PCA for the venous data set:

```{r PCA-std-venous, fig.path = IMAGE_PATH, fig.width = 7 * phi, fig.height = 7, fig.cap = "PCA for venous blood samples. Circles and rectangles indicate male or female samples.", echo = FALSE}

pc_raw_venous <- prcomp(t(log2(assay(res_ven, "normalized_filled_imputed"))),
                        scale = FALSE, center = TRUE)

pch <- rep(21, ncol(res_cap))
pch[res_ven$sex == "M"] <- 22
par(mfrow = c(1, 2))
plot_pca(pc_raw_venous, col = paste0(col_sex[as.character(res_ven$sex)], 80),
         pc_x = 1, pc_y = 2, main = "venous samples, M/F",
         pch = pch, labels = res_ven$sample)
plot_pca(pc_raw_venous, col = paste0(col_sex[as.character(res_ven$sex)], 80),
         pc_x = 3, pc_y = 4, main = "venous samples, M/F",
         pch = pch, labels = res_ven$sample)
legend("topleft", col = col_sex, legend = names(col_sex), pch = 16,
       cex = 0.4)


```

In the venous dataset, a differentiation between male and female samples is not 
observed.The replicates cannot be assigned to each other.

Lastly, we generate the PCA for the plasma samples:

```{r PCA-std-plasma, fig.path = IMAGE_PATH, fig.width = 7 * phi, fig.height = 7, fig.cap = "PCA for plasma blood samples. Circles and rectangles indicate male or female samples.", echo = FALSE}

pc_raw_plasma <- prcomp(t(log2(assay(res_plas, "normalized_filled_imputed"))),
                        scale = FALSE, center = TRUE)

pch <- rep(21, ncol(res_plas))
pch[res_plas$sex == "M"] <- 22
par(mfrow = c(1, 2))
plot_pca(pc_raw_plasma, col = paste0(col_sex[as.character(res_plas$sex)], 80),
         pc_x = 1, pc_y = 2, main = "plasma samples, M/F",
         pch = pch, labels = res_plas$sample)
plot_pca(pc_raw_plasma, col = paste0(col_sex[as.character(res_plas$sex)], 80),
         pc_x = 3, pc_y = 4, main = "plasma samples, M/F",
         pch = pch, labels = res_plas$sample)
legend("topleft", col = col_sex, legend = names(col_sex), pch = 16,
       cex = 0.4)


```

In the plasma samples, we do not see a clustering effect between male and female
samples.

Next we merge the technical replicates.

```{r}

#' Average 
averageSE <- function(x, column = character(), mainAssay = character()) {
    if (!column %in% colnames(colData(x)))
        stop("Column '", "' not found in 'colData' of 'x'")
    f <- factor(colData(x)[, column], levels = unique(colData(x)[, column]))
    ## new colData: take the first element for each replicate.
    cd <- colData(x)[match(levels(f), f), ]
    ## loop over the assays and average them.
    a <- lapply(assays(x), function(z) {
        z <- split.data.frame(t(z), f = f)
        z <- do.call(cbind, lapply(z, colMeans, na.rm = TRUE))
        z[is.na(z)] <- NA
        z
    })
    if (length(mainAssay)) {
        tmp <- split.data.frame(t(assay(x, mainAssay)), f = f)
        tmp <- do.call(cbind, lapply(tmp, function(y) {
            apply(y, MARGIN = 2, FUN = sd, na.rm = TRUE)
        }))
        tmp[is.na(tmp)] <- NA
        a[[paste0(mainAssay, "_sd")]] <- tmp
    }
    SummarizedExperiment(assays = a, rowData = rowData(x),
                         colData = cd, metadata = metadata(x))
}

## Average technical replicates:
res_pos <- averageSE(res_pos, column = "sample_pair",
                     mainAssay = "normalized_filled")



```
