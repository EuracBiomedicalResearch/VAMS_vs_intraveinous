---
title: "Matrix comparison, semi-targeted analysis, positive polarity"
author: "SÃ¸ren Fjelstrup, Chiara Volani, Giuseppe Paglia and Johannes Rainer"
graphics: yes
output:
  BiocStyle::html_document:
    toc_float: true
bibliography: references.bib
csl: biomed-central.csl
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

```{r biocstyle, echo = FALSE, results='hide', message = FALSE}
library(BiocStyle)
BiocStyle::markdown()
```

**Modified**: `r file.info("vams_matrix_pos_semtar.Rmd")$mtime`<br />
**Compiled**: `r date()`

```{r settings, echo = FALSE, results = "hide", message = FALSE, warning = FALSE}
#' Set general options
options(useFancyQuotes = FALSE)
set.seed(18011977)

#' Define paths:
filename <- "vams_matrix_pos_semtar"
#' Path to save the images; remove all old images.
IMAGE_PATH <- paste0("images/", filename, "/")
if (file.exists(IMAGE_PATH)) 
    unlink(IMAGE_PATH, recursive = TRUE)
dir.create(IMAGE_PATH, recursive = TRUE)
#' Path to store RData files
RDATA_PATH <- paste0("data/RData/", filename, "/")
if (!file.exists(RDATA_PATH)) dir.create(RDATA_PATH, recursive = TRUE)

#' Get the number of cpus allocated or fall back to 3
ncores <- as.integer(Sys.getenv("SLURM_JOB_CPUS_PER_NODE", 3))
```

# Introduction

In this document we evaluate differences between the 4 matrices *venous*,
*capillary*, *plasma* and *RBC* using a *semi-targeted* approach: instead of
analyzing the full (untatgeted) data set (described in
[vams_matrix_pos.html](vams_matrix_pos.html)) we restrict the analysis to
features potentially representing a set of previously measured standards. The
matching of features to these standards is done based on the m/z of the expected
adduct and the proximity of the features' retention time to the expected
retention time of the standards.

Below we load all required libraries and the data.

```{r libs-data, message = FALSE}
library(xcms)
library(SummarizedExperiment)
library(pander)
library(RColorBrewer)
source("util-functions.R")
library(UpSetR)
library(doParallel)
registerDoParallel(3)
register(DoparParam(), default = TRUE)

#' Define colors for the groups.
col_source <- brewer.pal(5, name = "Set1")[c(1, 2, 4, 5)]
names(col_source) <- c("RBC",           #' red
                       "plasma",        #' blue
                       "capillary",     #' purple
                       "venous")        #' orange

load("data/RData/vams_normalization/vams_pos.RData")

```

Below we impute missing feature intensities. These are replaced with half of the
feature's smallest value in all samples adding a small standard deviation
thus avoiding constant values.

```{r Imputation-of-Values}
assays(vams_pos)$imputed <- imputeRowMinRand(
                    assay(vams_pos), min_fraction = 1/2,
                    sd_fraction = 1, abs = TRUE)

```


# Identify features potentially representing measured standard compounds

Below we load a table containing the measured retention times (in water and
serum) for the set of standards. After that we load a database containing the
annotations from HMDB (version 4.1) and use this to update/fix the exact
(monoisotopic) masses of the standards.

```{r standards, message = FALSE, warning = FALSE}
url <- "https://raw.githubusercontent.com/EuracBiomedicalResearch/lcms-standards/master/"

std <- read.table(paste0(url, "data/standards_rtime.txt"), header = TRUE,
                  sep = "\t", as.is = TRUE, quote = "", comment.char = "")
#' Subset to positive polarity
std <- std[std$polarity == "POS", ]

library(CompoundDb)
cdb <- CompDb("local_data/CompDb.Hsapiens.HMDB.4.1.sqlite")

#' Ensure we have the correct masses.
masses <- vapply(std$hmdb_id, function(z)
    compounds(cdb, column = "mass", filter = ~ compound_id == z)$mass,
    numeric(1))
std$mass <- masses

```

Next we retrieve annotations from the database for each standard matching the
m/z of expected adducts accepting a difference between m/z of 10 ppm.

```{r match-features, message = FALSE, warning = FALSE}
#' Identify all features matching the masses and adducts.
res <- lapply(seq_len(nrow(std)), function(i) {
    match_features(mass = std$mass[i], rt = std$rt[i],
                   object = rowData(vams_pos),
                   adduct = c("[M+H]+", "[M+Na]+"),
                   ppm = 10)
})

#' Combine with the std table
std_features <- cbind(
    std[rep(seq_len(nrow(std)), vapply(res, nrow, integer(1))), ],
    do.call(rbind, res))
```

Next we reduce redundancy due to duplicated feature assignments for retention
times measured in water and in serum. For each standard we select thus the row
of the standard measured in serum (unless the standard was only detected in
water).

```{r prefer-serum}
#' reduce to have only a single hmdb_id/feature_id pair
std_features_split <- split.data.frame(std_features, std_features$hmdb_id)
std_features <- do.call(rbind,
                        lapply(std_features_split, function(z) {
                            tmp <- split(z, z$feature_id)
                            do.call(rbind, lapply(tmp, function(ftr) {
                                if (nrow(ftr) > 1) {
                                    ## return the one for serum...
                                    ftr[grep("serum", ftr$source_id)[1], ]
                                }
                                else ftr
                            }))
                        }))
rownames(std_features) <- NULL

```

At last we restrict feature assignments based on the difference between the
expected and observed retention time:

- For standards with retention times measured in water: the retention time
  difference has to be > -10: due to the higher sample complexity, we expect
  retention times in serum to be higher than in water.
- For standards with retention times measured in serum: the absolute retention
  time difference should not be larger 30 seconds.
  
```{r restrict-rtime}
water <- grepl("water", std_features$source_id)
std_features <- std_features[(water & std_features$rt_diff > -10) | !water, ]

serum <- grepl("serum", std_features$source_id)
std_features <- std_features[(serum & abs(std_features$rt_diff) < 30) | !serum, ]
```

In total `r nrow(std_features)` features were annotated in that way to the 
`r length(unique(std_features$hmdb_id))` unique standards. We have thus for some
standards a mapping to multiple features, e.g. representing different adducts of
the same metabolite, or simply wrong assignments.

At last we collapse multiple annotations of the same feature to many standards
into a single field which we will then use in the annotation of the result
tables.

```{r collapse-multimaps}

tmp <- split(std_features, std_features$feature_id)
std_features_ann <- do.call(rbind, lapply(tmp, function(z) {
    c(hmdb_id = paste(z$hmdb_id, collapse = ";"),
      name = paste(z$name, collapse = ";"))
}))

```

# Filtering of the data set

We next subset the full data set consisting of abundances of `r nrow(vams_pos)`
features to the features potentially measuring the standards.

```{r filter, message = FALSE, warning = FALSE}
vams_pos_semtar <- vams_pos[rownames(std_features_ann), ]
rowData(vams_pos_semtar) <- cbind(rowData(vams_pos_semtar), std_features_ann)
```

# *Qualitative* data analysis

Similar to the corresponding section in the analysis on the full data set
[vams_matrix_pos.html](vams_matrix_pos.html) we perform first a *qualitative*
analysis in which we simply evaluate whether features are *present* or *absent*
in a matrix.

## Identifying detected/present features for each matrix

We next aim to identify *present* (detected) features for each matrix which
allows to perform qualitative comparisons between the matrices. We use the same
approach described in the analysis of the full data (see
[vams_matrix_pos.Rmd](vams_matrix_pos.Rmd), respectively the compiled html/pdf
file for details) and hence don't show the code to perform the analysis here.

```{r proportion-detected, message = FALSE, warning = FALSE, echo = FALSE}
wght_detected <- c(1, 0.9, 0.7, 0.5)

#' Determine for each feature the proportion of samples (per matrix) in
#' which a peak was detected
prop_detected <- apply(assay(vams_pos_semtar, "weights"), 1, function(x, grps) {
  vapply(split(x, grps), function(z) sum(z %in% wght_detected) / length(z),
           numeric(1)) }, grps = vams_pos_semtar$source)
prop_detected <- t(prop_detected)

#' Calculate ratio between proportion and max proportion
prop_ratio <- (1 / rowMax(prop_detected)) * prop_detected

#' Define present/absent calls
present_call <- prop_ratio > 1/3

```

## Comparison of numbers of features detected in each matrix

With the present/absent calls available we can next evaluate the number of
features being detected in each matrix. The results are represented with the
barplot below.

```{r barplot-features, message = FALSE, warning = FALSE, echo = FALSE, fig.path = IMAGE_PATH, fig.cap = "Number of features detected by each matrix", fig.width = 6, fig.height = 8}
par(mfrow = c(1, 1), mar = c(7, 4.5, 2, 0.5))
barplot(colSums(present_call), col = col_source[colnames(present_call)],
        main = "Detected features", ylab = "count", las = 2)

```

Similarly to the analysis on the full data set, the fewest number of features
was detected in plasma samples. The highest number of standards was detected in
capillary samples (for the full data set it was in venous samples). The results
are summarized in the table below.

```{r feature-count-table, results = "asis", echo = FALSE}
cpt <- paste0("Number of features detected in each matrix")
pandoc.table(colSums(present_call), style = "rmarkdown",
             caption = cpt)

```


## Matrix-specific features and features present in all matrices

We next compare the overlaps and intersects of features for standards being
*present* in the 4 matrices.

```{r upsetr-plot, message = FALSE, warning = FALSE, echo = FALSE, fig.path = IMAGE_PATH, fig.cap = "Visualisation of the feature intersects between the 4 matrices.", fig.width = 10, fig.height = 8}
ints <- apply(present_call, MARGIN = 2, which)
upset(fromList(ints), order.by = "freq",
      sets.bar.color = col_source[c("venous", "capillary", "RBC", "plasma")])
```

As before, most features are shared between all matrices, with about 15% being
shared between all but the plasma matrix. Only very few samples are unique to a
matrix. We next evaluate the average abundance of common or matrix specific
features.

```{r matrix-specific-features, echo = FALSE}
feats_common <- rownames(present_call)[rowSums(present_call) == 4]
feats_plasma <- rownames(present_call)[rowSums(present_call) == 1 &
                                       present_call[, "plasma"]]
feats_venous <- rownames(present_call)[rowSums(present_call) == 1 &
                                       present_call[, "venous"]]
feats_RBC <- rownames(present_call)[rowSums(present_call) == 1 &
                                    present_call[, "RBC"]]
feats_capillary <- rownames(present_call)[rowSums(present_call) == 1 &
                                          present_call[, "capillary"]]
```

```{r matrix-specific-abundance, message = FALSE, fig.path = IMAGE_PATH, fig.cap = "Distribution of average (across samples) abundances of common and matrix-specific features.", fig.width = 6, fig.height = 8, echo = FALSE}
ints <- list(
    common = rowMeans(assay(vams_pos_semtar)[feats_common, ]),
    plasma = rowMeans(assay(vams_pos_semtar)[feats_plasma,
                                             vams_pos_semtar$source == "plasma"]),
    venous = mean(assay(vams_pos_semtar)[feats_venous,
                                         vams_pos_semtar$source == "venous"]),
    RBC = rowMeans(assay(vams_pos_semtar)[feats_RBC,
                                          vams_pos_semtar$source == "RBC"]),
    capillary = rowMeans(assay(vams_pos_semtar)[feats_capillary,
                                                vams_pos_semtar$source == "capillary"])
)
par(mar = c(7, 4.5, 1, 1))
boxplot(lapply(ints, log2), varwidth = TRUE, col = col_source[names(ints)],
        ylab = expression(log[2]~abundance), las = 2, main = "average abundance")
grid(nx = NA, ny = NULL)

```

As before, the average abundance of matrix-specific features is much lower than
the abundance of *common* features. Thus many features might appear to be matrix
specific because their abundance is below the detection limit in other matrices.


# *Quantitative* data analysis

Next we evaluate and compare abundance levels of features for measured standards
between the matrices.

## Grouping samples based on metabolite abundances

We perform a principal component analysis to evaluate the grouping of the
samples/matrices in our experiment.

```{r pca-rsd, message = FALSE, warning = FALSE, echo = FALSE, fig.path = IMAGE_PATH, fig.width = 10, fig.height = 5, fig.cap = "PCA grouping samples based on (centered) feature abundances. Only features for measured standards are used. Circles represent samples from female, rectangles from male participants. Missing values were replaced with half of the feature's minimal abundance adding also a small random variance."}
tmp <- log2(assay(vams_pos_semtar, "imputed"))
pc <- prcomp(t(tmp), scale = FALSE, center = TRUE)
pchs <- ifelse(vams_pos_semtar$sex == "F", 21, 22)

par(mfrow = c(1, 2), mar = c(4.5, 4.5, 1, 1))
plot_pca(pc, pc_x = 1, pc_y = 2, 
         col = paste0(col_source[vams_pos_semtar$source], "ce"),
         bg = paste0(col_source[vams_pos_semtar$source], 60),
         pch = pchs, cex = 1.5)

legend("top", col = col_source, legend = names(col_source), pch = 16)

plot_pca(pc, pc_x = 3, pc_y = 4,
         col = paste0(col_source[vams_pos_semtar$source], "ce"),
         bg = paste0(col_source[vams_pos_semtar$source], 60),
         pch = pchs, cex = 1.5)

```

Despite being based on only about 1% of the total features, the clustering of
the samples are almost identical to the ones seen on the PCA of the full data
set (see [vams_matrix_pos.html](vams_matrix_pos.html)).


## Differential abundance analysis

We next identify features with significant differences in abundances between
matrices. Analogous to the analysis in the full data set we use multiple
regression for the differential abundance analysis employing a model that
explains observed abundances on the matrix, the sex and the ID of the
individual. 

```{r ModelforlinearmodelVSplasmanoconfounding, warning = FALSE}
pLimit <- 0.01
foldLimit <- 1
SourcesTypes <- c("sourceplasma","sourceRBC","sourcevenous")

#' The function for the multiple linear regression is made. This takes a numeric
#' input along with a matrix containing the confounding factors, it returns the
#' means and the p value
fitlmFunction <- function(x, dataMat, model = conc ~ source) {
    dataMat$conc <- x
    dataMat$source <- factor(x = dataMat$source, 
                             levels = c("capillary", "plasma", "RBC", "venous"))
    mdl <- lm(model, data = dataMat)
    smry <- data.frame(summary(mdl)$coefficients)
    SourceTypes <- paste0("source", levels(dataMat$source)[-1])
    Output <- c(coef = smry[SourceTypes, 1], pvalue =  smry[SourceTypes, 4])
    names(Output) <- c(paste0("coef.", SourceTypes),
                       paste0("pvalue.", SourceTypes))
    Output
}

#' The data is log2 transformed to make it mostly gaussian in distribution  
fitMatrix <- t(apply(log2(assay(vams_pos_semtar, "imputed")), 1,
                     fitlmFunction, 
                     dataMat = as.data.frame(colData(vams_pos_semtar)),
                     model = conc ~ source + sex))

#' Adjusting for multiple hypothesis testing
padj <- apply(fitMatrix[ ,paste0("pvalue.", SourcesTypes)], 2, p.adjust, 
              method = "BH")
sign <- abs(fitMatrix[, grep("coef", colnames(fitMatrix))]) > foldLimit &
    padj < pLimit
colnames(sign) <- sub("coef.", "", colnames(sign), fixed = TRUE)
#' Compile the result table
res_matrix_pos<- cbind(rowData(vams_pos_semtar),
                       fitMatrix,
                       adj = padj,
                       significant = sign)

```

```{r with-limma, echo = FALSE, eval = FALSE}
library(limma)

source <- vams_pos_semtar$source
sex <- vams_pos_semtar$sex
dsgn <- model.matrix(~ 0 + source + sex)

fit <- lmFit(log2(assay(vams_pos_semtar, "imputed")), design = dsgn)
cntr <- makeContrasts(sourceplasma = sourceplasma - sourcecapillary,
                      sourceRBC = sourceRBC - sourcecapillary,
                      sourcevenous = sourcevenous - sourcecapillary,
                      levels = dsgn)
fit <- contrasts.fit(fit, cntr)
fit <- eBayes(fit)

padj <- apply(fit$p.value, 2, p.adjust, method = "BH")

sign <- abs(fit$coefficients) > foldLimit & padj < pLimit

res_matrix_posl <- cbind(rowData(vams_pos_semtar),
                         pvalue = fit$p.value,
                         adj.pvalue = padj,
                         coef = fit$coefficients,
                         significant = sign)

```

The distribution of raw p-values for the significance of differential abundance
for features between a source and capillary samples is shown below.

```{r Histogramofpvalues, fig.path = IMAGE_PATH, echo = FALSE, fig.cap = "Histogram of the p values each of the linear models against capillary. All histograms show a smooth decrease over the range of pvalues, indicating only a small possible effect from confounding factors"}
TestedSourcenames <-  c("plasma", "RBC", "venous")
par(mfrow=c(1, 3))
for (i in 1:3) {
    hist(res_matrix_pos[, paste0("pvalue.", SourcesTypes[i])],
         main = paste0(TestedSourcenames[i], " vs capillary"),
         xlab = "p-value")
}

```

The results from the differential abundance analysis are visualized with volcano
plots below.

```{r VolcanoPlotMultipleRegression, fig.path = IMAGE_PATH, echo = FALSE, fig.cap = "Volcano plots of each of the linear models against capillary. Benjamini-Hochberg adjusted values, against the mean differences for each feature, show a large proportion of the features are statistically significantly different between matrixes", fig.width = 12, fig.height = 4}
#' A new color set is defined to better conform to what is need by the volcano plot
col_volcano <- brewer.pal(9, name = "Set1")[c(9, 9, 9, 3)]
names(col_volcano) <- c("all", "pLimit", "foldLimit", "significant")

#' The filters for pvalue and fold increase is defined
colorFilterLowP <- as.matrix(
    res_matrix_pos[, paste0("adj.pvalue.", SourcesTypes)]) < pLimit
colorFilterHighFold <- abs(as.matrix(
    res_matrix_pos[, paste0("coef.", SourcesTypes)])) > foldLimit

#' The filter for coloring the points is made
colorFilter <- 1 * colorFilterLowP
colorFilter[colorFilterHighFold] <- 2
colorFilter[colorFilterHighFold * colorFilterLowP == 1] <- 3
colorFilter <- colorFilter + 1

par(mfrow=c(1, 3), mar = c(4.3, 4.3, 1, 1))
x_range <- range(as.matrix(
    res_matrix_pos[, grep("^coef", colnames(res_matrix_pos))]), na.rm = TRUE)
y_range <- range(
    -log10(as.matrix(res_matrix_pos[, grep("^adj", colnames(res_matrix_pos))])),
    na.rm = TRUE)
for (i in 1:3){
    plot(3, 3, pch = NA, xlim = x_range, ylim = y_range,
         xlab = expression(log[2]~fold~change),
         ylab = expression(-log[10]~p[BH]~value),
         main = paste0(TestedSourcenames[i], " vs capillary"))
    grid(col = "#cecece20")
    points(res_matrix_pos[, paste0("coef.", SourcesTypes[i])],
           -log10(res_matrix_pos[, paste0("adj.pvalue.", SourcesTypes[i])]),
           pch = 16, col = paste0(col_volcano[colorFilter[, i]], 60),
           cex = 1.2)
    abline(h = -log10(pLimit), col = "grey", lty = 3)
    abline(v = c(-foldLimit, foldLimit), col = "grey", lty = 3)
}

```

The differences between the matrices are considerable and most differences were
found between plasma and capillary.

```{r count-table_linear_model, results = "asis", echo = FALSE}
cpt <- paste0("Number of features with a significant difference in abundances",
              " (more than two-fold difference in abundances at a 1% FDR.")
pandoc.table(colSums(as.matrix(
    res_matrix_pos[, grep("significant", colnames(res_matrix_pos))]),
    na.rm = TRUE), style = "rmarkdown", caption = cpt)

```

Out of the 121 features, approximatively 50, 25 and 30% of the features are
found to have statistically significant abundances (compared to capillary
samples) for plasma, RBC and venous samples, respectively.


## Distribution of features

Next we visualize the distributions of the m/z and retention times for features
either found to be detected in a certain matrix or being signifcantly
differently abundant.

```{r pValueDependencyOnmzNoconfounding, fig.cap = "Distribution of m/z values (left) or retention time (right) for detected features in a matrix.", echo = FALSE, fig.width = 12, fig.height = 6, fig.path = IMAGE_PATH}

#' Distributions of mz values for each matrix.
par(mfrow = c(1, 2), mar = c(4.3, 4.3, 1, 1))
plot(density(res_matrix_pos$mzmed[present_call[, 1]], na.rm = TRUE),
     col = paste0(col_source[colnames(present_call)[1]], 80),
     main = "Detected features in a matrix",
     xlab = "m/z", ylim = c(0, 0.01), lwd = 2)
for (i in 2:4) {
    lines(density(res_matrix_pos$mzmed[present_call[, i]], na.rm = TRUE), 
          col = paste0(col_source[colnames(present_call)[i]], 80), lwd = 2)
}
legend("topleft", legend = c(colnames(present_call)),
       col = col_source[colnames(present_call)], pch = 16)
#' retention time
plot(density(res_matrix_pos$rtmed[present_call[, 1]], na.rm = TRUE),
     col = paste0(col_source[colnames(present_call)[1]], 80),
     main = "Detected features in a matrix",
     xlab = "rt", ylim = c(0, 0.015), lwd = 2)
for (i in 2:4) {
    lines(density(res_matrix_pos$rtmed[present_call[, i]], na.rm = TRUE), 
          col = paste0(col_source[colnames(present_call)[i]], 80), lwd = 2)
}

```

In contrast to the full data set, the distribution of m/z and retention times
for detected features of the measured standards are very similar between the
matrices.

```{r mzSignificant, fig.cap = "Distributions of m/z values (left) and retention times (right) for features with significant different abundances compared to the levels in capillary samples.", echo = FALSE, fig.width = 12, fig.height = 6, fig.path = IMAGE_PATH}
par(mfrow = c(1, 2), mar = c(4.3, 4.3, 1, 1))
#' m/z
plot(density(res_matrix_pos$mzmed, na.rm = TRUE),
     col = "#cecece", main = "Significant features",
     xlab = "m/z", ylim = c(0, 0.01), lwd = 2)
for (i in 1:3) {
    lines(density(
        res_matrix_pos$mzmed[res_matrix_pos[, paste0("significant.",
                                                     SourcesTypes[i])]],
        na.rm = TRUE), col = paste0(col_source[TestedSourcenames[i]], 80),
        lwd = 2)
}
legend("topleft", legend=c("All features", TestedSourcenames), 
       col = c("#cecece", col_source[TestedSourcenames]), pch = 16)
#' rt
plot(density(res_matrix_pos$rtmed, na.rm = TRUE),
     col = "#cecece", main = "Significant features",
     xlab = "rt", ylim = c(0, 0.04), lwd = 2)
for (i in 1:3) {
    lines(density(
        res_matrix_pos$rtmed[res_matrix_pos[, paste0("significant.",
                                                     SourcesTypes[i])]],
        na.rm = TRUE), col = paste0(col_source[TestedSourcenames[i]], 80),
        lwd = 2)
}

```

Also regarding the m/z and retention time distribution for the significant
features all matrices are similar.

```{r mzCountsSignificant, fig.cap = "Distribution of m/z values (left) and retention time (right) for significant features with a higher or lower abundance compared to capillary samples.", echo = FALSE, fig.width = 12, fig.height = 6, fig.path = IMAGE_PATH}

par(mfrow = c(1, 2), mar = c(4.3, 4.3, 1.5, 1))
plot(x = 1, y = 1, pch = NA, xlim = c(50, 1100), ylim = c(-15, 15),
     xlab = "m/z", ylab = "count", main = "Significant features")
text(x = c(50, 50), y = c(-10, 10), pos = c(4, 4),
     label = c("lower abundance than capillary",
               "higher abundance than capillary"))
for (src in TestedSourcenames) {
    yLow <- res_matrix_pos[
        which(res_matrix_pos[, paste0("significant.source", src)] & 
              res_matrix_pos[, paste0("coef.source", src)] < 0), "mzmed"]
    yLow <- hist(yLow, breaks = seq(50, 1100, 20), plot = FALSE)   
    yHigh <- res_matrix_pos[
        which(res_matrix_pos[, paste0("significant.source", src)] & 
              res_matrix_pos[, paste0("coef.source", src)] > 0), "mzmed"]
    yHigh <- hist(yHigh, breaks = seq(50, 1100, 20), plot = FALSE)
    lines(yHigh$mids, yHigh$counts, col = paste0(col_source[src], 80), lwd = 2)
    lines(yLow$mids, -yLow$counts, col = paste0(col_source[src], 80), lwd = 2)
}
grid()
abline(h = 0)
legend("topright", legend = TestedSourcenames, lwd = 2, lty = 1,
       col = col_source[TestedSourcenames], inset = c(0, 0))
plot(x = 1, y = 1, pch = NA, xlim = c(0, 250), ylim = c(-20, 20),
     xlab = "rt", ylab = "count", main = "Significant features")
text(x = c(0, 0), y = c(-15, 15), pos = c(4, 4),
     label = c("lower abundance than capillary",
               "higher abundance than capillary"))
for (src in TestedSourcenames) {
    yLow <- res_matrix_pos[
        which(res_matrix_pos[, paste0("significant.source", src)] & 
              res_matrix_pos[, paste0("coef.source", src)] < 0), "rtmed"]
    yLow <- hist(yLow, breaks = seq(0, 250, 20), plot = FALSE)   
    yHigh <- res_matrix_pos[
        which(res_matrix_pos[, paste0("significant.source", src)] & 
              res_matrix_pos[, paste0("coef.source", src)] > 0), "rtmed"]
    yHigh <- hist(yHigh, breaks = seq(0, 250, 20), plot = FALSE)
    lines(yHigh$mids, yHigh$counts, col = paste0(col_source[src], 80), lwd = 2)
    lines(yLow$mids, -yLow$counts, col = paste0(col_source[src], 80), lwd = 2)
}
grid()
abline(h = 0)

```

Due to the small number of tested features the plots are not so informative and
also hard to interpret. Still, no big differences are observable.

# Result object

The results of this analysis are exported to the
*vams_matrix_pos_semtar_results.xlsx* file.

```{r writexl}
library(writexl)
write_xlsx(as.data.frame(res_matrix_pos),
           path = "data/xls/vams_matrix_pos_semtar_results.xlsx")

save(res_matrix_pos, file = paste0(RDATA_PATH, "res_matrix_pos_semtar.RData"))
```

The most important columns in the result table are:
- `mzmed`, `mzmin`, `mzmax`: m/z of the feature.
- `rtmed`, `rtmin`, `rtmax`: retention time window of the feature.
- `QC_rsd`: RSD over QC samples.
- `coef.source<matrix>`: log2 fold change of feature abundance between
  `<matrix>` and capillary samples.
- `pvalue.source<matrix>`: p-value representing the significance of the
  difference in abundances between `<matrix>` and capillary samples. These are
  raw (unadjusted) p-values and should only considered for sorting of the
  features.
- `adj.pvalue.source<matrix>`: p-values adjusted for multiple hypothesis
  testing representing the significance of differential abundance.
- `significant.source<matrix>`: logical indicating whether the feature was
  identified to have a significant difference in abundances.
- `present.<matrix>`: *present* call of the feature from the qualitative
  analysis.


# Session information

```{r sessionInfo}
devtools::session_info()
```
