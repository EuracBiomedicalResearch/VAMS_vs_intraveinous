---
title: "Preprocessing (negative) of the vams vs intraveneous untargeted metabolomics data"
author: "Chiara Volani, Beatrice Giaier, Mar Garcia-Aloy, Vinicius Veri Hernandes and Johannes Rainer"
graphics: yes
output:
  BiocStyle::html_document:
    toc_float: true
bibliography: references.bib
csl: biomed-central.csl
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

```{r biocstyle, echo = FALSE, results = "asis" }
library(BiocStyle)
BiocStyle::markdown() 
```

**Modified**: `r file.info("vams_preprocessing.Rmd")$mtime`<br />
**Compiled**: `r date()`

```{r settings, echo = FALSE, results = "hide", message = FALSE}
#' Set general options
options(useFancyQuotes = FALSE)
set.seed(123)

#' Define paths:
filename <- "vams_preprocessing_neg"
#' Path to save the images; remove all old images.
IMAGE_PATH <- paste0("C:/Users/bgiaier/Documents/Eurac/VAMS_vs_intraveinous/images/",filename, "/")
dir.create(IMAGE_PATH, recursive = TRUE, showWarnings = FALSE)
#' Path to store RData files
RDATA_PATH <- paste0("data/RData/", filename, "/")
if (!file.exists(RDATA_PATH)) dir.create(RDATA_PATH, recursive = TRUE)

#' Define the path where we can find the mzML files:
MZML_PATH <- "C:/Users/bgiaier/Documents/Eurac/vams/VAMS"
if (!file.exists(MZML_PATH))
    stop("Can not find the directory with the mzML files: ", MZML_PATH)

#' Where to cut the chromatogram (i.e. subset to spectra within rt 0-rt_cut)
rt_cut <- 340

#' Get the number of cpus allocated or fall back to 3 
ncores <- as.integer(Sys.getenv("SLURM_JOB_CPUS_PER_NODE", 3))

#' Whether or not to plot the EICs for all standards - takes loooong time
plot_eics <- TRUE

#' rt_tol: accepted deviation of a standards retention time to the theoretical
#' one.
rt_tol <- 40
```

# Introduction
 
In this section we perform the pre-processing of the untargeted metabolomics
data of the *MitYOU* project which comprises an initial quality assessment,
chromatographic peak detection, alignment (retention time correction) and
correspondence (chromatographic peak grouping across samples).

# Negative polarity

We now focus on the data in negative polarity.

## Raw data import and initial quality assessment

Below we load all required libraries for the analysis as well as the *phenodata*
file defining the experiment's layout. Also, we set up the parallel processing,
define colors to be used for the various experimental groups throughout the
experiment and finally read the raw data.

```{r neg-libraries-data, message = FALSE}
library(xcms)
library(RColorBrewer)
library(pander)
library(pheatmap)
library(MsCoreUtils)
library(Rdisop)
library(CompMetaboTools)

## Use socket based parallel processing on Windows systems
if (.Platform$OS.type == "unix") {
    register(bpstart(MulticoreParam(ncores)))
} else {
    register(bpstart(SnowParam(ncores)))
}

pd <- read.table("data/phenodata.txt", sep = "\t", as.is = TRUE, header = TRUE)
pd_neg <- pd[pd$polarity == "NEG", ]

#' Define colors for the groups.
col_source <- brewer.pal(5, name = "Set1")
names(col_source) <- c("RBC",           # red
                       "plasma",        # blue
                       "all",           # green
                       "capillary",     # purple
                       "venous")        # orange
```

```{r neg-data_neg, message = FALSE}
#' Read the data
data_neg <- readMSData(paste0(MZML_PATH, "/", pd_neg$mzML_file),
                       pdata = as(AnnotatedDataFrame(pd_neg),
                                  "NAnnotatedDataFrame"), mode = "onDisk")
data_neg <- filterRt(data_neg, rt = c(0, rt_cut))

#' Add the time stamp from the individual files and check if they
#' match the injection index
time_stamp <- extract_time_stamp(fileNames(data_neg))
data_neg$time_stamp <- time_stamp
stopifnot(!is.unsorted(time_stamp))
```

All samples of the experiment are listed below.

```{r neg-phenodata, message = FALSE, results = "asis", echo = FALSE}
validatePdata <- function(x) {
    src <- c(`1` = "plasma", `2` = "venous", `3` = "capillary", RBC = "RBC")
    fn <- strsplit(x$mzML_file, split = "_")
    for (i in 1:nrow(x)) {
        splt <- fn[[i]]
        if (splt[1] != x$batch[i])
            message("Row ", i, ": batch wrong")
        if (length(splt) == 5) {
            if (as.numeric(splt[2]) != x$sample[i])
                message("Row ", i, ": sample wrong")
            if (src[splt[3]] != x$source[i])
                message("Row ", i, ": source wrong")
            if ((splt[4] == "a" & x$replicate[i] != 1) ||
                (splt[4] == "b" & x$replicate[i] != 2))
                message("Row ", i, ": replicate wrong")
        } else {
            if (x$sample[i] != "POOL")
                message("Row ", i, ": sample wrong")
        }
    }
}
#' validatePdata(pData(data_neg))

tab <- pData(data_neg)[, -4]
pandoc.table(tab, style = "rmarkdown",
             caption = paste0("Data files and samples for negative polarity"))

```

The injection order layout of one measurement run is visualized below.

```{r neg-run-plot, fig.width = 10, fig.height = 2, fig.path = IMAGE_PATH, fig.cap = "Layout of a measurement run."}
tmp <- pData(data_neg)[data_neg$batch == "2018_02/06022018", ]
par(mar = c(2, 0, 2, 0))
plot(3, 3, pch = NA, xaxt = "n", yaxt = "n", ylim = c(0, 2),
     xlim = c(0.5, nrow(tmp) + 0.5), bty = "n")
rect(xleft = tmp$inj_idx - 0.5, xright = tmp$inj_idx + 0.5, ybottom = 0,
     ytop = 1, col = col_source[tmp$source], border = "grey")
axis(side = 1, line = 0, las = 2)
text(x = tmp$inj_idx, y = rep(0.5, nrow(tmp)), labels = tmp$sample,
     srt = 90, cex = 0.7)
legend("top", col = col_source, legend = names(col_source), horiz = TRUE,
       pch = 15)
```

Sample source type and individuals are randomly distributed along the injection
order.

Next we perform an initial quality assessment by comparing the distribution of
TIC and BPC values from the spectra between all samples.

```{r neg-calc-tic, message = FALSE}
chrs_bpc <- chromatogram(data_neg, aggregationFun = "max")
```

The base peak chromatogram for the full experiment is shown below.

```{r neg-bpc-plot, message = FALSE, echo = FALSE, fig.path = IMAGE_PATH, fig.width = 12, fig.height = 5, fig.cap = "Base peak chromatograms for all samples of the experiment (negative polarity)."}
plot(chrs_bpc, col = paste0(col_source[chrs_bpc$source], "60"))
legend("topright", col = col_source, legend = names(col_source), lwd = 2)
```

The base peak chromatograms are quite similar between the different sample
sources. For plasma and venous samples higher intensities are observed. However, differences are less stiking than it was observed in the positive run suggesting 
that similar compounds are detected. In the range 40 - 110 seconds the BPCs of 
all types indicate problems during sample measurement and/or sample preparation. We next cluster samples based on pair-wise correlations of their (log2) base 
peak intensities.

```{r neg-bin-chr, echo = FALSE, message = FALSE, warning = FALSE, fig.width = 12, fig.height = 12, fig.cap = "Samples clustered by base peak chromatogram. Clustering bases on complete linkage hierarchical clustering of pairwise correlations of log2 base peak signals."}
#' First we have to bin the chromatograms to force them having the same
#' retention times.
chrs_bin <- MSnbase::bin(chrs_bpc)

#' Calculating the correlation on the log2 transformed bp signals
cormat <- cor(log2(do.call(cbind, lapply(chrs_bin, intensity))))
colnames(cormat) <- rownames(cormat) <- sampleNames(data_neg)
ann <- pData(data_neg)[, c("batch", "source")]
ann$batch <- factor(ann$batch, levels = c("2018_02/06022018", "2018_02/07022018"))
res <- pheatmap(cormat, annotation_col = ann, cutree_cols = 3,
                annotation_color = list(source = col_source))

```

The base peak chromatograms cluster mainly by the sample source, separating
mostly capillary samples and red blood cells from other sources (i.e. plasma,
all, and venous samples). Two cluster of samples, consisting exclusively of
capillary and red blood cell samples and originating from both batches, separate
from all others samples.

The samples belonging to the first and second cluster, respectively, of 
capillary and red blood samples that separates from all other samples are listed 
in the two tables below.

```{r neg-cluster-one-sample-table, echo = FALSE, results = "asis"}
clust_one <- cutree(res$tree_col, 2)
clust_one_idx <- which(clust_one == 2)
tab <- pData(data_neg)[clust_one_idx, c("batch", "sample",
                                        "source", "replicate", "inj_idx")]
pandoc.table(tab[order(tab$sample), ], style = "rmarkdown",
             caption = paste("Samples separating from all others based on",
                             "their base peak chromatograms."))
```

```{r neg-cluster-two-sample-table, echo = FALSE, results = "asis"}
clust_two <- cutree(res$tree_col, 3)
clust_two_idx <- which(clust_two == 3)
tab <- pData(data_neg)[clust_two_idx, c("batch", "sample",
                                        "source", "replicate", "inj_idx")]
pandoc.table(tab[order(tab$sample), ], style = "rmarkdown",
             caption = paste("Samples separating from all others based on",
                             "their base peak chromatograms."))
```

As described already above, the potential outlier samples are exclusively RBC
and capillary blood samples. For individuals *1*, *11*, *12*, *16*, *17*, *18*,
*19*, *2*, *20* in the first cluster and samples *1*, *10*, *11*, *12*, *13*, 
*14*, *17*, *20*, *21*, *22*, *3*, *5*, *6*, *7*, *8* and *9* in the second 
cluster both replicates are affected suggesting a potential problem with the extraction or the sample tube. For all the others the actual measurement might be 
failed, since the other replicate was not affected. Note that no batch 
dependency can be observed.

In the plot below the base peak chromatogram of samples from this cluster are
highlighted.

```{r neg-cluster-one-bpc-plot, echo = FALSE, fig.width = 12, fig.height = 5, fig.cap = "Base peak chromatogram with samples identified as potential outliers being highlighted in red."}
col_clust <- c("#00000020", "#ff000080")
plot(chrs_bpc, col = col_clust[clust_one])

#' cols <- rep("#00000020", length(chrs_bpc$source))
#' cols[chrs_bpc$sample %in% c("16", "19")] <- "#ff000080"
#' #'cols[c(74, 178)] <- "#ff000080"
#' plot(chrs_bpc, col = cols)

```

```{r, echo = FALSE, eval = FALSE}
#' Perform the PCA
pc <- prcomp(t(log2(do.call(cbind, lapply(chrs_bin, intensity)))),
             scale = FALSE, center = TRUE)
par(mfrow = c(1, 3))
plot_pca(pc, col = col_clust[clust_one], pc_x = 1, pc_y = 2)
legend("topleft", col = col_clust, legend = c("all", "outlier"), lwd = 2, cex=0.8)
plot_pca(pc, col = col_clust[clust_one], pc_x = 3, pc_y = 4)
plot_pca(pc, col = col_clust[clust_one], pc_x = 2, pc_y = 3)
text(pc$x[, 2], pc$x[, 3], label = sampleNames(chrs_bin),
     col = col_clust[clust_one])


#' cols <- rep("#00000040", length(chrs_bin$source))
#' keep_idx <- c(166, 169, 133, 192, 111, 125, 113, 157)
#' rem_idx <- c(74, 158, 172, 174, 194, 177, 149, 186, 188, 167, 178)
#' cols[keep_idx] <- "#0000ff80"
#' cols[rem_idx] <- "#ff000080"

#' BioCHRIStes::plot_pca(pc, col = cols, pc_x = 2, pc_y = 3)

#' plot(chrs_bpc, col = cols)

```

Next we evaluate the distribution of base peak and total ion values per sample
to identify potentially problematic samples/injections. In addition we calculate
per-sample RLA values.

```{r neg-bpc-boxplot, message = FALSE, fig.path = IMAGE_PATH, fig.width = 12, fig.height = 6, fig.cap = "Distribution of the spectras' base peak signal per sample (top) and average RLA of base peak signals per sample (bottom). Potential outlier samples identified based on their base peak intensities are indicated with squares."}
bpcs <- lapply(chrs_bpc, intensity)
xl <- c(1, length(bpcs))
par(mfrow = c(2, 1), mar = c(0, 4.3, 0, 0.1))
boxplot(lapply(bpcs, log2), col = paste0(col_source[chrs_bpc$source], 60),
        pch = NA, xaxt = "n", ylab = expression(log[2]~base~peak~intensity),
        xlim = xl)
grid(nx = NULL)
par(mar = c(3, 4.3, 0.5, 0.1))
bpcs_rla <- rla(vapply(bpcs, mean, numeric(1)), f = chrs_bpc$source)
pch <- rep(16, length(bpcs_rla))
pch[clust_one_idx] <- 15
plot(bpcs_rla, xlab = "", ylab = "average RLA", xlim = xl,
     col = paste0(col_source[chrs_bpc$source], 80), pch = pch)
grid(nx = NULL)

```

Overall seen, the signals are more equal distributed than it was observed in the
positive run, with no striking differences visible between the first and second 
batch. Although, the distribution of the base peak signals varies strongly 
between samples with stretches of measurements in both batches showing lower distribution than samples measured before or after (especially visible for 
capillary and RBC samples). Three red blood cell samples (two in the first and 
two in the second batch), as well as one QC (in the first batch) have much lower average base peak intensities, most likely due to a failed injection (because 
the signal of the replicated measurement is *normal*) and should thus be 
excluded from the analysis.  Only 6 of 70 samples identified as potential 
outliers based on the correlation of their base peak chromatograms deviate from 
other samples based on their base peak RLA value.  Below we list all samples for which one replicate yielded a more than two-fold difference in average base peak signal.

```{r neg-bpc-outlier, echo = FALSE, message = FALSE, results = "asis"}
outl <- abs(bpcs_rla) > 1
outl_smps <- paste0(chrs_bpc$sample[outl], chrs_bpc$source[outl])
all_outl <- paste0(chrs_bpc$sample, chrs_bpc$source) %in% outl_smps
tab <- cbind(pData(chrs_bpc)[all_outl, ], bpc_rla = bpcs_rla[all_outl])

pandoc.table(tab[order(abs(tab$bpc_rla), decreasing = TRUE), ],
             style = "rmarkdown", 
             caption = paste0("Samples for which one replicated measurement ",
                              "had a more than two-fold difference in average",
                              " base peak intensity."))
```

For all of the above samples one of the two replicates yielded a more than
two-fold difference in average base peak intensity, while the other did not. We
might thus exclude the problematic replicate for these samples.

### Summary

The base peak and total ion chromatogram between samples from the various
sources are slightly different. The distribution of signals does also show a relatively large variation between all samples, with the signal being generally higher for plasma and venous samples. Six potentially problematic samples have 
been spotted that show either more than two-fold lower or higher average base 
peak intensity than other samples from the same source. All are RBC samples. 
This is most likely caused by a failed/problematic injection, because one 
replicate is affected.

## Chromatographic peak detection

We load below the most likely adduct and the expected retention time for the standards defined in [this repository](http://github.com/EuracBiomedicalResearch/lcms-standards).

```{r known-cmps, warning = FALSE}
library(CompoundDb)
std_info <- read.table(
"https://raw.githubusercontent.com/EuracBiomedicalResearch/lcms-standards/master/data/standards_dilution.txt",
    sep = "\t", header = TRUE, as.is = TRUE)
std_info <- std_info[!is.na(std_info[, grep("NEG", colnames(std_info))]), ]
rownames(std_info) <- 1:nrow(std_info)
std_info$mzneut = NA
std_info$mz_ion = NA
for (i in seq(nrow(std_info))) {
    if (grepl("C", std_info$formula[i])){
        std_info$mzneut[i] <- getMolecule(
            as.character(std_info$formula[i]))$exactmass
    } else {
        std_info$mzneut[i] = as.numeric(std_info$formula[i])
    }
    #' Calculate also the m/z
    std_info$mz_ion[i] <- unlist(
        mass2mz(std_info$mzneut[i],
                adduct = as.character(
                    std_info[i, grep("NEG", colnames(std_info))])))
}
```

The centwave parameter are the same established for the positive MS run, namely,
`ppm = 50` and `peakwidth = c(2, 20)`).

```{r neg-centWave, message = FALSE, warning = FALSE, eval = !file.exists(paste0(RDATA_PATH, "data_neg_pks.RData"))}
cwp <- CentWaveParam(ppm = 50,
                     peakwidth = c(2, 20),
                     snthresh = 10,
                     mzdiff = 0.001,
                     prefilter = c(3, 800),
                     noise = 100,
                     integrate = 2)

data_neg <- findChromPeaks(data_neg, param = cwp)
save(data_neg, file = paste0(RDATA_PATH, "data_neg_pks.RData"))
```

```{r neg-centWave-cached, echo = FALSE, eval = file.exists(paste0(RDATA_PATH, "data_neg_pks.RData"))}
load(paste0(RDATA_PATH, "data_neg_pks.RData"))
n_peaks_before <- nrow(chromPeaks(data_neg))
```

Next we are post-processing the identified chromatographic peaks to reduce the
amount of peak detection artifacts such as largely overlapping peaks or
artificially split peaks.

```{r neg-centWave-refine, message = FALSE, warning = FALSE, eval = !file.exists(paste0(RDATA_PATH, "data_neg_refined.RData"))}
mnp <- MergeNeighboringPeaksParam(expandRt = 2.5, expandMz = 0.001,
                                  minProp = 3/4)
data_neg <- refineChromPeaks(data_neg, param = mnp)
save(data_neg, file = paste0(RDATA_PATH, "data_neg_refined.RData"))
```

```{r, eval = file.exists(paste0(RDATA_PATH, "data_neg_refined.RData")), echo = FALSE}
load(paste0(RDATA_PATH, "data_neg_refined.RData"))
```

Merging neighboring peaks reduced the total number of peaks in the
data set from `r n_peaks_before` to `nrow(chromPeaks(data_neg))`.

```{r neg-centWave-eic-plots, echo = FALSE, eval = plot_eics}
#' Two-step approach: define first the rt/mz region for each standard and
#' extract the chromatogram afterwards.
std_info_mz_rt <- matrix(
    ncol = 4, nrow = nrow(std_info),
    dimnames = list(std_info$name, c("mzmin", "mzmax", "rtmin", "rtmax")))
for (i in 1:nrow(std_info)) {
    pks <- chromPeaks(data_neg, mz = std_info$mz_ion[i], ppm = 50)
    if (nrow(pks)) {
        rtdiff <- abs(pks[, "rt"] - std_info$RT[i])
        keep <- which(rtdiff < rt_tol)
        if (length(keep)) {
            pks <- pks[keep, , drop = FALSE]
            mzr <- range(pks[, c("mzmin", "mzmax")])
            rtr <- range(pks[, c("rtmin", "rtmax")], std_info$RT[i])
            std_info_mz_rt[i, ] <- c(mzr, rtr)
        }
    }
}
std_info <- std_info[!is.na(std_info_mz_rt[, "mzmin"]), ]
std_info_mz_rt <- std_info_mz_rt[!is.na(std_info_mz_rt[, "mzmin"]), ]

#' Extract the ion chromatogram for each standard
rtr <- std_info_mz_rt[, c("rtmin", "rtmax")]
rtr[, 1] <- rtr[, 1] - 10
rtr[, 2] <- rtr[, 2] + 10
std_info_chr <- chromatogram(
    data_neg, mz = std_info_mz_rt[, c("mzmin", "mzmax")],
    rt = rtr, aggregationFun = "max")

#' Plot the extracted ion chromatograms
dr <- paste0(IMAGE_PATH, "peakdetection/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
sample_colors <- col_source[data_neg$source]
for (i in 1:nrow(std_info)) {
    cmpname <- gsub("L-", "", std_info$name[i])
    cmpname <- tolower(gsub(" .*", "", cmpname))
    filename <- paste0(dr, i, "-", cmpname, "_", "NEG", ".png")
    png(file = filename, width = 16, height = 8, units = "cm",
        res = 300, pointsize = 4)
    chr <- std_info_chr[i, ]
    pks <- chromPeaks(chr)
    plot(chr, col = "#00000040",
         main = paste0(std_info$name[i], ": ",
                       format(mz(chr)[1], digits = 6), "-",
                       format(mz(chr)[2], digits = 6)),
         peakCol = paste0(sample_colors[pks[, "column"]], 50),
         peakBg = paste0(sample_colors[pks[, "column"]], 10))
    #' This is just to indicate identified peaks with a rectangle.
    xcms:::.add_chromatogram_peaks(
               chr, pks,
               col = paste0(sample_colors[pks[, "column"]], 40),
               bg = NA,
               type = "rectangle")
    abline(v = std_info$RT[i])
    dev.off()
}
```

```{r neg-centWave-manual-check, echo = FALSE, eval = FALSE}
#' Go manually through all generated plots above and determine which peaks
#' look OK.
std_info$RT_obs <- NA_real_
std_info$is_ok <- FALSE
std_info$peak_note <- NA_character_
write.table(std_info, file = "data/std_info_neg.txt", row.names = FALSE, sep = "\t")
```

```{r neg-centWave-manual-check-import, echo = FALSE, warning = FALSE}
std_info <- read.table("data/std_info_neg_checked.txt", sep = "\t", as.is = TRUE,
                       header = TRUE)
std_info <- std_info[std_info$is_ok, ]

#' Select for each standard the peaks overlapping with the observed rt.
std_info_mz_rt <- matrix(nrow = nrow(std_info), ncol = 4,
                         dimnames = list(std_info$name,
                                         c("mzmin", "mzmax", "rtmin", "rtmax")))
for (i in 1:nrow(std_info)) {
    pks <- chromPeaks(data_neg, mz = std_info$mz_ion[i], ppm = 50,
                      rt = std_info$RT_obs[i])
    if (nrow(pks)) {
        mzr <- range(pks[, c("mzmin", "mzmax")])
        rtr <- range(pks[, c("rtmin", "rtmax")])
        std_info_mz_rt[i, ] <- c(mzr, rtr)
    }
}
std_info <- std_info[!is.na(std_info_mz_rt[, "mzmin"]), ]
std_info_mz_rt <- std_info_mz_rt[!is.na(std_info_mz_rt[, "mzmin"]), ]
```

```{r neg-centWace-eics-refined, echo = FALSE, eval = plot_eics, warning = FALSE, message = FALSE}
#' Extract the ion chromatogram for each standard
rtr <- std_info_mz_rt[, c("rtmin", "rtmax")]
rtr[, 1] <- rtr[, 1] - 10
rtr[, 2] <- rtr[, 2] + 10
std_info_chr <- chromatogram(
    data_neg, mz = std_info_mz_rt[, c("mzmin", "mzmax")],
    rt = rtr, aggregationFun = "max")

#' Plot the extracted ion chromatograms
dr <- paste0(IMAGE_PATH, "peakdetection-standards/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
sample_colors <- col_source[data_neg$source]
for (i in 1:nrow(std_info)) {
    cmpname <- gsub("L-", "", std_info$name[i])
    cmpname <- tolower(gsub(" .*", "", cmpname))
    filename <- paste0(dr, i, "-", cmpname, "_", "NEG", ".png")
    png(file = filename, width = 16, height = 8, units = "cm",
        res = 300, pointsize = 4)
    chr <- std_info_chr[i, ]
    pks <- chromPeaks(chr)
    plot(chr, col = "#00000040",
         main = paste0(std_info$name[i], ": ",
                       format(mz(chr)[1], digits = 6), "-",
                       format(mz(chr)[2], digits = 6)),
         peakCol = paste0(sample_colors[pks[, "column"]], 50),
         peakBg = paste0(sample_colors[pks[, "column"]], 10))
    #' This is just to indicate identified peaks with a rectangle.
    xcms:::.add_chromatogram_peaks(
               chr, pks,
               col = paste0(sample_colors[pks[, "column"]], 40),
               bg = NA,
               type = "rectangle")
    ## abline(v = std_info$RT[i])
    abline(v = std_info$RT_obs[i], lty = 2)
    dev.off()
}
```

```{r echo = FALSE, eval = FALSE}
## Plot EICs for peaks that were merged by the *refinement* step.
load(paste0(RDATA_PATH, "data_neg_pks.RData"))
data_neg_pks <- data_neg
load(paste0(RDATA_PATH, "data_neg_refined.RData"))

merged_rand <- sample(which(chromPeakData(data_neg)$merged), 100)

dr <- paste0(IMAGE_PATH, "random_merged_peaks/")
dir.create(dr, showWarnings = FALSE)
for (i in merged_rand) {
    pk <- chromPeaks(data_neg)[i, , drop = FALSE]
    rtr <- pk[1, c("rtmin", "rtmax")] + c(-10, 10)
    mzr <- pk[1, c("mzmin", "mzmax")] + c(-0.005, 0.005)
    chr_1 <- chromatogram(filterFile(data_neg_pks, pk[1, "sample"]),
                          rt = rtr, mz = mzr)
    chr_2 <- chromatogram(filterFile(data_neg, pk[1, "sample"]),
                          rt = rtr, mz = mzr)
    png(file = paste0(dr, rownames(pk), ".png"), width = 12, height = 12,
        units = "cm", res = 300, pointsize = 4)
    par(mfrow = c(2, 1))
    plot(chr_1, peakCol = paste0(sample_colors[pk[1, "sample"]], 50),
         peakBg = paste0(sample_colors[pk[1, "sample"]], 10))
    plot(chr_2, peakCol = paste0(sample_colors[pk[1, "sample"]], 50),
         peakBg = paste0(sample_colors[pk[1, "sample"]], 10))
    dev.off()
}

#' Check merged peaks for Glucose...
#idx <- which(std_info$name == "Glucose")
#rtr <- std_info$RT_obs[idx] + c(-10, 10)
#mzr <- std_info[idx, c("mz_ion")] + c(-0.01, 0.01)
#pks <- chromPeaks(data_neg, mz = mzr, rt = rtr)
#is_merged <- which(chromPeakData(data_neg)[rownames(pks), "merged"])
#for (i in is_merged) {
    #chr_1 <- chromatogram(filterFile(data_neg_pks, pks[i, "sample"]),
                          #rt = rtr, mz = mzr)
    #chr_2 <- chromatogram(filterFile(data_neg, pks[i, "sample"]),
                          #rt = rtr, mz = mzr)
    #png(file = paste0(dr, "Glucose_", i, ".png"), width = 12, height = 12,
        #units = "cm", res = 300, pointsize = 4)
    #par(mfrow = c(2, 1))
    #plot(chr_1, peakCol = paste0(sample_colors[pks[i, "sample"]], 50),
         #peakBg = paste0(sample_colors[pks[i, "sample"]], 10))
    #plot(chr_2, peakCol = paste0(sample_colors[pks[i, "sample"]], 50),
         #peakBg = paste0(sample_colors[pks[i, "sample"]], 10))
    #dev.off()    
#}

#mzr <- c(225.0553, 491.0636)
#rtr <- c(140, 200)
#chr_1 <- chromatogram(filterFile(data_neg_pks, 74), mz = mzr, rt = rtr)
#chr_2 <- chromatogram(filterFile(data_neg, 74), mz = mzr, rt = rtr)
#par(mfrow = c(2, 1))
#plot(chr_1)
#plot(chr_2)

#mzr <- c(225.0583, 225.0653)
#rtr <- c(155, 180)
#chr_1 <- chromatogram(filterFile(data_neg_pks, 111), mz = mzr, rt = rtr)
#chr_2 <- chromatogram(filterFile(data_neg, 111), mz = mzr, rt = rtr)
#par(mfrow = c(2, 1))
#plot(chr_1)
#plot(chr_2)

```

Results from the peak merging were validated manually by inspecting 100 random
merged peaks. In most cases merging resulted in better peak integration. Most
importantly, peak merging removes any completely overlapping peaks which would
result in the correspondence analysis to artificially inflated quantified
feature abundances (if `method = "sum"` is used).

For the in total `r nrow(std_info)` standards for which retention times have
been determined (in water), `r sum(std_info$is_ok)` are considered *detected* in
the present data set after manually inspecting the detected peaks close to the
expected retention time.

The table below summarizes the results of the chromatographic peak detection for
the list of these *known compounds*.

```{r neg-known-compounds-peak-summary, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}
std_info <- std_info[std_info$is_ok, , drop = FALSE]

#' Calculate summaries on peaks overlapping an MS slice.
#'
#' @return
#'
#' `numeric()` with:
#' - average rt peak width `"rt_width"`
#' - average mz peak width `"mz_width"`
#' - average mz peak width in ppm `"mz_width_ppm"`
#' - average difference of the peak m/z to the theoretical m/z in ppm `"mz_ppm"`
#' - number of samples in which more than one peak was found `"multi_pk_count"`
#' - percentage of samples within each group in which a peak was found.
slice_peak_summary <- function(rtr, mzr, mz = NULL, x, group, ppm = 10) {
    if (missing(group))
        group <- rep("all", length(fileNames(x)))
    group <- factor(group, levels = unique(group))
    if (missing(x))
        stop("'x' has to be submitted.")
    pks <- chromPeaks(x, rt = rtr, mz = mzr, type = "apex_within", ppm = ppm)
    if (nrow(pks)) {
        pks <- cbind(pks,
                     rt_width = pks[, "rtmax"] - pks[, "rtmin"],
                     mz_width = pks[, "mzmax"] - pks[, "mzmin"])
        pks <- cbind(pks,
                     mz_width_ppm = pks[, "mz_width"] * 1e6 / pks[, "mz"])
        if (length(mz))
            mz_ppm <- mean(abs(pks[, "mz"] - mz) * 1e6 / mz)
        else mz_ppm <- NA_real_
        #' Number of samples in which multiple peaks were identified.
        pk_cnt_smpl <- table(factor(pks[, "sample"],
                                    levels = 1:length(fileNames(x))))
        #' Percentage per source in which a peak was identified.
        pk_perc <- split(as.numeric(pk_cnt_smpl), group)
        percs <- unlist(lapply(pk_perc, function(z) 100 * sum(z > 0) / length(z)))
        c(rt_width = mean(pks[, "rt_width"]),
          mz_width = mean(pks[, "mz_width"]),
          mz_width_ppm = mean(pks[, "mz_width_ppm"]),
          mz_ppm = mz_ppm,
          multi_pk_count = sum(pk_cnt_smpl > 1),
          percs)
    } else {
        percs <- rep(NA_real_, length(unique(group)))
        names(percs) <- unique(group)
        c(rt_width = NA_real_, mz_width = NA_real_, mz_width_ppm = NA_real_,
          mz_ppm = NA_real_, multi_pk_count = NA_real_, percs)
    }
}

#' Iterate through rows to determine statistics for samples:
std_info_pks <- vector("list", nrow(std_info))
for (i in 1:nrow(std_info)) {
    rtr <- std_info$RT_obs[i] + c(-7, 7)
    mzr <- std_info$mz_ion[i]
    res <- slice_peak_summary(rtr, mzr, mz = std_info$mz_ion[i],
                              data_neg, data_neg$source, ppm = 50)
    if (is.na(res[1]))
        res <- slice_peak_summary(rtr, mzr, mz = std_info$mz_ion[i],
                                  data_neg, data_neg$source, ppm = 100)
    std_info_pks[[i]] <- res
}

std_info_pks <- data.frame(name = std_info$name, do.call(rbind, std_info_pks),
                           stringsAsFactors = FALSE)
std_info_pks$delta_rt <- std_info$RT_obs - std_info$RT

pandoc.table(std_info_pks, style = "rmarkdown",
             caption = paste("Summary for identified chromatographic peaks of",
                             "the known compounds. Columns rt_width, mz_width",
                             "and mz_width_ppm show the mean widths in",
                             "retention time and m/z dimension of the",
                             "peaks, mz_ppm the average difference between",
                             "the peaks' m/z and the theoretical m/z of the",
                             "ion, multi_pk_count the number of samples in",
                             "which more than one peak was identified",
                             "in the rt region and the remaining columns",
                             "the percentages of samples per group in which",
                             "a peak was identified. Columnn delta_rt ",
                             "contains the difference between the observed ",
                             "and the expected retention time."))
```

Next we evaluate the numbers of detected peaks, m/z and retention time widths of
the peaks and the distribution of integrated peak signals in all samples.

```{r neg-peaks-summary-plot, warning = FALSE, message = FALSE, fig.cap = "Summaries of identified chromatographic peaks. Shown are the number of detected peaks, their m/z widths and their integrated signal in each measured sample.", fig.width = 12, fig.height = 10}
#' Split the peaks per sample.
pk_list <- split.data.frame(chromPeaks(data_neg),
                            chromPeaks(data_neg)[, "sample"])
#' Calculate mz and rt widths
pk_list <- lapply(pk_list, function(z) {
    cbind(z, mz_width = z[, "mzmax"] - z[, "mzmin"],
          mz_width_ppm = (z[, "mzmax"] - z[, "mzmin"]) * 1e6 / z[, "mz"],
          rt_width = z[, "rtmax"] - z[, "rtmin"])
})

par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1))
barplot(unlist(lapply(pk_list, nrow)),
        col = paste0(col_source[data_neg$source], 80),
        ylab = "peak count", main = "Peak detection summary, NEG",
        ylim = c(0, 4000), xaxt = "n")
grid()
legend("top", horiz = TRUE, col = col_source, pch = 15,
       legend = names(col_source))
par(mar = c(0, 4.3, 0, 0.1))
boxplot(lapply(pk_list, function(z) z[, "mz_width_ppm"]), outline = FALSE,
        ylab = "m/z width [ppm]", varwidth = TRUE, xaxt = "n",
        col = paste0(col_source[data_neg$source], 80))
#' boxplot(lapply(pk_list, function(z) z[, "rt_width"]), outline = FALSE,
#'         ylab = "rt width", varwidth = TRUE, xaxt = "n",
#'         col = paste0(col_source[data_neg$source], 80))
boxplot(lapply(pk_list, function(z) log2(z[, "into"])), outline = FALSE,
        ylab = expression(log[2]~intensity), varwidth = TRUE, xaxt = "n",
        col = paste0(col_source[data_neg$source], 80))

```

The numbers of detected peaks is between 2000 and 4000 with more peaks being
found in venous and capillary samples, while fewer were found in plasma
samples. RBC samples show the highest variability in the numbers of identified
peaks with four samples yielding a very low number of peaks (< 2000) and all 
others being however below 3000 counts. The m/z widths of identified peaks is on average near 10ppm with most of them being below the mark. Interestingly, the
distribution of integrated peak signals between samples is also highly similar,
which is relatively unexpected, since some samples did show considerably lower
base peak intensity signals.

The table below shows the per-sample median values summarized per source type.

```{r neg-peaks-summary-table, echo = FALSE, message = FALSE, results = "asis"}
#' Calculate per sample mean of
#' - peak count
#' - m/z width
#' - rt width
#' Aggregate these per sample group.
smpl_summary <- cbind(peak_count = vapply(pk_list, nrow, numeric(1)),
                      do.call(rbind, lapply(pk_list, function(z) {
                          c(median_mz_width = median(z[, "mz_width_ppm"]),
                            median_rt_width = median(z[, "rt_width"]))
                      })))
tab <- aggregate(smpl_summary, by = list(source = data_neg$source), quantile)
rownames(tab) <- tab[, 1]
tab <- tab[, -1]
pandoc.table(t(tab), style = "rmarkdown", 
             cap = paste("Summary of peak detection results. Shown are the",
                         "per-source quantiles of the numbers of identified",
                         "peaks, of the median m/z (in ppm) and rt widths",
                         " per sample."))
```

The per-sample median m/z width of the identified peaks is on average quite
low and consistent across sample types, same as the retention time width. The
only apparent differences are for the numbers of detected peaks. Unlike in 
positive MS run, the lowest numbers are found for red blood cell samples and 
the highest again for venous samples.

### Summary

On average about 10000 chromatographic peaks were identified per sample, with the
median m/z width of these peaks being quite small.

## Alignment

Chromatographic peaks have to be aligned using *peak groups* method and based on *hook* peaks. Note that before alignment we remove potentially problematic samples identified before. We are setting `binSize = 0.01`.

```{r neg-mz-distance-peaks-plot, message = FALSE, warning = FALSE, fig.cap = "Position of detected chromatographic peaks within a sample. Shown are chromatographic peaks in a region with high peak density. The horizontal blue line represents the bin width if binSize = 0.02 was used."}
plotChromPeaks(filterMz(data_neg, mz = c(756, 758)), 1)
abline(h = c(757, 757.01), col = "#0000ff80")
```

The `bw` parameter is defined below.

```{r neg-bw-definition-plot, echo = FALSE, message = FALSE, warning = FALSE, fig.cap = "Simulated peak grouing result on a m/z slice containing the Fructose and Mannose peaks. The upper panel shows the chromatogram for the MS data slice, the lower the position of the chromatographic peaks in that slice along the retention time axis (y-axis lists samples). The black line shows the density distribution for a bw = 1.3, the grey rectangles indicate the peaks that are grouped to a feature.", fig.width = 12, fig.height = 8}
plot_grouping <- function(x, mz, rt, param, col = "#00000080",
                          peak_type = "point", lwd = 1, ...) {
    if (missing(rt))
        rt <- range(rtime(x))
    chr_tmp <- chromatogram(x, mz = mz, rt = rt)
    col_tmp <- col[chromPeaks(chr_tmp)[, "sample"]]
    plotChromPeakDensity(chr_tmp, param = pdp_tmp, peakPch = 16,
                         col = paste0(col, 60),
                         peakCol = paste0(col_tmp, 40),
                         peakBg = paste0(col_tmp, 10))
}

mzr <- std_info[std_info$name == "Glucose", "mz_ion"] + c(-0.002, 0.002)
rtr <- c(140, 180)
pdp_tmp <- PeakDensityParam(sampleGroups = data_neg$source, bw = 1.3)
plot_grouping(data_neg, mz = mzr, rt = rtr, param = pdp_tmp,
              col = col_source[data_neg$source])
```

With a smoothing bandwidth `bw = 1.3` we are able to separate the Fructose and
Mannose peak (see plot above). However, because peak detection failed separating
peaks for the above example especially in plasma samples (data not shown) and
because in the present analysis, due to the comparison of different matrices, we
put less emphasis in the quantification of specific isomers, we relax this
criteria and accept grouping of isomers into the same feature. We use a `bw = 3`
which reduces the number of features for the later analysis (and by potentially
grouping isomers into the same feature also the specificity of the analysis).

```{r neg-bw-definition-plot-2, echo = FALSE, message = FALSE, warning = FALSE, fig.cap = "Simulated peak grouing result on a m/z slice containing the Fructose and Mannose peaks. The upper panel shows the chromatogram for the MS data slice, the lower the position of the chromatographic peaks in that slice along the retention time axis (y-axis lists samples). The black line shows the density distribution for a bw = 3, the grey rectangles indicate the peaks that are grouped to a feature.", fig.width = 12, fig.height = 8}
mzr <- std_info[std_info$name == "Glucose", "mz_ion"] + c(-0.002, 0.002)
rtr <- c(140, 180)

pdp_tmp <- PeakDensityParam(sampleGroups = data_neg$source, bw = 3)
plot_grouping(data_neg, mz = mzr, rt = rtr, param = pdp_tmp,
              col = col_source[data_neg$source])
```

In addition we evaluate the bandwidth setting on the peaks for 1-Methylhistidine
and 3-Methylhistidine.

```{r neg-bw-definition-plot-3, echo = FALSE, message = FALSE, warning = FALSE, fig.cap = "Simulated peak grouing result for Methylhistidine. The upper panel shows the chromatogram for the MS data slice, the lower the position of the chromatographic peaks for 1-Methylhistidine and 3-Methylhistidine (y-axis lists samples). The black line shows the density distribution for a bw = 3, the grey rectangles indicate the peaks that are grouped to a feature.", fig.width = 12, fig.height = 8}
mzr <- std_info[std_info$HMDB.code == "HMDB0000001", "mz_ion"] + c(0.002, -0.002)
rtr <- c(170, 210)
plot_grouping(data_neg, rt = rtr, mz = mzr, param = pdp_tmp,
              col = col_source[data_neg$source])
```

With a `bw = 3` peaks for 1-Methylhistidine and 3-Methylhistidine are also
grouped into the same feature.

Below we perform the peak grouping on the defined settings and subsequently the
alignment. For the alignment we require a *hook* peak to be present in at least 
95% of QC samples. Other set parameters are `span = 0.3` and `extraPeaks = 50`.

```{r neg-alignment-group, message = FALSE, warning = FALSE}
#' Remove potentially problematic samples. These were manually defined.
bad_idx <- c(378, 274, 352, 239, 383, 387)

data_neg <- filterFile(data_neg, file = seq_along(data_neg$sample)[-bad_idx])

#' Define the peak grouping parameters to define the hook peaks
#' These should be peaks present in most samples
pdp <- PeakDensityParam(sampleGroups = data_neg$source,
                        minFraction = 0.95,
                        minSamples = 5,
                        binSize = 0.01,
                        bw = 3)
data_neg <- groupChromPeaks(data_neg, param = pdp)

#' Next we perform the alignemnt.
pgp <- PeakGroupsParam(minFraction = 0.95, extraPeaks = 50, span = 0.3,
                       subsetAdjust = "average",
                       subset = which(data_neg$sample == "POOL"))
data_neg <- adjustRtime(data_neg, param = pgp)
```

The results from the alignment are shown below. The base peak chromatograms are
slightly more overlapping after alignment. Also, adjustment of retention time is
smaller 5 seconds for most of the signal, which is what we would expect from
such a small experiment consisting of only two measurement runs.

```{r}
load(paste0(RDATA_PATH, "data_neg_aligned.RData"))
```


```{r neg-alignment-rtime-plot, message = FALSE, warning = FALSE, echo = FALSE, fig.width = 12, fig.height = 10, fig.cap = "Alignment result. Shown are the raw base peak chromatogram, the base peak chromatogram after alignment and the difference between the adjusted and raw retention time. Grey dots indicate hook peaks on which the alignment based."}
chr_raw <- chromatogram(data_neg, aggregationFun = "max", adjustedRtime = FALSE)
chr_adj <- chromatogram(data_neg, aggregationFun = "max")
par(mfrow = c(3, 1), mar = c(0, 4.3, 2, 0.1))
plot(chr_raw, col = paste0(col_source[chr_raw$source], 40),
     peakType = "none", main = "BPC, raw")
plot(chr_adj, col = paste0(col_source[chr_raw$source], 40),
     peakType = "none", main = "BPC, adjusted")
plotAdjustedRtime(data_neg, col = paste0(col_source[data_neg$source], 80),
                  peakGroupsPch = 1, peakGroupsCol = "#00000040")
```

At last we generate extracted ion chromatogram plots of the raw and adjusted
data for the list of known compounds. These are visually inspected to evaluate
the impact of the alignment. The plots for some representative compounds are
shown below.

```{r neg-alignment-kc-plots, echo = FALSE, warning = FALSE, message = FALSE, eval = plot_eics}
#' For each standard, reduce to the peak with the highest intensity within
#' the observed rt +/- 7 seconds.
std_info_mz_rt_obs <- matrix(
    ncol = 4, nrow = nrow(std_info),
    dimnames = list(std_info$name, c("mzmin", "mzmax", "rtmin", "rtmax")))
for (i in 1:nrow(std_info)) {
    pks <- chromPeaks(data_neg, mz = std_info$mz_ion[i], ppm = 50,
                      rt = std_info$RT_obs[i] + c(-7, 7),
                      type = "apex_within")
    if (nrow(pks)) {
        mzr <- range(pks[, c("mzmin", "mzmax")])
        rtr <- range(pks[, c("rtmin", "rtmax")], std_info$RT[i])
        std_info_mz_rt_obs[i, ] <- c(mzr, rtr + c(-2, 2))
    } else {
        std_info_mz_rt_obs[i, c("mzmin", "mzmax", "rtmin", "rtmax")] <-
            c(std_info$mz_ion[i] + c(-0.002, 0.002),
              std_info$RT_obs[i] + c(-10, 10))
    }
}

std_info_chr <- chromatogram(
    data_neg, mz = std_info_mz_rt_obs[, c("mzmin", "mzmax")],
    rt = std_info_mz_rt_obs[, c("rtmin", "rtmax")],
    aggregationFun = "max")

#' Plot the extracted ion chromatograms
dr <- paste0(IMAGE_PATH, "alignment/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
sample_colors <- col_source[data_neg$source]
for (i in 1:nrow(std_info)) {
    cmpname <- gsub("L-", "", std_info$name[i])
    cmpname <- tolower(gsub(" .*", "", cmpname))
    filename <- paste0(dr, i, "-", cmpname, "_", "NEG", ".png")
    png(file = filename, width = 16, height = 8, units = "cm",
        res = 300, pointsize = 4)
    chr <- std_info_chr[i, ]
    pks <- chromPeaks(chr)
    plot(chr, col = "#00000040",
         main = paste0(std_info$name[i], ": ",
                       format(mz(chr)[1], digits = 6), "-",
                       format(mz(chr)[2], digits = 6)),
         peakCol = paste0(sample_colors[pks[, "column"]], 50),
         peakBg = paste0(sample_colors[pks[, "column"]], 10))
    abline(v = std_info$RT_obs[i])
    dev.off()
}

```

For most known compounds alignment worked nicely, see e.g. the plot for Serine
or 1- and 3-Methylhistidine below, others could not be aligned perfectly, such
as C4 Carnitine (see last image below).

![](images/vams_preprocessing_neg/alignment/38-serine_NEG.png)

![](images/vams_preprocessing_neg/alignment/72-1-methylhistidine_NEG.png)

![](images/vams_preprocessing_neg/alignment/37-3-methylhistidine_NEG.png)

![](images/vams_preprocessing_neg/alignment/26-threonine_NEG.png)

### Summary

```{r, echo = FALSE}
save(data_neg, file = paste0(RDATA_PATH, "data_neg_aligned.RData"))
```

We used the peak groups method for alignment that uses *hook* peaks expected to
be present in all samples for the alignment.

## Correspondence

We re-use settings for the grouping performed already in the previous
section (i.e. the bandwidth parameter) but reduce the `minFraction` parameter.

```{r neg-correspondence, message = FALSE, warning = FALSE}
#' Define settings for the correspondence and perform the analysis
pdp <- PeakDensityParam(sampleGroups = data_neg$source,
                        minFraction = 1/3,
                        minSamples = 3,
                        binSize = 0.01,
                        bw = 3)
data_neg <- groupChromPeaks(data_neg, param = pdp)
```

```{r neg-correspondence-kc-plots, echo = FALSE, warning = FALSE, message = FALSE, eval = plot_eics}
rtr <- std_info_mz_rt[, c("rtmin", "rtmax")]
rtr[, 1] <- rtr[, 1] - 10
rtr[, 2] <- rtr[, 2] + 10
std_info_chr <- chromatogram(
    data_neg, mz = std_info_mz_rt[, c("mzmin", "mzmax")],
    rt = rtr, aggregationFun = "max")

dr <- paste0(IMAGE_PATH, "correspondence/")
dir.create(dr, showWarnings = FALSE)
#' Visualizing alignment results for known compounds.
for (i in seq_len(nrow(std_info))) {
    cmpname <- gsub("L-", "", std_info$name[i])
    cmpname <- tolower(gsub(" .*", "", cmpname))
    filename <- paste0(dr, i, "-", cmpname, "_", "NEG", ".png")
    chr <- std_info_chr[i, ]
    #' Use a different color for each feature.
    n_fts <- nrow(featureDefinitions(chr))
    clrs <- brewer.pal(9, "Set1")[seq_len(n_fts)]
    fts <- featureDefinitions(chr)
    if (nrow(fts)) {
        pk_col <- rep("#000000", nrow(chromPeaks(chr)))
        for (j in seq_len(n_fts)) {
            pk_col[fts$peakidx[[j]]] <- clrs[j]
        }
        png(filename, width = 12, height = 10, units = "cm",
            res = 200, pointsize = 4)
        plotChromPeakDensity(chr, simulate = FALSE,
                             main = paste0(std_info$name[i], ": ",
                                           format(mz(chr)[1], digits = 6), "-",
                                           format(mz(chr)[2], digits = 6)),
                             peakCol = paste0(pk_col, 40),
                             peakBg = paste0(pk_col, "10"),
                             col = "#00000040")
        abline(v = std_info$RT[i], col = "#00000080", lty = 3)
        abline(v = std_info$RT_obs[i], col = "#00000080", lty = 1)
    } else {
        png(filename, width = 12, height = 10, units = "cm",
            res = 200, pointsize = 4)
        plotChromPeakDensity(chr,
                             main = paste0(std_info$name[i], ": ",
                                           format(mz(chr)[1], digits = 6), "-",
                                           format(mz(chr)[2], digits = 6)),
                             param = pdp, col = "#00000040")
        abline(v = std_info$RT[i], col = "#00000080", lty = 3)
        abline(v = std_info$RT_obs[i], col = "#00000080", lty = 1)
    }
    dev.off()
}

#' In addition find for each standard the *best* feature (i.e. closest mz
#' and rt.
std_info$feature_id <- NA_character_
for (i in seq_len(nrow(std_info))) {
    fts <- featureDefinitions(data_neg, mz = std_info$mz_ion[i], ppm = 50)
    rt_diff <- abs(fts$rtmed - std_info$RT_obs[i])
    fts <- fts[rt_diff < 7, ]
    mz_diff <- abs(fts$mzmed - std_info$mz_ion[i])
    std_info$feature_id[i] <- rownames(fts[order(mz_diff), ])[1]
}

```

The table below summarizes the results from the correspondence analysis.

```{r neg-correspondence-summary-table, echo = FALSE, message = FALSE, warning = FALSE, results = "asis"}
feat_summ <- featureSummary(data_neg, group = data_neg$source)

#' Summarized the feature summary table by breaking it down to certain
#' categories that represent the total number of features, total number of
#' features with as well as fetures present in certain percentages of samples with the percentages defined with `percentages`.
#'
#' @param x `matrix` such as returned by the [featureSummary] function.
#'
#' @param percentages `numeric` defining the percentages for which counts
#'     should be reported.
#'
#' @return `matrix` with total counts of features and counts of features for
#'     which peaks have been found in certain percentages of samples. Rows
#'     `"multi"` refer to features for which multiple chromatographic peaks
#'     are present in a sample.
#'
#' @author Johannes Rainer
featureSummaryTable <- function(x, percentages = c(10, 25, 50, 90)) {
    #' Check input table.
    if (!is.matrix(x) ||
        !all(c("count", "multi_count", "multi_perc", "perc") %in% colnames(x)))
        stop("'x' is supposed to be a matrix as returned by the ",
             "'featureSummary' function")
    trues <- list(total = feat_summ[, "count"] > 0,
                  `single peaks` = feat_summ[, "multi_count"] == 0,
                  `multi peaks` = feat_summ[, "multi_perc"] > 0
                  )
    if (length(percentages)) {
        for (perc in percentages) {
            trues <- c(trues, list(feat_summ[, "multi_perc"] > perc))
        }
        names(trues) <- c("total", "single peaks", "multi peaks",
                          paste0("multi in > ", percentages, "% of samples"))
    }
    do.call(rbind, lapply(trues, function(is_true) {
        cnt <- c(count = sum(is_true))
        for (perc in percentages) {
            nms <- names(cnt)
            cnt <- c(cnt, sum(x[is_true, "perc"] > perc))
            names(cnt) <- c(nms, paste0("in > ", perc, "%"))
        }
        cnt
    }))
}

pandoc.table(featureSummaryTable(feat_summ), style = "rmarkdown", 
             caption = paste("Summary of the correspondence analysis. Shown",
                             "are counts of features, counts of features with",
                             "at least one samples in which multiple peaks",
                             "are present (column multi peaks) and counts",
                             "of features with different amount of samples",
                             "having multiple peaks."))

```

About 70 % of the features are *single peak features*, i.e. have only a 
single chromatographic peak assigned per sample. The number of features present 
in more than 90 % of samples is low (about 15 %), but not unexpected, since we 
do have a relatively heterogeneous group of individuals, and are also comparing different sample sources. Note also that for the *multi peaks* most have an additional peak in fewer than 10 % of samples.

Next we evaluate the integrated signal for features in QC samples. This is
expected to be similar between QC samples. Differences can, besides batch
effects or injection order dependent effects, also be caused by differences in
the identified chromatographic peak boundaries. We thus extract below feature
intensities and subset these to QC samples.

```{r feature-vals-QC, message = FALSE}
#' We extract the integrated original signal and use the signal from the peak
#' with the larger signal for multi-peak features.
fmat <- featureValues(data_neg, value = "into", method = "maxint")

#' Subset to QC samples and remove features not present in 90% of the samples
fmat_qc <- fmat[, data_neg$source == "all"]
nsamp <- ncol(fmat_qc)
fmat_qc <- fmat_qc[apply(fmat_qc, MARGIN = 1,
                         function(z) (sum(!is.na(z)) / nsamp) >= 0.9), ]
```

Next we determine per-row differences that will be used to asses overall
similarity between replicates. In log2 scale, we calculate the maximal
difference (`M_range`) and, to avoid results being influenced by outliers,
differences between abundances after removing the lower and upper 1% of signals
(`diff_98`. These `M` values represent thus log fold change differences in
abundances.

```{r feature-vals-diff, message = FALSE}
#' Calculat maximal differences...
diff_fun <- function(z) {
    c(M_range = diff(range(z, na.rm = TRUE)),
      M_98 = unname(diff(quantile(z, probs = c(0.01, 0.99), na.rm = TRUE))),
      M_90 = unname(diff(quantile(z, probs = c(0.05, 0.95), na.rm = TRUE))))
}
QC_diffs <- t(apply(log2(fmat_qc), MARGIN = 1, FUN = diff_fun))

```

The table below lists the quantiles of these differences.

```{r feature-vals-diff-table, message = FALSE, echo = FALSE, results = "asis"}
tab <- apply(QC_diffs, MARGIN = 2, quantile)
pandoc.table(tab, style = "rmarkdown",
             caption = paste("Overview of the abundance differences between",
                             "QC samples. Shown are quantiles for the M_range",
                             "(log2 difference between the most extreme values",
                             "for a feature), M_98 (log2 difference after",
                             "removing the top 1% and lowest 1% of values for",
                             "a feature) and M_90 (log2 difference after",
                             "removing the top and lowest 5% of values per",
                             "feature). The analysis bases on", nrow(QC_diffs),
                             "features."))
```

The plot below shows the distribution of log2 ratios in abundances and their
dependency on average abundance.

```{r feature-vals-diff-plot, echo = FALSE, fig.cap = "Distribution of log2 ratios in abundances between QC samples and their dependency on their average abundance.", fig.widht = 10, fig.height = 5}
par(mfrow = c(1, 2), mar = c(4, 4.5, 1, 1))
boxplot(QC_diffs, ylab = expression(log[2]~abundance~ratio))
grid(nx = NA, ny = NULL)
plot(rowMeans(log2(fmat_qc), na.rm = TRUE), QC_diffs[, 1],
     xlab = expression(log[2]~average~abundance),
     ylab = expression(log[2]~abundance~ratio), pch = 16, col = "#00000060")
grid()
```

Next we inspect the data for features from 3 different classes, i.e. features
with single peaks, features having occasionally additional peaks and peaks with
additional peaks in more than 50% of samples. Also, we aim to identify features
that have single peaks in samples from one source, but multiple in others.

### Single peak features

These are supposedly higher quality features. We below identify these peaks and
subsequently create extracted ion chromatograms for 30 randomly chosen ones, 10
with low (signal below 10000), 10 with intermediate (10000 to 20000) and 10 with
high signal intensities (above 2000). For the selection we focus in addition on
features that are present in at least one third of samples.

```{r neg-single-peak-features, message = FALSE}
#' Selecting features with a single peak being present
#' in more than 33% of samples.
feats <- rownames(feat_summ)[feat_summ[, "multi_count"] == 0 &
                             feat_summ[, "perc"] > 100/3]
rms <- rowMeans(fmat[feats, ], na.rm = TRUE)
feats_low <- sample(feats[rms < 10000], 10)
feats_int <- sample(feats[rms > 10000 & rms < 20000], 10)
feats_high <- sample(feats[rms > 20000], 10)

```

```{r neg-single-peak-features-plot, echo = FALSE, message = FALSE, warning = FALSE}

dr <- paste0(IMAGE_PATH, "single_peak_fts/")
dir.create(dr, showWarnings = FALSE)

#' Extract ion chromatograms for all features.
chrs_tmp <- featureChromatograms(data_neg, features = feats_low, expandRt = 2,
                                 include = "feature_only")
for (i in seq_along(feats_low)) {
    feat <- feats_low[i]
    fn <- paste0(dr, "low-", feat, ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    chr <- chrs_tmp[i, ]
    pk_col <- rep("#ff0000", nrow(chromPeaks(chr)))
    pk_col[featureDefinitions(chr)$peakidx[[1]]] <- brewer.pal(3, "Set1")[2]
    plotChromPeakDensity(chr, peakBg = paste0(pk_col, 10), peakPch = 16,
                         peakCol = paste0(pk_col, 40), simulate = FALSE)
    dev.off()
}

chrs_tmp <- featureChromatograms(data_neg, features = feats_int, expandRt = 2,
                                 include = "feature_only")
for (i in seq_along(feats_int)) {
    feat <- feats_int[i]
    fn <- paste0(dr, "int-", feat, ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    chr <- chrs_tmp[i, ]
    pk_col <- rep("#ff0000", nrow(chromPeaks(chr)))
    pk_col[featureDefinitions(chr)$peakidx[[1]]] <- brewer.pal(3, "Set1")[2]
    plotChromPeakDensity(chr, peakBg = paste0(pk_col, 10), peakPch = 16,
                         peakCol = paste0(pk_col, 40), simulate = FALSE)
    dev.off()
}

chrs_tmp <- featureChromatograms(data_neg, features = feats_high, expandRt = 2,
                                 include = "feature_only")
for (i in seq_along(feats_high)) {
    feat <- feats_high[i]
    fn <- paste0(dr, "high-", feat, ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    chr <- chrs_tmp[i, ]
    pk_col <- rep("#ff0000", nrow(chromPeaks(chr)))
    pk_col[featureDefinitions(chr)$peakidx[[1]]] <- brewer.pal(3, "Set1")[2]
    plotChromPeakDensity(chr, peakBg = paste0(pk_col, 10), peakPch = 16,
                         peakCol = paste0(pk_col, 40), simulate = FALSE)
    dev.off()
}

```

The chromatograms for all these peaks look OK, especially for the high
intensity group (data not shown).

### Features having occasionally additional peaks

These are features that have an additional peak in less than 10% of
samples. Again we require the features to have a peak in more then 30% of
samples and select 10 random features for low, intermediate and high
intensities.

```{r neg-occasional-multi-features, message = FALSE}
#' Selecting features with occacional multiple peaks
#' being present. A peak has to be present also in more than 33% of samples.
feats <- rownames(feat_summ)[feat_summ[, "multi_count"] > 0 &
                             feat_summ[, "multi_perc"] < 10 &
                             feat_summ[, "perc"] > 100/3]
rms <- rowMeans(fmat[feats, ], na.rm = TRUE)
feats_low <- sample(feats[rms < 10000], 10)
feats_int <- sample(feats[rms > 10000 & rms < 20000], 10)
feats_high <- sample(feats[rms > 20000], 10)

```

```{r neg-occasional-multi-features-plot, echo = FALSE, message = FALSE, warning = FALSE}
dr <- paste0(IMAGE_PATH, "occasional_multi_peak_fts/")
dir.create(dr, showWarnings = FALSE)

chrs_tmp <- featureChromatograms(data_neg, features = feats_low, expandRt = 2,
                                 include = "feature_only")
for (i in seq_along(feats_low)) {
    feat <- feats_low[i]
    fn <- paste0(dr, "low-", feat, ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    chr <- chrs_tmp[i, ]
    pk_col <- rep("#ff0000", nrow(chromPeaks(chr)))
    pk_col[featureDefinitions(chr)$peakidx[[1]]] <- brewer.pal(3, "Set1")[2]
    plotChromPeakDensity(chr, peakBg = paste0(pk_col, 10), peakPch = 16,
                         peakCol = paste0(pk_col, 40), simulate = FALSE)
    dev.off()
}
chrs_tmp <- featureChromatograms(data_neg, features = feats_int, expandRt = 2,
                                 include = "feature_only")
for (i in seq_along(feats_int)) {
    feat <- feats_int[i]
    fn <- paste0(dr, "int-", feat, ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    chr <- chrs_tmp[i, ]
    pk_col <- rep("#ff0000", nrow(chromPeaks(chr)))
    pk_col[featureDefinitions(chr)$peakidx[[1]]] <- brewer.pal(3, "Set1")[2]
    plotChromPeakDensity(chr, peakBg = paste0(pk_col, 10), peakPch = 16,
                         peakCol = paste0(pk_col, 40), simulate = FALSE)
    dev.off()
}
chrs_tmp <- featureChromatograms(data_neg, features = feats_high, expandRt = 2,
                                 include = "feature_only")
for (i in seq_along(feats_high)) {
    feat <- feats_high[i]
    fn <- paste0(dr, "high-", feat, ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    chr <- chrs_tmp[i, ]
    pk_col <- rep("#ff0000", nrow(chromPeaks(chr)))
    pk_col[featureDefinitions(chr)$peakidx[[1]]] <- brewer.pal(3, "Set1")[2]
    plotChromPeakDensity(chr, peakBg = paste0(pk_col, 10), peakPch = 16,
                         peakCol = paste0(pk_col, 40), simulate = FALSE)
    dev.off()
}

```

Most of the features show peaks with good peak shape.

### Features with many peaks per sample

Here we want to characterize features that have more than one chromatographic
peak assigned in more than 50% of samples.

```{r neg-multi50-features, message = FALSE}
#' Selecting features with multiple peaks
#' being present. A peak has to be present also in more than 33% of samples.
feats <- rownames(feat_summ)[feat_summ[, "multi_perc"] > 50 &
                             feat_summ[, "perc"] > 100/3]

```

```{r neg-multi50-features-plot, echo = FALSE, message = FALSE, warning = FALSE}
dr <- paste0(IMAGE_PATH, "multi_50_peak_fts/")
dir.create(dr, showWarnings = FALSE)

chrs_tmp <- featureChromatograms(data_neg, features = feats, expandRt = 2,
                                 include = "feature_only")
for (i in seq_along(feats)) {
    feat <- feats[i]
    fn <- paste0(dr, "", feat, ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    chr <- chrs_tmp[i, ]
    pk_col <- rep("#ff0000", nrow(chromPeaks(chr)))
    pk_col[featureDefinitions(chr)$peakidx[[1]]] <- brewer.pal(3, "Set1")[2]
    if (nrow(featureDefinitions(chr))) {
        plotChromPeakDensity(chr, peakBg = paste0(pk_col, 10), peakPch = 16,
                             peakCol = paste0(pk_col, 40), simulate = FALSE)
    } else {
        plotChromPeakDensity(chr, peakBg = paste0(pk_col, 10), peakPch = 16,
                             peakCol = paste0(pk_col, 40), simulate = TRUE,
                             param = pdp)
    }
    dev.off()
}

```

Some of these features combine peaks from isomers for which correspondence
failed to separate them into different features while most combine peaks
identified in signal from (presumably) background ions.

### Features close on m/z and with partially overlapping chromatographic peaks

At last we evaluate features that are overlapping on m/z and retention time with
or without extending their region. If only the feature boundaries are
considered, overlapping features will necessarily share one or more peaks with
each other. Below we identify overlapping features, but also features that are
close on retention time, m/z or both dimensions.

```{r overlapping-features, message = FALSE, warning = FALSE}
ovlap_fts <- overlappingFeatures(data_neg)
ovlap_fts_rt <- overlappingFeatures(data_neg, expandRt = 2) # isomers?
ovlap_fts_mz <- overlappingFeatures(data_neg, ppm = 40)
ovlap_fts_rt_mz <- overlappingFeatures(data_neg, ppm = 40, expandRt = 2)

```

```{r overlapping-features-table, message = FALSE, echo = FALSE, results = "asis"}
tab <- rbind(overlapping = length(ovlap_fts),
             overlapping_within_4seconds = length(ovlap_fts_rt),
             overlapping_50ppm = length(ovlap_fts_mz),
             overlapping_4seconds_100ppm = length(ovlap_fts_rt_mz))
pandoc.table(tab, style = "rmarkdown",
             caption = paste("Summary of overlapping or close features.",
                             "Listed are the total number of overlapping",
                             "features, features that are within 4 seconds to",
                             "each other, features that are overlapping if the",
                             "m/z width is extended by 100 ppm and features",
                             "overlapping if both their retention time range",
                             "and m/z width is extended."))
```

While no features are directly overlapping, quite some are very close in
retention time and/or m/z dimension. Most of these features represent signal
from long signal.

```{r feature-groups-close-ppm, echo = FALSE, results = "hide", message = FALSE, warning = FALSE}
#' Randomly choosing among features that are less than 50 ppm apart.
set.seed(123)

fts_grps <- ovlap_fts_mz[sample(seq_along(ovlap_fts_mz), 20)]

dr <- paste0(IMAGE_PATH, "overlapping_close_mz/")
dir.create(dr, showWarnings = FALSE)
#' Use the pool data...
data_qc <- filterFile(dropChromPeaks(data_neg),
                      file = which(data_neg$source == "all"))

for (i in seq_along(fts_grps)) {
    fn <- paste0(dr, "feature-group-", i, ".png")
    png(fn, width = 20, height = 16, units = "cm", res = 200, pointsize = 6)
    fts_def <- featureDefinitions(data_neg)[fts_grps[[i]], ]
    pks <- chromPeaks(data_neg)[unlist(fts_def$peakidx), ]
    tmp <- filterMz(filterRt(data_qc, range(pks[, c("rtmin", "rtmax")])),
                    mz = range(pks[, c("mzmin", "mzmax")]))
    plot(tmp, type = "XIC", cex = 1)
    dev.off()
}

```


```{r save-data, echo = FALSE, results = "hide"}
save(data_neg, file = paste0(RDATA_PATH, "data_neg.RData"))

```

### Summary

# References
