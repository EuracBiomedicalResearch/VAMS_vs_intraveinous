---
title: "Differential abundance analysis, untargeted approach"
subtitle: "negative polarity"
author: "Christa Malfertheiner"
date: "5 October 2021"
output:
  BiocStyle::html_document:
    toc: true
    number_sections: false
    toc_float: true
bibliography: references.bib
csl: biomed-central.csl
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

```{r setup, echo = FALSE, results = "asis", warning = FALSE}
library(BiocStyle)
BiocStyle::markdown()
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

```{r parameters, echo = FALSE, warning = FALSE}
## Set general parameters
polarity <- "NEG" # specify "neg" or "NEG"
p.cut <- 0.05     # cut-off for significance.
m.cut <- 0.7      # cut-off for log2 fold change
set.seed(123)
## Setting golden ratio to save images
phi <- (1+sqrt(5))/2
FILE_NAME <- "untargeted_matrix_neg"
## Define paths:
IMAGE_PATH <- paste0("images/", FILE_NAME, "/")
if (dir.exists(IMAGE_PATH)) unlink(IMAGE_PATH, recursive = TRUE, force = TRUE)
dir.create(IMAGE_PATH, recursive = TRUE, showWarnings = FALSE)
RDATA_PATH <- paste0("data/RData/", FILE_NAME, "/")
dir.create(RDATA_PATH, recursive = TRUE, showWarnings = FALSE)
RESULT_PATH <- paste0("data/results/", FILE_NAME, "/")
dir.create(RESULT_PATH, recursive = TRUE, showWarnings = FALSE)
FIG_PATH <- paste0(IMAGE_PATH, "FIG/")
dir.create(FIG_PATH, showWarnings = FALSE)
```

# Introduction

In this document we perform the differential abundance analysis of the features
for the *MitYOU* project, with the aim of finding significant sample source-
related features. This task is performed by hypothesis testing, where we try to
identify which metabolites have the most different concentrations between 
plasma samples, venous and capillary blood samples. We follow an untargeted 
approach, the analysis comprises feature pre-filtering, exploratory analysis 
and differential abundance analysis.

# Data import

First, we load the required packages and the data, after preprocessing and 
normalization. The end result of these steps is a `SummarizedExperiment` that 
contains aligned data, where features are grouped (after correspondence), and 
that have undergone gap filling, normalization by the median, linear fitting 
and per-feature between-batch normalization to remove any unwanted variability.
The `SummarizedExperiment` lets us store all the information regarding the 
normalization steps in the form of `assays`, which we are still able to access 
to proceed with the analysis.

```{r load-data, echo = FALSE, warning = FALSE}
library(xcms)
library(limma)
library(pheatmap)
library(writexl)
library(SummarizedExperiment)
library(RColorBrewer)
library(MsFeatures)
library(CompMetaboTools)
library(pander)
setMSnbaseFastLoad(FALSE)
load("data/RData/vams_normalization_neg/res_neg.RData")
res_neg$sample_pair <- paste0(res_neg$source, ".", res_neg$sample)
```

It is important now to remove the `POOL` samples from the dataset, because the 

analysis has to be performed only on study samples; the `POOL` samples, though 
are still required to evaluate the goodness of the detected features, therefore
they will be stored in a separate `SummarizedExperiment` object that can be 
accessed when needed. We also exclude the `RBC` samples from our analysis, as 
these samples showed a noisy signal beforehand. We also store them separately 
in a SummarizedExperiment object.

We assign the colours as seen before.

```{r split-qc, echo = TRUE}
res_qc <- res_neg[, res_neg$source == "all"]
res_neg <- res_neg[, res_neg$source != "all"]
res_rbc <- res_neg[, res_neg$source == "RBC"]
res_neg <- res_neg[, res_neg$source != "RBC"]

res_neg$source <- factor(as.character(res_neg$source))
res_neg$sex <- factor(as.character(res_neg$sex))

col_source <- brewer.pal(6, name = "Set1")[c(6, 2, 1)]
names(col_source) <- c("plasma",        #' yellow
                       "venous",        #' blue
                       "capillary")     #' red
                       
col_sex <- brewer.pal(4, name = "Set1") [c(1, 2, 3)]
names(col_sex) <- c("F",           # red
                    "M",           # blue
                    "POOL")        # green

## Setting golden ratio to save images
phi <- (1+sqrt(5))/2
```

```{r, echo = FALSE}
## Calculate variability across samples/replicates.
samps <- unique(res_neg$sample_pair)
M <- lapply(samps, function(z) {
    idx <- which(res_neg$sample_pair == z)
    if (length(idx) > 1) {
        abs(log2(assay(res_neg, "normalized_filled_imputed")[, idx[1L]]) -
            log2(assay(res_neg, "normalized_filled_imputed")[, idx[2L]]))
    } else NULL
})
names(M) <- samps
M <- do.call(cbind, M)
```

At last we also average the *technical* replicates for each individual to 
generate the final data set.

```{r average-replicates}
#' Average 
averageSE <- function(x, column = character(), mainAssay = character()) {
    if (!column %in% colnames(colData(x)))
        stop("Column '", "' not found in 'colData' of 'x'")
    f <- factor(colData(x)[, column], levels = unique(colData(x)[, column]))
    ## new colData: take the first element for each replicate.
    cd <- colData(x)[match(levels(f), f), ]
    rownames(cd) <- cd[, column]
    ## loop over the assays and average them.
    a <- lapply(assays(x), function(z) {
        z <- split.data.frame(t(z), f = f)
        z <- do.call(cbind, lapply(z, colMeans, na.rm = TRUE))
        z[is.na(z)] <- NA
        z
    })
    if (length(mainAssay)) {
        tmp <- split.data.frame(t(assay(x, mainAssay)), f = f)
        tmp <- do.call(cbind, lapply(tmp, function(y) {
            apply(y, MARGIN = 2, FUN = sd, na.rm = TRUE)
        }))
        tmp[is.na(tmp)] <- NA
        a[[paste0(mainAssay, "_sd")]] <- tmp
    }
    SummarizedExperiment(assays = a, rowData = rowData(x),
                         colData = cd, metadata = metadata(x))
}
## Average technical replicates:
res_neg <- averageSE(res_neg, column = "source_sample",
                     mainAssay = "normalized_filled")
```

The samples used in this analysis are listed below.

```{r, echo = FALSE, results = "asis"}
tab <- colData(res_neg)[, c("source", "sex", "age")]
pandoc.table(as.data.frame(tab), style = "rmarkdown", split.tables = Inf,
             caption = "Samples used in this analysis")
```

# Feature pre-filtering

Feature pre-filtering is an important step of data analysis that aims to reduce
as much as negsible the random error that occurs during the measurement of an 
analyte: during this process, features with high noise and features that were 
detected in a low number of samples are removed. As a side effect, by reducing 
the number of features that are being tested later, the pre-filtering reduces 
also the loss of power by the subsequent adjustment for multiple hypothesis 
testing.

This step is fundamental, though one must be careful not to pre-filter for a 
characteristic that will be tested later: the pre-filtering must be, as a 
matter of fact, independent from later analyses.

The first step of pre-filtering consists of removing features with high 
technical variance; several methods have been developed to determine which 
signals must be removed, the most common of which relies on the **relative 
standard deviation (RSD)**, which is defined as the ratio between the standard 
deviation and the mean:

$RSD = \dfrac{s_{i,qc}}{\bar{m}_{i,qc}}$

This value is calculated for each feature found in the pooled QC samples: when 
this is higher than 30%, the feature is removed from the dataset 
[@broadhurstGuidelinesConsiderationsUse2018].

Another common approach is based on the **dispersion ratio (D-ratio)**: this is
defined as the ratio between the sample standard deviation for the pooled QC 
samples and the sample standard deviation for the study samples (the former 
expected to represent technical variance, the latter a combination of technical
and biological variance):

$D-ratio = \dfrac{s_{i,qc}}{s_{i,sample}}$

The interpretation of this value goes as follows: when the D-ratio is 0%, there
is no technical variance in the observed measurements, whereas a D-ratio of 
100% represents only noise and no biological variance detected. A common cut-
off for the D-ratio is 0.5, aiming at keeping features whose variation in study
samples is twice as large as the one in QC samples 
[@broadhurstGuidelinesConsiderationsUse2018].

For the present dataset calculate the D-ratio **separately** for each source 
(sample matrix) because the variance between sample matrices is expected to be 
very large. For each feature the mean D-ratio across the 3 sample matrices is 
used for the filtering.

```{r filter-rsd, warning = FALSE}
rsds <- rowRsd(assay(res_qc, "normalized_filled"))

dratios_ven <- apply(
    log2(assay(res_qc, "normalized_filled")), 1, sd, na.rm = TRUE) /
    apply(log2(assay(res_neg[, res_neg$source == "venous"],
                     "normalized_filled")), 1, sd, na.rm = TRUE)

dratios_cap <- apply(
    log2(assay(res_qc, "normalized_filled")), 1, sd, na.rm = TRUE) /
    apply(log2(assay(res_neg[, res_neg$source == "capillary"],
                     "normalized_filled")), 1, sd, na.rm = TRUE)

dratios_pla <- apply(
    log2(assay(res_qc, "normalized_filled")), 1, sd, na.rm = TRUE) /
    apply(log2(assay(res_neg[, res_neg$source == "plasma"],
                     "normalized_filled")), 1, sd, na.rm = TRUE)

dratios <- apply(cbind(dratios_ven, dratios_cap, dratios_pla),
                 MARGIN = 1, mean, na.rm = TRUE)

dratios[is.infinite(dratios)] <- NA
```

The distribution of RSD values and D-ratio is shown in the plot below:

```{r filter-rsd-plot, fig.path = IMAGE_PATH, fig.width = 5 * phi, fig.height = 5, fig.cap = "Distribution of RSD values and D-ratios in the data set. The dashed vertical red line represents the cut-off value for the RSD and D-ratio, respectively.", echo = FALSE}
par(mfrow = c(1, 2))
plot(density(rsds, na.rm = TRUE), xlab = "RSD",
     main = "Distribution of RSD values")
abline(v = 0.3, col = "red", lty = 2)
plot(density(dratios, na.rm = TRUE), xlab = "D-ratio",
     main = "Distribution of D-ratios")
abline(v = 0.5, col = "red", lty = 2)
```

The plot below directly compares the RSD and D-ratio for each feature.

```{r filter-rsd-vs-dratio-plot, fig.path = IMAGE_PATH, fig.width = 5, fig.height = 5, fig.cap = "Direct comparison of RSD and D-ratios.", echo = FALSE}
plot(log2(rsds), log2(dratios), xlab = expression(log[2]~RSD),
     ylab = expression(log[2]~D-ratio), pch = 16, col = "#00000040")
abline(v = log2(0.3), col = "red", lty = 2)
abline(h = log2(0.5), col = "red", lty = 2)
```

The plot shows a correlation between RSD and D-ratios, though the two methods are not interchangeable. Below we pre-filter the data using the D-ratio.

```{r do-filter}
res <- res_neg[which(dratios < 0.5), ]
```

This reduced the data set from `r length(dratios)` to `r nrow(res)` features. Next, we discard the features that have not been identified in at least one third of the samples in any of the sample groups.

```{r filter-proportion}
keep <- moreAreValidThan(assay(res, "raw"), f = res$source, prop = 1/3)
res <- res[keep, ]
```

The dataset has been reduced from `r length(rsds)` to `r nrow(res)` features: 
this result shows that most features have been retained even after pre-
filtering, thus ensuring a dataset where features have a D-ratio lower than 0.5
and have less than 70% missing values.

```{r, echo = FALSE}
## Variability across data sets.
matrices <- vapply(strsplit(colnames(M), split = ".", fixed = TRUE),
                   function(z) z[1], character(1))
png(paste0(FIG_PATH, "FIG_8_NEG_untargeted_diff_rep_A.png"),
    width = 10, height = 5, res = 600, pointsize = 4, units = "cm")
library(vioplot)
par(mfrow = c(1, 2))
m <- split(colMeans(M), matrices)
vioplot(m, main = "All features", las = 2,
        ylab = expression(log[2]~average~difference))
grid(nx = NA, ny = NULL)
##
m <- split(colMeans(M[rownames(res), ]), matrices)
vioplot(m, main = "Features passed pre-filtering", las = 2,
        ylab = expression(log[2]~average~difference))
grid(nx = NA, ny = NULL)
dev.off()

## The same plot, but average per feature.
png(paste0(FIG_PATH, "FIG_8_NEG_untargeted_diff_rep_B.png"),
    width = 10, height = 5, res = 600, pointsize = 4, units = "cm")
par(mfrow = c(1, 2))
m <- t(M)
m <- split.data.frame(m, matrices)
m <- lapply(m, colMeans)
vioplot(m, main = "All features", las = 2, ylab = expression(log[2]~difference))
grid(nx = NA, ny = NULL)
m <- t(M[rownames(res), ])
m <- split.data.frame(m, matrices)
m <- lapply(m, colMeans)
vioplot(m, main = "Features passed pre-filtering", las = 2,
        ylab = expression(log[2]~difference))
grid(nx = NA, ny = NULL)
dev.off()

```


# Exploratory analysis: PCA

Next, we perform a PCA analysis: this allows us to gather information about any
possible similarities among the samples, based on the measured metabolite 
intensities.

```{r pca-all}
pc <- prcomp(t(log2(assay(res, "normalized_filled_imputed"))),
             center = TRUE, scale. = FALSE)
```

```{r pca-plot, fig.path = IMAGE_PATH, fig.cap = "PCA of the samples based on feature intensities.", fig.width = 7 * phi, fig.height = 7, echo = FALSE}
par(mfrow = c(1, 2))
col <- "#00000080"
plot_pca(pc, bg = paste0(col_source[as.character(res$source)], 90),
         pc_x = 1, pc_y = 2, pch = 21, col = col)
legend("topright", col = col_source, legend = names(col_source),
       pch = 16, ncol = 2)
plot_pca(pc, bg = paste0(col_source[as.character(res$source)], 90),
         pc_x = 3, pc_y = 4, pch = 21, col = col)

```

We see a clear separation by sample matrix for all three sample sources in PC1 and PC2.

```{r, echo = FALSE}
png(paste0(FIG_PATH, "FIG_2_NEG_PCA_untargeted.png"), width = 5, height = 5,
    res = 600, pointsize = 4, units = "cm")
par(mfrow = c(1, 1), mar = c(4.2, 4.5, 1.5, 1), cex.lab = 1.5)
plot_pca(pc, bg = paste0(col_source[as.character(res$source)], 90),
         pc_x = 1, pc_y = 2, pch = 21, col = col, cex = 1.5)
legend("bottomright", pt.bg = col_source, col = "#00000080",
       legend = names(col_source), pch = 21, cex = 1.5)
## plot_pca(pc, bg = paste0(col_source[as.character(res$source)], 90),
##          pc_x = 3, pc_y = 4, pch = 21, col = col, cex = 1.5)
dev.off()

```

# Present and absent features

We then wanted to check if there are compounds that are only present in some of
the three matrices. For a metabolite to be *present* we require that a signal
was detected by the MS instrument for that metabolite in a large fraction of
samples of a certain sample matrix. We thus call a metabolite to be present, if
a chromatographic peak was detected in 1/3 of the samples per matrix. Therefore,
we use below the `raw` data of our three sample sources (which only contains
intensity values for **detected** chromatographic peaks) and looked, which
compounds are present in more than 1/3 of the samples.

```{r Present and absent features, echo = FALSE}
plas <- assay(res, "raw")[, res$source == "plasma"]
plas_present <- moreAreValidThan(plas, prop = 1/3)

ven <- assay(res, "raw")[, res$source == "venous"]
ven_present <- moreAreValidThan(ven, prop = 1/3)

cap <- assay(res, "raw")[, res$source == "capillary"]
cap_present <- moreAreValidThan(cap, prop = 1/3)

```

We then create a plot an `UpSetR` plot to see the overlap of present features:

```{r present-feature-comparison-upset, fig.path = IMAGE_PATH, fig.cap = "Overlap of present features across the 3 sample matrices.", echo = FALSE, eval = TRUE}

#create an UpSetR plot
library(UpSetR)
listInput <- list(capillary = which(cap_present, useNames = TRUE),
                  venous = which(ven_present, useNames = TRUE),
                  plasma = which(plas_present, useNames = TRUE))
upset(fromList(listInput), order.by = "freq", sets.bar.color = col_source[c("venous", "capillary", "plasma")])
```

```{r, echo = FALSE}
png(paste0(FIG_PATH, "FIG_2_NEG_upset_untargeted.png"), width = 7, height = 7,
    res = 600, pointsize = 4, units = "cm")
par(mfrow = c(1, 1), mar = c(4.2, 4.5, 1.5, 1), cex.lab = 1.5)
upset(fromList(listInput), keep.order = FALSE,
      sets.bar.color = col_source[c("capillary", "venous", "plasma")],
      order.by = "freq")
dev.off()

```


The majority of the 1003 present features, 423 features, are present in all 
three sample sources, whereas 270 features are only present in capillary and 
venous blood samples and 102 features are only present in venous blood and 
plasma samples. 89 features are only present in capillary blood samples, 79 
features are only found in venous blood and 24 features are present in plasma 
samples exclusively. Lastly, 16 features are present in plasma and capillary 
blood samples, but absent in venous blood.

# Differential abundance analysis

In this section, we perform a differential abundance analysis to identify 
features that have significantly different abundances between male and female 
samples. The analysis is based on feature-wise multiple linear regression: the 
aim of such analysis is to find the relationship between the independent 
variables (age and sex) and the response variable (signal intensity). In short,
multiple linear regression is a form of linear regression that is used when 
there are two or more predictors. Multiple linear regression is preferred over 
separate simple linear regression in order to avoid wrong predictions: this 
could happen because the input variables may be correlated, which could lead 
to unsatisfactory results. The formula for multiple regression model is:

$Y = \beta_0 + \beta_1x_{i1} + \beta_2x_{i2} \ldots, + \beta_px_{ip} + \epsilon$

where: \
- $Y =$ predicted value (dependent variable) \
- $\beta_0 =$ y intercept, constant term
- $\beta_1, \beta_2, \ldots, \beta_p =$ regression coefficients \
- $x_i =$ independent variables \
- $\epsilon =$ residuals.

The `limma` package contains the `lmFit` function, which calculates the linear
model that best describes the data. The results are stored in a `MArrayLM`
(Microarray Linear Model Fit) object.

This model, though, is not enough to accept whether or not there is actually a
relationship among the response and the independent variables, therefore we must
perform a hypothesis test: we define the *null hypothesis* as there not being
any differences in the abundances of metabolites in male and female samples. The
*alternative hypothesis* is therefore defined when there are differences in the
intensities of the signals coming from the metabolites in the two different
experimental groups.
To accept or reject the alternative hypothesis, it is necessary to calculate the
p-value: the function that allows us to add the results to the `MArrayLM` object
created before is `eBayes`. The `eBayes` function computes several statistics,
including the moderated t-test, which is defined as follows:

$\dfrac{d}{s + s_0}$

where \
- $d =$ difference in two group means ($m_1 - m_2$) \
- $s =$ pooled standard deviation \
- $s_0 =$ small constant (it depends on the variance within the group).

The constant is added to the denominator in order to avoid a division by an
extremely low number, which would of course increase the result of the statistic
falsely inducing us into rejecting the null hypothesis, thus considering the
difference as significant, when it is not. When performing multiple hypothesis
testing, though, there is a high chance of rejecting the null hypothesis when it
is true (type I error), thus a method to control the False Discovery Rate is
required: in this case we opted for Benjamini-Hochberg correction. In
conclusion, the alternative hypothesis is rejected when the adjusted p-value is
smaller than the confidence threshold that was set at the beginning of this
document to `r p.cut`. This means we accept `r p.cut * 100`% false positives
among the features called *significant*.

```{r analysis}
## Factor sample source, sex and age
source <- factor(res$source)
sex <- factor(res$sex)

## Fit the data to the desired design
dsgn <- model.matrix(~ 0 + source + sex)
fit <- lmFit(log2(assay(res, "normalized_filled_imputed")), design = dsgn)

## Fit the actual contrasts of interest
contr_mat <- makeContrasts(
  CapvsVen = sourcecapillary - sourcevenous,
  CapvsPlas = sourcecapillary - sourceplasma,
  VenvsPlas = sourcevenous - sourceplasma,
  levels = dsgn)

fit <- contrasts.fit(fit, contrasts = contr_mat)
fit <- eBayes(fit)
adjp <- apply(fit$p.value, 2, p.adjust, method = "BH")
tmp <- data.frame(
    coef = fit$coefficient,
    pvalue = fit$p.value,
    adjp = adjp,
    significant = adjp < p.cut & abs(fit$coefficient) > m.cut
)
tmp$avg.Cap <- rowMeans(
    log2(assay(res, "normalized_filled_imputed")[, res$source == "capillary"]))
tmp$avg.Ven <- rowMeans(
    log2(assay(res, "normalized_filled_imputed")[, res$source == "venous"]))
tmp$avg.Plas <- rowMeans(
    log2(assay(res, "normalized_filled_imputed")[, res$source == "plasma"]))
rowData(res) <- cbind(rowData(res), tmp)

```

We plot then the distribution of p-values, both raw and adjusted:

```{r standards-p-value-histogram, echo = FALSE, fig.path = IMAGE_PATH, fig.width = 7 * phi, fig.height = 7, fig.cap = "Distribution of raw (left) and adjusted p-values (right) for all 3 comparisons."}
par(mfrow = c(3, 2))
hist(rowData(res)$pvalue.CapvsPlas, breaks = 64, xlab = "p value",
     main = "Capillary vs plasma")
hist(rowData(res)$adjp.CapvsPlas, breaks = 64,
     xlab = expression(p[BH]~value),
     main = "Capillary vs plasma")
hist(rowData(res)$pvalue.VenvsPlas, breaks = 64, xlab = "p value",
     main = "Venous vs plasma")
hist(rowData(res)$adjp.VenvsPlas, breaks = 64,
     xlab = expression(p[BH]~value),
     main = "Venous vs plasma")
hist(rowData(res)$pvalue.CapvsVen, breaks = 64, xlab = "p value",
     main = "Capillary vs venous")
hist(rowData(res)$adjp.CapvsVen, breaks = 64,
     xlab = expression(p[BH]~value),
     main = "Capillary vs venous")
```

Thus, most of the metabolites were identified to have significantly different 
concentrations between the comparison. A table with the number of significant 
metabolites is shown below.

```{r table-sig, echo = FALSE, results = "asis"}
tab <- colSums(as.matrix(rowData(res)[, grep("significant", 
                                             colnames(rowData(res)))]))
pandoc.table(tab, style = "rmarkdown",
             caption = paste0("Number of significant features of the in",
                              " total ", nrow(res), " analyzed features."))
```

### Volcano plots

We first evaluate features found to be significantly different between two 
matrices visually by generating volcano plots:

```{r volcano, echo = FALSE, fig.path = IMAGE_PATH, fig.width = 10, fig.height = 10, fig.cap = "Volcano plot showing the analysis results for the comparison between capillary and venous samples (left), capillary and plasma samples (mid) and venous and plasma samples (right)."}
plot_volcano <- function(x, contrast = y, main = "", xlim, ylim) {
    X <- rowData(x)[, paste0("coef.", contrast)]
    Y <- rowData(x)[, paste0("adjp.", contrast)]
    minp <- min(Y[Y > 0])
    Y[Y == 0] <- minp / 100
    Y <- -log10(Y)
    if (missing(xlim))
        xlim <- range(X)
    if (missing(ylim))
        ylim <- range(Y)
    plot(X, Y,
         xlab = expression(log[2]~difference),
         ylab = expression(-log[10]~p[BH]), pch = 16, col = "#00000060",
         xlim = xlim, ylim = ylim, main = main)
    rect(xleft = -100, ybottom = -log10(p.cut), xright = -m.cut, ytop = 100,
         border = NA, col = paste0(brewer.pal(3, "Set1")[2], 10))
    rect(xleft = m.cut, ybottom = -log10(p.cut), xright = 100, ytop = 100,
         border = NA, col = paste0(brewer.pal(3, "Set1")[2], 10))
        sigs <- rowData(x)[, paste0("significant.", contrast)]
    if (any(sigs))
        points(X[sigs], Y[sigs], col = paste0(brewer.pal(3, "Set1")[2], "ce"))
}
par(mfrow = c(1, 3))
XL <- c(-15, 15)
YL <- c(0, 60)
plot_volcano(res, "CapvsVen", xlim = XL, ylim = YL,
             main = "Capillary vs Venous")
grid()
plot_volcano(res, "CapvsPlas", xlim = XL, ylim = YL,
             main = "Capillary vs Plasma")
grid()
plot_volcano(res, "VenvsPlas", xlim = XL, ylim = YL,
             main = "Venous vs Plasma")
grid()
```

```{r, echo = FALSE}
png(paste0(FIG_PATH, "FIG_NEG_volcano_untargeted.png"),
    width = 12, height = 4, units = "cm", res = 600, pointsize = 6)
par(mfrow = c(1, 3), mar = c(4, 4.2, 1.5, 0.5))
XL <- c(-15, 15)
YL <- c(0, 60)
plot_volcano(res, "CapvsVen", xlim = XL, ylim = YL,
             main = "Capillary vs Venous")
grid()
plot_volcano(res, "CapvsPlas", xlim = XL, ylim = YL,
             main = "Capillary vs Plasma")
grid()
plot_volcano(res, "VenvsPlas", xlim = XL, ylim = YL,
             main = "Venous vs Plasma")
grid()
dev.off()

```


Fewer significant features are shown in the volcano plot of the matrix 
comparison of capillary and venous samples (left) compared to the other two 
plots. Also, both sides of the volcano plot are more balanced, whereas the 
plots of the other two comparisons show a higher abundance of significant 
features on the positive side of the log2 scale, which indicates that less 
features that were found to be significant in the latter two matrix comparison
have a higher signal intensity in plasma compared to venous or capillary blood.
The analyses of significant features of capillary samples versus plasma samples
and of venous samples versus plasma samples seem more comparable according to 
the volcano plots.

### UpSetR plot of the significant features

We then compare the features found to be significant in the 1 vs 1 matrix 
comparison across all three analyses by creating an `UpSetR` plot:

```{r overlap-significant-ft-upset, fig.path = IMAGE_PATH, fig.cap = "Overlap of significant features for the comparison between capillary and venous samples, capillary and plasma samples and venous and plasma samples.", echo = FALSE, eval = TRUE}
listInput <- list(CapvsVen = which(rowData(res)$significant.CapvsVen, 
                                   useNames = TRUE),
                  CapvsPlas = which(rowData(res)$significant.CapvsPlas, 
                                    useNames = TRUE),
                  VenvsPlas = which(rowData(res)$significant.VenvsPlas, 
                                    useNames = TRUE))
upset(fromList(listInput), order.by = "freq")
```

240 of the 729 features found to be significant in at least one of the matrix 
comparisons are shared between the comparison of capillary and plasma samples 
and the comparison between venous and plasma samples, whereas 253 features are 
shared throughout all analyses. 41 features were found to be significant when 
comparing venous against plasma samples, 8 features are only found significant 
when capillary and plasma samples are compared and only three features are 
linked to the comparison of capillary and venous samples exclusively.

### Heatmap

We want to plot a heatmap for the features found to be significant in at least 
one matrix comparison.

```{r heatmap-subset, echo = FALSE}

sig_CV <- which(rowData(res)$significant.CapvsVen, useNames = TRUE)
sig_CP <- which(rowData(res)$significant.CapvsPlas, useNames = TRUE)
sig_VP <- which(rowData(res)$significant.VenvsPlas, useNames = TRUE)

sig_ft <- unique(c(sig_CV, sig_CP, sig_VP))

```

Therefore, we generate a heatmap of individual log2 abundances for these 
features:

```{r heatmap-log2, fig.path = IMAGE_PATH, fig.width = 15, fig.height = 10, fig.cap = "Heatmap of log2 abundances for significant features.", echo = FALSE}
## Create heatmap
tmp <- log2(assay(res, "normalized_filled_imputed")[sig_ft, , drop = FALSE])
tmp <- tmp - rowMeans(tmp, na.rm = TRUE)
ann <- data.frame(source = colData(res)[, c("source")])
rownames(ann) <- colnames(tmp)
pm <- pheatmap(tmp, annotation_col = ann, labels_col = res$sample,
               annotation_color = list(source = col_source),
               labels_row = rep("", nrow(tmp)))
```

```{r, echo = FALSE}
pheatmap(tmp, annotation_col = ann, labels_col = res$sample,
         annotation_color = list(source = col_source),
         labels_row = rep("", nrow(tmp)),
         filename = paste0(FIG_PATH, "FIG_NEG_heatmap_untargeted.png"),
         width = 7, height = 10)

```


The data is separated into two main clusters, one containing all plasma samples
and the other containing all capillary and venous samples which indicates a
higher similarity between the latter ones.  In the heatmap we observe a cluster
of features that are highly abundant in capillary samples, but lower in plasma
and/or in venous blood in the upper part, whereas in the lower part of the map a
cluster of features, that are low in intensity in capillary blood and higher in
intensity in plasma and venous blood.

# Feature grouping

We now want to group significant features representing signals from
isotopologues or different ions/adducts of the same compound into one bin. This
aims at reducing the complexity of the data set and could help or simplify the
annotation of the features. The analysis is performed on subset of features
found significant in any of the 3 comparisons in three steps: we start by
grouping the features according to their retention time, we then proceed by
separating features within their groups according to their signal across all
samples, and lastly, we refine the groups by similarity of their EIcs. The
reasoning behind this is that signals representing isotopes or ions/adducts
originating from the same compound are expected to have the same abundance per
sample and are expected to elute at the same retention time from the LC, with
their elution pattern (=EIC) being highly similar

First, we have to create a subset of the features, we want to consider for our 
analysis:

```{r subset-feature-groups}
register(SerialParam())
load("data/RData/vams_normalization_neg/data_neg_filled.RData")
data_study <- filterFile(data_neg, match(res$mzML_file, data_neg$mzML_file),
                         keepFeatures = TRUE)
## Define the initial feature groups, i.e. assign all significant features
## to "FG" keeping all others to NA
fgs <- rep(NA_character_, nrow(featureDefinitions(data_study)))
names(fgs) <- rownames(featureDefinitions(data_study))
sig_in_any <- rowData(res)$significant.CapvsVen |
                         rowData(res)$significant.CapvsPlas |
                                    rowData(res)$significant.VenvsPlas
fgs[rownames(rowData(res))[sig_in_any]] <- "FG"
featureGroups(data_study) <- fgs
```

We now group the features based on their retention time. Therefore, we evaluate
retention times and m/z of all features in the present data set.

```{r plot-retention-time, fig.path = IMAGE_PATH, fig.width = 15, fig.height = 10, fig.cap = "Distribution of retention time and m/z of all features. Significant features are highlighted with a red color.", echo = FALSE}
plot(featureDefinitions(data_study)$rtmed, featureDefinitions(data_study)$mzmed,
     xlab = "retention time", ylab = "m/z", main = "features", pch = 16,
     col = "#00000040")
points(featureDefinitions(data_study)$rtmed[!is.na(fgs)],
       featureDefinitions(data_study)$mzmed[!is.na(fgs)],
       col = "#ff000080")
grid()
```

There are several features with about the same retention time but different m/z
seen in the plot, especially at the beginning of the LC, but also at rt about
160. Below, we group features within a retention time of 5 seconds into 
*feature groups*.

```{r}
data_study <- groupFeatures(data_study, param = SimilarRtimeParam(5))
```

The significant features were grouped into in total
`r length(table(featureGroups(data_study)))` groups. We now determine the size
of each feature group (i.e. how many features are grouped together).

```{r, echo = FALSE, results = "asis"}
tmp <- table(featureGroups(data_study))
## average retention time per group
rts <- aggregate(featureDefinitions(data_study)$rtmed,
                 by = list(featureGroups(data_study)), FUN = mean)
tab <- data.frame(group_id = names(tmp),
                  count = as.integer(tmp),
                  rt = rts[match(names(tmp), rts[, 1]), 2])
pandoc.table(tab, style = "rmarkdown",
             caption = "Feature groups after grouping by retention time.")
```

In addition, we visualize these feature groups showing all features in the 
m/z-retention time space with grouped features being connected with a line.

```{r feature-grouping-retention-time, fig.path = IMAGE_PATH, fig.width = 5 * phi, fig.height = 5, fig.cap = "Feature groups defined with a retention time window of 5 seconds."}
plotFeatureGroups(data_study)
grid()
```

After this first grouping step, we evaluate the correlation of features based 
on their (raw, log2 transformed) abundances across samples with a heatmap.

```{r feature-grouping-cormat, fig.path = IMAGE_PATH, fig.cap = "Pairwise correlation of feature abundances across samples.", echo = FALSE, fig.height = 10, fig.width = 10}
fvals <- log2(featureValues(data_study, filled = TRUE))
## subset to significant features
fvals <- fvals[!is.na(featureGroups(data_study)), ]
cormat <- cor(t(fvals), use = "pairwise.complete.obs")
ann <- data.frame(
    fgroup = featureGroups(data_study)[!is.na(featureGroups(data_study))])
rownames(ann) <- rownames(cormat)
hm <- pheatmap(cormat, annotation_row = ann, cluster_rows = TRUE,
               cluster_cols = TRUE, show_colnames = FALSE,
               show_rownames = FALSE)
```

A high correlation between sets of features can be observed. The feature groups
are divided into smaller clusters according to their log2 transformed
abundances. To restrict feature groups to only highly correlated features we use
an arbitrary correlation coefficient cut-off of 0.7

We then refine our feature groups using the *groupFeatures* with the
*AbundanceSimilarityParam* to group features with a correlation higher than 0.7 
including both detected and filled-in signal. 

```{r correlation-analysis}
data_study <- groupFeatures(
    data_study, AbundanceSimilarityParam(threshold = 0.7, transform = log2),
    filled = TRUE)
```

The table below shows the significant features and their assigned feature group.
In total `r length(table(featureGroups(data_study)))` groups have been found at
this point.

```{r, echo = FALSE, results = "asis"}
tmp <- table(featureGroups(data_study))
rts <- aggregate(featureDefinitions(data_study)$rtmed,
                 by = list(featureGroups(data_study)), FUN = mean)
tab <- data.frame(group_id = names(tmp),
                  count = as.integer(tmp),
                  rt = rts[match(names(tmp), rts[, 1]), 2])
pandoc.table(tab, style = "rmarkdown",
             caption = paste0("Feature groups after grouping by retention time",
                              " and similarity of abundance across samples."))
```

Many of the larger retention time-based feature groups have been split into 
two or more sub-groups based on the correlation of their feature abundances, 
such as *FG.001*, *FG.114* or *FG.224*. 

```{r pairwise-correlation, fig.path = IMAGE_PATH, fig.cap = "Pairwise correlation of features initially grouped in feature group FG.001.", echo = FALSE, fig.height = 10, fig.width = 10}
fts <- rownames(featureDefinitions(data_study))[
    grep("FG.001", featureGroups(data_study))]
pairs(t(fvals[fts, ]), gap = 0.1, main = "FG.0.01")
```

Features seem to be uncorrelated to each other in this initial feature.

```{r pairwise-correlation-fg114, fig.path = IMAGE_PATH, fig.cap = "Pairwise correlation of features initially grouped in feature group FG.114.", echo = FALSE, fig.height = 10, fig.width = 10}
fts <- rownames(featureDefinitions(data_study))[
    grep("FG.114", featureGroups(data_study))]
pairs(t(fvals[fts, ]), gap = 0.1, main = "FG.114")
```

Correlation can be seen for some features (between FT11396 and FT13447) but most
are uncorrelated to each other in this initial feature group.

```{r pairwise-correlation-fg224, fig.path = IMAGE_PATH, fig.cap = "Pairwise correlation of features initially grouped in feature group FG.224.", echo = FALSE, fig.height = 10, fig.width = 10}
fts <- rownames(featureDefinitions(data_study))[
    grep("FG.224", featureGroups(data_study))]
pairs(t(fvals[fts, ]), gap = 0.1, main = "FG.224")
```

Also for this feature group, only two features are correlated while all others
are uncorrelated.

Other feature groups, such as *FG.210* were not splitted.

```{r pairwise-correlation-fg210, fig.path = IMAGE_PATH, fig.cap = "Pairwise correlation of features initially grouped in feature group FG.210.", echo = FALSE, fig.height = 10, fig.width = 10}
fts <- rownames(featureDefinitions(data_study))[
    grep("FG.210", featureGroups(data_study))]
pairs(t(fvals[fts, ]), gap = 0.1, main = "FG.210")
```

We visualize again the feature groups after the sub-grouping by similarity in
abundance across samples.

```{r feature-grouping-abundance-correlation, fig.path = IMAGE_PATH, fig.width = 5 * phi, fig.height = 5, fig.cap = "Feature groups after sub-grouping by abundance similarity."}
plotFeatureGroups(data_study)
grid()
```

In the last step of the feature grouping analysis, we perform the grouping based
on similarity of the EICs. The chromatographic peak shape of an ion of a 
compound should be highly similar to the elution pattern of this compound. 
Thus, features from the same compound are assumed to have similar peak shapes 
of their EICs within the same sample (sneumann). 
As peak shape correlation is computationally intense, we perform this analysis 
on a subset of samples with highest intensity per feature abundance within a
feature group. So, we first identify the 3 samples with highest intensity, then
a pairwise similarity calculation is performed and the resulting similarity
score is aggregated. If this value is greater than the cut-off threshold 0.7, 
the peaks are assigned to the same feature group.

```{r eic-similarity}
data_study <- groupFeatures(
    data_study, EicSimilarityParam(threshold = 0.7, n = 3))
```

The table below shows the significant features and their assigned feature group.
In the end, the features have been split into
`r length(table(featureGroups(data_study)))` groups.

```{r, echo = FALSE, results = "asis"}
tmp <- table(featureGroups(data_study))
rts <- aggregate(featureDefinitions(data_study)$rtmed,
                 by = list(featureGroups(data_study)), FUN = mean)
tab <- data.frame(group_id = names(tmp),
                  count = as.integer(tmp),
                  rt = rts[match(names(tmp), rts[, 1]), 2])
pandoc.table(tab, style = "rmarkdown",
             caption = paste0("Feature groups after grouping by retention time",
                              ", similarity of abundance across samples and ",
                              "EIC similarity."))
```

In most cases, pre-defined feature groups (by the abundance correlation) were 
not further subdivided. Below we evaluate some of the feature groups, starting 
with *FG.171.001* which was split into 2 different feature groups based on EIC 
correlation. We first extract the EICs for all features from this initial 
feature group. With n = 1 we specify to extract the EIC only from the sample 
with the highest intensity.

```{r EIC-extraction-FG, echo = TRUE}
fts <- grep("FG.171.001", featureGroups(data_study))
eics <- featureChromatograms(data_study, features = fts,
                             filled = TRUE, n = 1)
```

Next we plot the EICs using a different color for each of the subgroups. With 
peakType = "none" we disable the highlighting of the detected chromatographic 
peaks.

```{r EICs-FG.171.001, fig.path = IMAGE_PATH, fig.cap = "EICs for all features from the inital feature group FG.071.001. Subgrops were colored differenly.", echo = FALSE, fig.height = 10, fig.width = 10}
cols <- brewer.pal(n = 9, "Set1")
fgs <- unique(featureGroups(data_study)[fts])
cols <- cols[seq_along(fgs)]
names(cols) <- fgs

par(mfrow = c(1, 2))
plotChromatogramsOverlay(
    eics, col = paste0(cols[featureGroups(data_study)[fts]], 80),
    lwd = 2, peakType = "none")
legend("topright", legend = names(cols), lty = 1, lwd = 2, col = cols,
       title = "feature group")
plotChromatogramsOverlay(
    normalize(eics), col = paste0(cols[featureGroups(data_study)[fts]], 80),
    lwd = 2, peakType = "none")
```

On the left side we see the actual intensities, the normalized are shown on the
right.

We evaluate next the sub-grouping in another feature group (*FG.216.001*) that
was split into 2 distinct groups.

```{r EIC-extraction-FG.216.001, echo = TRUE}
fts <- grep("FG.216.001", featureGroups(data_study))
eics <- featureChromatograms(data_study, features = fts,
                             filled = TRUE, n = 1)
```

Next we plot the EICs using a different color for each of the subgroups. With 
`peakType = "none"` we disable the highlighting of the detected chromatographic 
peaks.

```{r EICs-FG.216.001,  fig.path = IMAGE_PATH, fig.cap = "EICs for all features from the inital feature group FG.216.001. Subgrops were colored differenly.", echo = FALSE, fig.height = 10, fig.width = 10}
cols <- brewer.pal(n = 9, "Set1")
fgs <- unique(featureGroups(data_study)[fts])
cols <- cols[seq_along(fgs)]
names(cols) <- fgs

par(mfrow = c(1, 2))
plotChromatogramsOverlay(
    eics, col = paste0(cols[featureGroups(data_study)[fts]], 80),
    lwd = 2, peakType = "none")
legend("topright", legend = names(cols), lty = 1, lwd = 2, col = cols,
       title = "feature group")
plotChromatogramsOverlay(
    normalize(eics), col = paste0(cols[featureGroups(data_study)[fts]], 80),
    lwd = 2, peakType = "none")
```

At last, we create such overview plots for all feature groups (code hidden).

```{r feature-grouping-overview-plots, echo = FALSE}
fgs <- unique(featureGroups(data_study))
fgs <- fgs[!is.na(fgs)]
dr <- paste0(IMAGE_PATH, "feature_groups/")
dir.create(dr, showWarnings = FALSE)
for (fg in fgs) {
    fts_idx <- which(featureGroups(data_study) == fg)
    eics <- featureChromatograms(data_study, features = fts_idx,
                                 expandRt = 2, filled = TRUE, n = 2)
    png(paste0(dr, fg, ".png"), width = 12, height = 6, units = "cm",
        res = 300, pointsize = 4)
    par(mfrow = c(2, 2))
    ft_cols <- brewer.pal(max(3, length(fts_idx)), "Paired")[seq_along(fts_idx)]
    plotChromatogramsOverlay(normalize(eics[, 1, drop = FALSE]), lwd = 2,
                             col = paste0(ft_cols, 80),
                             main = paste0(fg, ": ", colnames(eics)[1]))
    legend("topright",
           legend = rownames(featureDefinitions(data_study))[fts_idx],
           col = ft_cols, lty = 1)
    plotChromatogramsOverlay(normalize(eics[, 2, drop = FALSE]), lwd = 2,
                             col = paste0(ft_cols, 80),
                             main = paste0(fg, ": ", colnames(eics)[2]))
    legend("topright",
           legend = rownames(featureDefinitions(data_study))[fts_idx],
           col = ft_cols, lty = 1)
    if (nrow(eics) > 1) {
        mz_y <- joyPlot(eics[, 1, drop = FALSE], col = ft_cols)
        abline(h = mz_y, col = paste0(ft_cols, 40), lty = 3)
        text(x = rep(min(unlist(lapply(eics, rtime))), length(mz_y)),
             y = mz_y, labels = format(mz(eics)[, 1], digits = 6),
             col = ft_cols, pos = 4)
        mz_y <- joyPlot(eics[, 2, drop = FALSE], col = ft_cols)
        abline(h = mz_y, col = paste0(ft_cols, 40), lty = 3)
        text(x = rep(min(unlist(lapply(eics, rtime))), length(mz_y)),
             y = mz_y, labels = format(mz(eics)[, 1], digits = 6),
             col = ft_cols, pos = 4)
    }
    dev.off()
    if (nrow(eics) > 1) {
        fvals <- log2(featureValues(data_study, filled = TRUE)[fts_idx, ])
        cormat <- cor(t(fvals), use = "pairwise.complete.obs")
        ann <- data.frame(fgroup = featureGroups(data_study)[fts_idx])
        rownames(ann) <- rownames(cormat)
        hm <- pheatmap(cormat, annotation_row = ann, cluster_rows = TRUE,
                       cluster_cols = TRUE,
                       filename = paste0(dr, fg, "_heatmap.png"))
    }
}
```



# Session information

```{r}
sessionInfo()
```
