---
title: "Matrix comparison"
author: "Johannes Rainer, SÃ¸ren Fjelstr, Chiara Volani and Giuseppe Paglia"
graphics: yes
output:
  BiocStyle::html_document:
    toc_float: true
bibliography: references.bib
csl: biomed-central.csl
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

```{r biocstyle, echo = FALSE, results = "hide"}
library(BiocStyle)
BiocStyle::markdown()
```

**Modified**: `r file.info("vams_matrix_pos.Rmd")$mtime`<br />
**Compiled**: `r date()`

```{r settings, echo = FALSE, results = "hide", message = FALSE}
#' Set general options
options(useFancyQuotes = FALSE)
set.seed(18011977)

#' Define paths:
filename <- "vams_matrix_pos"
#' Path to save the images; remove all old images.
IMAGE_PATH <- paste0("images/", filename, "/")
if (file.exists(IMAGE_PATH)) 
    unlink(IMAGE_PATH, recursive = TRUE)
dir.create(IMAGE_PATH, recursive = TRUE)
#' Path to store RData files
RDATA_PATH <- paste0("data/RData/", filename, "/")
if (!file.exists(RDATA_PATH)) dir.create(RDATA_PATH, recursive = TRUE)

#' Get the number of cpus allocated or fall back to 3
ncores <- as.integer(Sys.getenv("SLURM_JOB_CPUS_PER_NODE", 3))
```

# Introduction

In this document we evaluate differences between the 4 matrices (sample sources)
*venous*, *capillary*, *plasma* and *RBC*. We are specifically interested in
identifying features which are specific to one matrix or common to all matrices
(qualitative analysis) as well as features with different abundances between
matrices (quantitative analyses). For the former analysis we use determine for
each feature whether it is *present* in a sample or not based on whether a
chromatographic peak was identified for it. The latter analysis is based on the
feature abundances.

The analysis uses the normalized feature abundances generated in
[vams_normalization.Rmd](vams_normalization.Rmd). The normalized data contains
abundance estimates for all features that are present in at least 30% of samples
of a matrix (QC samples excluded). The abundances from the two technical
replicates of each sample were combined into a single feature abundance. Also,
weights have been defined that provide information about the *quality* of a
normalized feature concentration. It is based on whether a chromatographic peak
was identified in a sample and how similar the reported abundances for the
feature in the two (technical) replicates for each sample are. Based on their
weight, features can be classified into 6 different types:

- `1`: signal from 2 detected peaks present and the RSD of their abundances is <
  30%. The `mean` of the two is reported.
- `0.9`: 1 detected and one filled-in signal present and their RSD is < 30%. The
  `mean` of the two is reported.
- `0.8`: only filled-in signal, but their RSD is < 30%. The `mean` of the two is
  reported.
- `0.7`: signal for two detected peaks but their RSD is >= 30%. The `mean` of
  the two is reported.
- `0.5`: signal from 1 detected peak present (independently of whether a
  filled-in signal is present for the other replicate). Report only
  the value for the detected peak.
- `0.25`: only filled-in signal is present. Either mean or single value
  reported.

Below we load all required libraries, define a color for each matrix and load
the normalized data.

```{r load-data , results='hide'}
library(xcms)
library(RColorBrewer)
library(pander)
library(doParallel)
registerDoParallel(ncores)
register(DoparParam(), default = TRUE)
#' register(SerialParam())
library(SummarizedExperiment)
library(UpSetR)
library(pls)
library(caret)

#' Load utility functions for the analysis
source("util-functions.R")

#' Define colors for the groups.
col_source <- brewer.pal(5, name = "Set1")[c(1, 2, 4, 5)]
names(col_source) <- c("RBC",           #' red
                       "plasma",        #' blue
                       "capillary",     #' purple
                       "venous")        #' orange

load("data/RData/vams_normalization/vams_pos.RData")

#' Remove rows/features that have only missing values
#' vams_pos <- vams_pos[rowNaProp(assay(vams_pos, "abundances")) < 1, ]
#' vams_pos <- vams_pos[1:400, ]

```


## Identifying detected/present features for each matrix

We next aim to identify *present* (detected) features for each matrix which
allows to perform qualitative comparisons between the matrices. In contrast to
features with differences in abundances (identified in the next section) we do
not consider absolute intensities in this analysis but rather evaluate whether a
feature is detected in most samples of a matrix or not, i.e. whether a
chromatographic peak was identified or not. This information is encoded into th
*weight* of a measurement (see Introduction for the definition of the weights):
a chromatographic peak was detected for a feature in at least one of the two
replicates if the weight is either 1, 0.9, 0.7 or 0.5. Below we use these
weights to determine the proportion of samples for each matrix in which a
chromatographic peak was identified.

```{r proportion-detected, message = FALSE, warning = FALSE}
wght_detected <- c(1, 0.9, 0.7, 0.5)

#' Determine for each feature the proportion of samples (per matrix) in
#' which a peak was detected/
prop_detected <- apply(assay(vams_pos, "weights"), 1, function(x, grps) {
    vapply(split(x, grps), function(z) sum(z %in% wght_detected) / length(z),
           numeric(1))
}, grps = vams_pos$source)
prop_detected <- t(prop_detected)
```

Defining absent/present calls is not trivial. Using a hard cut-off on the
proportion of samples with a detected peak can be problematic, as features can
not be expected to be present in all samples. Sex-specific features would for
example be expected to be present in only 50% of samples. Requiring features to
be present in 60% of samples to define them as *present* would thus flag all
sex-specific features to be *absent*.

We therefore use an approach that compares, separately for each feature, and in
each matrix the number of samples in which a chromatographic peak was detected
to the maximum such number in any of the matrices. Specifically, features are
called *absent* in a certain matrix, if a peak was detected in less than one
third of the maximal number of samples with a detected peak in any of the
matrices. As example, if a feature was detected in 10 samples of a matrix, but
only in 3 in another matrix, it will be called *absent* in the latter. On the
other hand, if a feature was detected at most in 4 samples in a matrix, it is
still considered to be present in matrices in which e.g. in 2 samples a peak was
detected.

Below we calculate first the ratio between the proportion of samples in which a
peak was detected and the maximal proportion for that feature and subsequently
define the absent/present calls for each feature in each matrix based on these
values.

Note that the present analysis bases on features with a detected peak in at
least 1/3 of samples.

```{r present-absent-call, message = FALSE, warning = FALSE}
#' Calculate ratio between proportion and max proportion
prop_ratio <- (1 / rowMax(prop_detected)) * prop_detected

#' Define present/absent calls
present_call <- prop_ratio > 1/3
```


## Comparison of numbers of features detected in each matrix

With the present/absent calls available we can next evaluate the number of
features being detected in each matrix. The results are represented with the
barplot below.

```{r barplot-features, message = FALSE, warning = FALSE, echo = FALSE, fig.path = IMAGE_PATH, fig.cap = "Number of features detected by each matrix", fig.width = 6, fig.height = 8}
par(mfrow = c(1, 1), mar = c(7, 4.5, 2, 0.5))
barplot(colSums(present_call), col = col_source[colnames(present_call)],
        main = "Detected features", ylab = "count", las = 2)
```

Not unexpectedly, most features are present in venous samples followed by
capillary and RBC samples. The fewest are present in plasma samples. The numbers
are shown also in the table below.

```{r feature-count-table, results = "asis", echo = FALSE}
cpt <- paste0("Number of features detected in each matrix")
pandoc.table(colSums(present_call), style = "rmarkdown",
             caption = cpt)
```


## Matrix-specific features and features present in all matrices

We next compare the overlaps and intersects of features being *present* in the 4
matrices.

```{r upsetr-plot, message = FALSE, warning = FALSE, echo = FALSE, fig.path = IMAGE_PATH, fig.cap = "Visualisation of the feature intersects between the 4 matrices.", fig.width = 10, fig.height = 8}
ints <- apply(present_call, MARGIN = 2, which)
upset(fromList(ints), order.by = "freq",
      sets.bar.color = col_source[c("venous", "capillary", "RBC", "plasma")])
```

About one third of the ~ 10,000 features is detectable in all 4 matrices. The
next largest overlap with ~ 2,000 features is between venous, capillary and RBC
samples followed by about 1,200 features that are specific to plasma and venous
samples. Over and above the results are as expected, with the largest overlap of
matrices being between samples containing also blood cells. The numbers of
matrix-specific features is with ~ 200 - 600 relatively small, with plasma
samples having the largest number of unique features.

```{r plot-common-features, echo = FALSE, warning = FALSE,eval = FALSE}
load("data/RData/vams_normalization/data_pos.RData")
col_sample <- col_source[data_pos$source]

plot_feats <- function(x, col) {
    col_bg <- paste0(col[chromPeaks(x)[, "sample"]], 20)
    col_fg <- paste0(col[chromPeaks(x)[, "sample"]], 60)
    col_bg[grep("^NA", col_bg)] <- NA
    col_fg[is.na(col_bg)] <- NA
    col_smpl <- paste0(col, 30)
    col_smpl[grep("^NA", col_smpl)] <- NA
    plot(x, col = col_smpl, peakBg = col_bg, peakCol = col_fg)
}

#' Present in all
feats_common <- rownames(present_call)[rowSums(present_call) == 4]
dr <- paste0(IMAGE_PATH, "common_features/")
dir.create(dr, showWarnings = FALSE)
feats <- sample(feats_common, 20)
feats_chrs <- featureChromatograms(data_pos, expandRt = 4, features = feats)
for (i in seq_along(feats)) {
    fn <- paste0(dr, feats[i], ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    plot_feats(feats_chrs[i, ], col = col_sample)
    dev.off()
}

#' Plasma
feats_plasma <- rownames(present_call)[rowSums(present_call) == 1 &
                                       present_call[, "plasma"]]
dr <- paste0(IMAGE_PATH, "plasma_features/")
dir.create(dr, showWarnings = FALSE)
## feats <- sample(feats_plasma, 20)
## feats_chrs <- featureChromatograms(data_pos, expandRt = 4, features = feats)
## for (i in seq_along(feats)) {
##     fn <- paste0(dr, feats[i], ".png")
##     png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
##     plot_feats(feats_chrs[i, ], col = col_sample)
##     dev.off()
## }
#' most specific:
feats <- feats_plasma[order(rowMeans(prop_ratio[feats_plasma, ]))][1:20]
feats_chrs <- featureChromatograms(data_pos, expandRt = 4, features = feats)
for (i in seq_along(feats)) {
    fn <- paste0(dr, feats[i], ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    plot_feats(feats_chrs[i, ], col = col_sample)
    dev.off()
}

#' Venous
feats_venous <- rownames(present_call)[rowSums(present_call) == 1 &
                                       present_call[, "venous"]]
dr <- paste0(IMAGE_PATH, "venous_features/")
dir.create(dr, showWarnings = FALSE)
feats <- feats_venous[order(rowMeans(prop_ratio[feats_venous, ]))][1:20]
feats_chrs <- featureChromatograms(data_pos, expandRt = 4, features = feats)
for (i in seq_along(feats)) {
    fn <- paste0(dr, feats[i], ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    plot_feats(feats_chrs[i, ], col = col_sample)
    dev.off()
}

#' RBC
feats_RBC <- rownames(present_call)[rowSums(present_call) == 1 &
                                    present_call[, "RBC"]]
dr <- paste0(IMAGE_PATH, "RBC_features/")
dir.create(dr, showWarnings = FALSE)
feats <- feats_RBC[order(rowMeans(prop_ratio[feats_RBC, ]))][1:20]
feats_chrs <- featureChromatograms(data_pos, expandRt = 4, features = feats)
for (i in seq_along(feats)) {
    fn <- paste0(dr, feats[i], ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    plot_feats(feats_chrs[i, ], col = col_sample)
    dev.off()
}

#' Capillary
feats_capillary <- rownames(present_call)[rowSums(present_call) == 1 &
                                          present_call[, "capillary"]]
dr <- paste0(IMAGE_PATH, "capillary_features/")
dir.create(dr, showWarnings = FALSE)
feats <- feats_capillary[order(rowMeans(prop_ratio[feats_capillary, ]))][1:20]
feats_chrs <- featureChromatograms(data_pos, expandRt = 4, features = feats)
for (i in seq_along(feats)) {
    fn <- paste0(dr, feats[i], ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    plot_feats(feats_chrs[i, ], col = col_sample)
    dev.off()
}


```

Some example data for features are shown below. The first shows an example for a
*common* feature, i.e. a feature that is present (although at difference
abundance) in all 4 matrices.

```{r out.width = "750px", echo = FALSE, fig.cap = "Feature present in all 4 matrices."}
knitr::include_graphics(paste0(IMAGE_PATH, "common_features/FT02184.png"))
```

Below an example for a plasma-only feature is shown. There seems to be some
signal also for some samples from other matrices, but that is mostly below
detection limit.

```{r out.width = "750px", echo = FALSE, fig.cap = "Plasma-specific feature."}
knitr::include_graphics(paste0(IMAGE_PATH, "plasma_features/FT00481.png"))
```

An example for a venous-specific feature is shown below.

```{r out.width = "750px", echo = FALSE, fig.cap = "Venous-specific feature."}
knitr::include_graphics(paste0(IMAGE_PATH, "venous_features/FT07248.png"))
```

An example for a RBC-only feature is shown below.

```{r out.width = "750px", echo = FALSE, fig.cap = "RBC-specific feature."}
knitr::include_graphics(paste0(IMAGE_PATH, "RBC_features/FT02578.png"))
```

An example for a capillary-specific feature is shown below.

```{r out.width = "750px", echo = FALSE, fig.cap = "Capillary-specific feature."}
knitr::include_graphics(paste0(IMAGE_PATH, "capillary_features/FT01583.png"))
```

What seems to be common to all matrix-specific features is that their abundance
is moderate. Below we thus evaluate whether the average abundance level of
matrix-specific features is different to those from common features.

```{r matrix-specific-abundance, message = FALSE, fig.path = IMAGE_PATH, fig.cap = "Distribution of average (across samples) abundances of common and matrix-specific features.", fig.width = 6, fig.height = 8}
feats_common <- rownames(present_call)[rowSums(present_call) == 4]
feats_plasma <- rownames(present_call)[rowSums(present_call) == 1 &
                                       present_call[, "plasma"]]
feats_venous <- rownames(present_call)[rowSums(present_call) == 1 &
                                       present_call[, "venous"]]
feats_RBC <- rownames(present_call)[rowSums(present_call) == 1 &
                                    present_call[, "RBC"]]
feats_capillary <- rownames(present_call)[rowSums(present_call) == 1 &
                                          present_call[, "capillary"]]

ints <- list(
    common = apply(assay(vams_pos, "abundances")[feats_common, ],
                   MARGIN = 1, mean),
    plasma = apply(assay(vams_pos, "abundances")[feats_plasma,
                                                 vams_pos$source == "plasma"],
                   MARGIN = 1, mean),
    venous = apply(assay(vams_pos, "abundances")[feats_venous,
                                                 vams_pos$source == "venous"],
                   MARGIN = 1, mean),
    RBC = apply(assay(vams_pos, "abundances")[feats_RBC,
                                              vams_pos$source == "RBC"],
                MARGIN = 1, mean),
    capillary = apply(assay(vams_pos, "abundances")[feats_capillary,
                                                    vams_pos$source == "capillary"],
                      MARGIN = 1, mean)
)
par(mar = c(7, 4.5, 1, 1))
boxplot(lapply(ints, log2), varwidth = TRUE, col = col_source[names(ints)],
        ylab = expression(log[2]~abundance), las = 2, main = "average abundance")
grid(nx = NA, ny = NULL)
```

Indeed, the average abundance of matrix-specific features seems to be about
two-fold lower than the abundance of *common* features. Thus many features might
appear to be matrix specific because their abundance is below the detection
limit in other matrices.


## Grouping samples based on metabolite abundances

We perform a principal component analysis to evaluate the grouping of the
samples/matrices in our experiment.

```{r pca-rsd, message = FALSE, warning = FALSE, echo = FALSE, fig.path = IMAGE_PATH, fig.width = 10, fig.height = 10, fig.cap = "PCA grouping samples based on (centered) feature abundances. Only features with an RSD < 30% in QC samples were used. Circles represent samples from female, rectangles from male participants. Missing values were replaced with half of the feature's minimal abundance adding also a small random variance."}
#' RSD < 30% in QC samples
tmp <- log2(assay(vams_pos, "abundances")[which(rowData(vams_pos)$QC_rsd < 0.3), ])
na_prop <- rowNaProp(tmp)
tmp <- imputeRowMinRand(tmp, min_fraction = 1/2)
pc <- prcomp(t(tmp), scale = FALSE, center = TRUE)
pchs <- ifelse(vams_pos$sex == "F", 21, 22)

par(mfrow = c(1, 2), mar = c(4.5, 4.5, 1, 1))
plot_pca(pc, pc_x = 1, pc_y = 2, col = paste0(col_source[vams_pos$source], "ce"),
         bg = paste0(col_source[vams_pos$source], 60), pch = pchs, cex = 1.5)
legend("bottomright", col = col_source, legend = names(col_source), pch = 16)
plot_pca(pc, pc_x = 3, pc_y = 4, col = paste0(col_source[vams_pos$source], 80),
         bg = paste0(col_source[vams_pos$source], 40), pch = pchs, cex = 1.5)

#' plot_pca(pc, pc_x = 2, pc_y = 3, col = paste0(col_source[vams_pos$source], 80),
#'          bg = paste0(col_source[vams_pos$source], 40), pch = 21, cex = 1.5)

```

The PCA above was performed on all features that have an RSD < 30% in QC samples
(about 4000). Missing values were replaced with half of the feature's smallest
abundance adding also a small random value based on the features' standard
deviations. Note that excluding features with `NA` values (~ 1000) or performing
the PCA on all over 10,000 features yielded the same result (data not shown).

As expected, a clear separation of plasma samples from all other samples
(containing also blood cells) can be observed on PC1. Capillary and red blood
cell samples cluster close together, with some RBC samples being closest to the
cluster consisting of venous samples. Both show however a stronger variation
(especially in PC2) than plasma or venous samples. On PC3 we can see again a
separation by matrix, with plasma and venous samples being closest. The
separation on PC3 could reflect the different sampling source, i.e. sampling
from the finger tip with the Mitra device (capillary) *vs* sampling from
intravenous blood (venous, plasma and RBC).


## Identifying features with differential abundance between the matrices
ToDO

- Quantitative analysis.
- Use paired statistics.
- Use plasma as baseline.



```{r Initial_Quantitative_Analysis}

#' All feautures present in the respective sample types are found. Note this is different to when only the unique were found.
feats_plasma <- rownames(present_call)[present_call[, "plasma"]]
feats_venous <- rownames(present_call)[present_call[, "venous"]]
feats_RBC <- rownames(present_call)[present_call[, "RBC"]]
feats_capillary <- rownames(present_call)[present_call[, "capillary"]]

#' A list containing the abundances of the respective features were made. Note that they are imputed as it otherwise have too many missing values
ints <- list(
    common = imputeRowMinRand( assay(vams_pos, "abundances")[feats_common, ], min_fraction = 1/2, sd_fraction = 1, abs = TRUE),
    
    plasma = imputeRowMinRand( assay(vams_pos, "abundances")[feats_plasma,
    vams_pos$source == "plasma"], min_fraction = 1/2, sd_fraction = 1, abs = TRUE),
    
    venous = imputeRowMinRand( assay(vams_pos, "abundances")[feats_venous,
    vams_pos$source == "venous"], min_fraction = 1/2, sd_fraction = 1, abs = TRUE),
    
    RBC = imputeRowMinRand( assay(vams_pos, "abundances")[feats_RBC,
    vams_pos$source == "RBC"], min_fraction = 1/2, sd_fraction = 1, abs = TRUE),

    capillary= imputeRowMinRand( assay(vams_pos, "abundances")[feats_capillary,
vams_pos$source == "capillary"], min_fraction = 1/2, sd_fraction = 1, abs = TRUE)
)
  
#' Boxplot showing the distributions of the different groups
par(mar = c(7, 4.5, 1, 1))
boxplot(lapply(ints, log2), varwidth = TRUE, col = col_source[names(ints)],
        ylab = expression(log[2]~abundance), las = 2, main = "average abundance")

(Medianslog2 <- list(
  common=median(unlist(lapply(ints$common,log2))),
  
  plasma=median(unlist(lapply(ints$plasma,log2))),
  
  venous=median(unlist(lapply(ints$venous,log2))),
  
  RBC=median(unlist(lapply(ints$RBC,log2))),
  
  capillary=median(unlist(lapply(ints$capillary,log2)))
))

#' Cumulative distribution functions are made for the different groups, log2 is necessary due to the large differences in abundances
plasma_ecdf <- ecdf(unlist(lapply(ints$plasma,log2)))
venous_ecdf <- ecdf(unlist(lapply(ints$venous,log2))) 
RBC_ecdf <- ecdf(unlist(lapply(ints$RBC,log2)))
capillary_ecdf <- ecdf(unlist(lapply(ints$capillary,log2)))

plot(plasma_ecdf, col = col_source[names(ints[2])],main = "cdf of abundance")
plot(venous_ecdf, col = col_source[names(ints[3])],add=TRUE)
plot(RBC_ecdf, col = col_source[names(ints[4])],add=TRUE)
plot(capillary_ecdf, col = col_source[names(ints[5])],add=TRUE)

legend('right', names(ints[2:5]), fill=col_source, border=NA)


#' The cdf's are zoomed at the low abundances as it is here a differences can be seen.
plot(plasma_ecdf, col = col_source[names(ints[2])],xlim=c(5,11),ylim=(c(0,0.6)),main = "cdf of abundance - Zoomed")
plot(venous_ecdf, col = col_source[names(ints[3])],add=TRUE)
plot(RBC_ecdf, col = col_source[names(ints[4])],add=TRUE)
plot(capillary_ecdf, col = col_source[names(ints[5])],add=TRUE)

legend('left', names(ints[2:5]), fill=col_source, border=NA)




#' A PCA is performed of the samples.
pc <- prcomp(t(ints$common), scale = FALSE, center = TRUE)
pchs <- ifelse(vams_pos$sex == "F", 21, 22)

par(mfrow = c(1, 2), mar = c(4.5, 4.5, 1, 1))
plot_pca(pc, pc_x = 1, pc_y = 2, col = paste0(col_source[vams_pos$source], "ce"),
         bg = paste0(col_source[vams_pos$source], 60), pch = pchs, cex = 1.5)
legend("topleft", col = col_source, legend = names(col_source), pch = 16)
plot_pca(pc, pc_x = 3, pc_y = 4, col = paste0(col_source[vams_pos$source], 80),
         bg = paste0(col_source[vams_pos$source], 40), pch = pchs, cex = 1.5)


```
The common features have a slightly higher median than any of the other groups
A difference of about 20.6% when compared to the second highest group, the plasma.
This is to be expected as the lower values will be more likely to be missing
across many samples.
The distribution functions generally looks the same, with the most major
differences seen with x equal betwwen 5 and 10. A zoom in were performed at this 
range. (Make integration at this range). The venous have fewer low abundancy 
features, plasma the most. RBC and capillary are comparable.
PCA were performed on the log-transformed features.
Here 6 outlier feautures were identified 
(venous-7","capillary-17","capillary-19","capillary-16","venous-18","capillary-18")


```{r OutlierFilteredPCA}

#' PCA is performed again for easier comparison, remove in future version
pc <- prcomp(t(ints$common), scale = FALSE, center = TRUE)
pchs <- ifelse(vams_pos$sex == "F", 21, 22)

par(mfrow = c(1, 2), mar = c(4.5, 4.5, 1, 1))
plot_pca(pc, pc_x = 1, pc_y = 2, col = paste0(col_source[vams_pos$source], "ce"),
         bg = paste0(col_source[vams_pos$source], 60), pch = pchs, cex = 1.5)
legend("topleft", col = col_source, legend = names(col_source), pch = 16)
plot_pca(pc, pc_x = 3, pc_y = 4, col = paste0(col_source[vams_pos$source], 80),
         bg = paste0(col_source[vams_pos$source], 40), pch = pchs, cex = 1.5)

#' The Outliers are found and the loadings in PC1 is sorted to find the features responsible.
OutlierFilter <- (pc$x[, 1]<(-1e+5) & pc$x[, 2]<(0))
sortedLoading <- sort(pc$rotation[,1])

feats <- c("FT08876","FT08384")
OutlierSamples <- assay(vams_pos, "abundances")[feats, OutlierFilter]
OutlierValues <- assay(vams_pos, "abundances")[feats,]

#' PCA without the outliers are made
intsCommonNoOutliers <- ints$common[,!OutlierFilter]

pc <- prcomp(t(intsCommonNoOutliers), scale = FALSE, center = TRUE)
pchs <- ifelse(vams_pos$sex == "F", 21, 22)

par(mfrow = c(1, 2), mar = c(4.5, 4.5, 1, 1))
plot_pca(pc, pc_x = 1, pc_y = 2, col = paste0(col_source[vams_pos$source], "ce"),
         bg = paste0(col_source[vams_pos$source], 60), pch = pchs, cex = 1.5)
legend("topright", col = col_source, legend = names(col_source), pch = 16)
plot_pca(pc, pc_x = 3, pc_y = 4, col = paste0(col_source[vams_pos$source], 80),
         bg = paste0(col_source[vams_pos$source], 40), pch = pchs, cex = 1.5)



```
Feature FT8876 and feature FT08384 were found to be responsible for the 7 outlier samples and were filtered away.
Removing the outliers resulted in a plot without any real discernable differences
between the groups. 

It was then decided to look at the chromatograms of the two features to determine whether it could be found why they are so different.

```{r Chromatogram, eval=FALSE}
dr <- paste0(IMAGE_PATH, "Outlier_features/")
dir.create(dr, showWarnings = FALSE)


feats <- c("FT08876","FT08384")
feats_chrs <- featureChromatograms(data_pos, expandRt = 4, features = feats)
for (i in seq_along(feats)) {
    fn <- paste0(dr, feats[i], ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    plot_feats(feats_chrs[i, ], col = col_sample)
    dev.off()
}
```

Chromatograms were made of the features responsible for the outliers.
Here it is evident that for the outlier samples these features have values much higher than the rest of the samples.
It is unclear if the smaller peaks at the lower retention times should be included here as well.






Multiple linear regression of the features common for all samples are made. A volcano plot for each of the combination, of plasma compared to all the other sources were made.
```{r multipleRegression}


fitlmFunction <- function(x,dataMat){
  dataMat <- cbind(conc=x,as.data.frame(dataMat))
  dataMat$source <- factor(x = vams_pos$source,levels = c("plasma","capillary", "RBC", "venous"))
  
  mdl <- lm(conc ~ source + age + factor(sex) + batch + factor(sample),data = dataMat)
  smry <- data.frame(summary(mdl)$coefficients)
  
  Output <- c(coef = smry[c("sourcecapillary","sourceRBC","sourcevenous"), 1], pvalue =  smry[c("sourcecapillary","sourceRBC","sourcevenous"), 4])
}
  
Data <- log2(ints$common[,,drop=FALSE])
fitMatrix <- t(apply(Data[,],1,fitlmFunction,dataMat=colData(vams_pos)))
#' names(Output) <- c(paste0("coef.",c("capillary","sourceRBC","venous")), paste0("pvalue.", c("capillary","sourceRBC","venous")))

#' VolcanoPlot
sourceList=list(vams_pos$source)
col_source <- brewer.pal(4, name = "Set1")
col_source[1] <- "#DDDDDD" 


aggregatedMeans <- aggregate(t(ints$common[,,drop=FALSE]),by=sourceList,FUN=mean)
par(mar = rep(2, 4))

divideFunction <- function(Matrix,Vector){
  Matrix/Vector
}

pLimit <- -log10(0.01/length(fitMatrix[,"pvalue1"]))
foldLimit <- 1

colorFilterLowP <- -log10(fitMatrix[,4:6,drop=FALSE])>pLimit

#' higfold is NOT a matrix, find way to reshape
colorFilterHighFold <- abs(log2( unlist(apply(aggregatedMeans[2:4,-1],1,divideFunction,Vector=aggregatedMeans[1,-1])))) > foldLimit


colorFilter <- 1*colorFilterLowP
colorFilter[colorFilterHighFold] <- 2
colorFilter[colorFilterHighFold*colorFilterLowP==1] <- 3
colorFilter <- colorFilter+1

(LowPSum <- apply(colorFilterLowP*1,2,sum))
(LowPProp <- LowPSum/length(colorFilterLowP))
#'apply(colorFilterHighFold*1,2,sum)
(LowPHighFoldSum <- apply(colorFilterHighFold*colorFilterLowP==1,2,sum))
(LowPHighFoldprop <- LowPHighFoldSum/length(colorFilterLowP))

plot(log2(unlist(aggregatedMeans[2,-1])/unlist(aggregatedMeans[1,-1])), -log10(fitMatrix[,"pvalue1"]),main="Plasma VS. Capillary", col=col_source[colorFilter[,1]],ylab = "-log10 , Bonferroni  adjusted p-value",xlab = "log2 fold change")
abline(h=pLimit)
abline(v=foldLimit)
abline(v=-foldLimit)
plot(log2(unlist(aggregatedMeans[3,-1])/unlist(aggregatedMeans[1,-1])), -log10(fitMatrix[,"pvalue2"]),main="Plasma VS. RBC", col=col_source[colorFilter[,2]],ylab = "-log10 , Bonferroni  adjusted p-value",xlab = "log2 fold change")
abline(h=pLimit)
abline(v=foldLimit)
abline(v=-foldLimit)
plot(log2(unlist(aggregatedMeans[4,-1])/unlist(aggregatedMeans[1,-1])), -log10(fitMatrix[,"pvalue3"]),main="Plasma VS. Venous", col=col_source[colorFilter[,3]],ylab = "-log10 , Bonferroni  adjusted p-value",xlab = "log2 fold change")
abline(h=pLimit)
abline(v=foldLimit)
abline(v=-foldLimit)

Rownames <- (row.names(vams_pos))
HighFoldlowPFilter <- colorFilterHighFold*colorFilterLowP==1
#' 




```
A linear model comparing each of the samples to Plasma was made. Accounting for age,sex,batch, and donor.

A volcano plot for each comparison were made, (555,1017,417) (5.4, 9.8, 4.0 %) features for Capillary, RBC and venous respectively were found to have bonferroni adjusted p values above 0.01. With (296,287,27) (2.9, 2.8,0.26 %) in addition having a difference above 1.
This shows thatof the three sources venous is the most alike to the plasma samples, with a small proportional of feautures being different.



Likewise it was decided to perform a PLS analysis of the data. This was done with the entire dataset, and as such imputation was needed due to the many missing values.
80% of the samples are used for training, with the remaining 20%  used for indedpendent validation. The assignment is random.
The training of the PLS is performed with and n=N-1 components and 10 segments these are likewise chosen randomly.
A confusion matrix of the prediction using the model on the test set is produced, together with a graph detailing the PRESS as a function of components used. 2 Fewer than the component in which the minima is reached is used *(This is done manually, but find way to do so automatically)* This is currently 6 components. A new model using  6 components are made. The new model is tested, producing a plot showing the probability scores of the samples *(Find a way to ensure they are normalized to [0,1])* and a new confusion matrix.
This confusion matrix shows that a identification of 100% is possible using PLS, even without adjusting for confounding factors.

```{r PLS}
col_source <- brewer.pal(5, name = "Set1")[c(1, 2, 4, 5)]
names(col_source) <- c("RBC",           #' red
                       "plasma",        #' blue
                       "capillary",     #' purple
                       "venous")        #' orange

sampleSize <- floor(0.8 * length(vams_pos$sample_name))
Data <- assay(vams_pos, "abundances")[,]
Data <- imputeRowMinRand(Data)
tData <- t(Data)

inTrain <- sample(seq(along = vams_pos$source), sampleSize)
inTest <- seq(along = vams_pos$source)[-inTrain]


training <- tData[inTrain,]
test <- tData[-inTrain,]
trainSource <- factor(vams_pos$source,levels=c("RBC","plasma","capillary","venous"))[inTrain]
testSource <- factor(vams_pos$source,levels=c("RBC","plasma","capillary","venous"))[-inTrain]

preProcValues <- preProcess(training)
trainDescr <- predict(preProcValues, training)
testDescr <- predict(preProcValues, test)
useSoftmax <- plsda(trainDescr, trainSource, ncomp = sampleSize-1,validation = "CV")

confusionMatrix(predict(useSoftmax, testDescr),
                testSource)
#' Consider using the sum of the PRESS values to determine the minima instead
#' PRESSValues <- apply(useSoftmax$validation$PRESS,2,sum) 

plot(useSoftmax$validation$PRESS[1,],col=col_source[1],ylab="PRESS", xlab = "PLS - Components", main = "PRESS VS PLS Components",ylim = c(0,ceiling(max(useSoftmax$validation$PRESS))))
legend("topright",legend=levels(trainSource),col = col_source[c(1,2,3,4)],pch = 16)
for (i in 2:4 ) {
   points(useSoftmax$validation$PRESS[trainSource[i],],col=col_source[i]) 
}



Mean <- list(
  capillary = apply(useSoftmax$fitted.values[trainSource=="capillary",,6],2,mean),
  
  plasma = apply(useSoftmax$fitted.values[trainSource=="plasma",,6],2,mean),
  
  RBC = apply(useSoftmax$fitted.values[trainSource=="RBC",,6],2,mean),
  
  venous  = apply(useSoftmax$fitted.values[trainSource=="venous",,6],2,mean)
)

StdDev <- list(
  capillary = 2*apply(useSoftmax$fitted.values[trainSource=="capillary",,6],2,sd),
  
  plasma = 2*apply(useSoftmax$fitted.values[trainSource=="plasma",,6],2,sd),
  
  RBC = 2*apply(useSoftmax$fitted.values[trainSource=="RBC",,6],2,sd),
  
  venous  = 2*apply(useSoftmax$fitted.values[trainSource=="venous",,6],2,sd)
)
  



plot(1:4,Mean$capillary,xlim=c(1,4),ylim=c(-0.2,1.2),type="n",main="Mean of scores"
     ,axes = FALSE,ylab = "Probability Score")
legend("top",legend=names(col_source),col = col_source,pch = 16)
axis(side = 1 ,labels=names(col_source),at=c(1:4))
axis(side = 2 ,at=c(0:0.2:1))
lines(1:4,Mean$capillary,col=col_source["capillary"])
lines(1:4,Mean$plasma,col=col_source["plasma"])
lines(1:4,Mean$RBC,col=col_source["RBC"])
lines(1:4,Mean$venous,col=col_source["venous"])

x <- c(1:4,4:1)

y <- c(Mean$capillary-StdDev$capillary,Mean$capillary[4:1]+StdDev$capillary[4:1])
col_source_alpha <- adjustcolor(col_source, alpha.f = 0.2)
names(col_source_alpha) <- c("RBC",           #' red
                       "plasma",        #' blue
                       "capillary",     #' purple
                       "venous")        #' orange

polygon(x,y,border = NA,col=col_source_alpha["capillary"])

y <- c(Mean$plasma-StdDev$plasma,Mean$plasma[4:1]+StdDev$plasma[4:1])
polygon(x,y,border = NA,col=col_source_alpha["plasma"])

y <- c(Mean$RBC-StdDev$RBC,Mean$RBC[4:1]+StdDev$RBC[4:1])
polygon(x,y,border= NA,col=col_source_alpha["RBC"])

y <- c(Mean$venous-StdDev$venous,Mean$venous[4:1]+StdDev$venous[4:1])
polygon(x,y,border = NA,col=col_source_alpha["venous"])





for (i in 1:length(trainSource)) {
points(1:4,t(useSoftmax$fitted.values[i,,6]),col=col_source[trainSource[i]])
}

useSoftmax <- plsda(trainDescr, trainSource, ncomp = 6,validation = "CV")

confusionMatrix(predict(useSoftmax, testDescr),
                testSource)
#' useSoftmax$scores



```



It was decided to see to what degree the *missing* values could determine the differences between samples as this is ultimatively what could be the issue in using alternative sources of blood.


```{r Missing_value_type}

MissingValues <- 1*is.na(assay(vams_pos, "abundances"))

#' MissingValues <- MissingValues[rowSums(MissingValues==0),]

pc <- prcomp(t(MissingValues), scale = FALSE, center = TRUE)
pchs <- ifelse(vams_pos$sex == "F", 21, 22)
col_source <- brewer.pal(5, name = "Set1")[c(1, 2, 4, 5)]
names(col_source) <- c("plasma",           #' red
                       "capillary",        #' blue
                       "RBC",     #' purple
                       "venous")        #' orange
                       

par(mfrow = c(1, 2), mar = c(4.5, 4.5, 1, 1))
plot_pca(pc, pc_x = 1, pc_y = 2, col = paste0(col_source[vams_pos$source], "ce"),
         bg = paste0(col_source[vams_pos$source], 60), pch = pchs, cex = 1.5)
legend("topright", col = col_source, legend = names(col_source), pch = 16)
plot_pca(pc, pc_x = 2, pc_y = 3, col = paste0(col_source[vams_pos$source], 80),
         bg = paste0(col_source[vams_pos$source], 40), pch = pchs, cex = 1.5)
legend("topright", col = col_source, legend = names(col_source), pch = 16)



fitlmFunction <- function(x,dataMat){
  dataMat <- cbind(conc=x,as.data.frame(dataMat))
  dataMat$source <- factor(x = vams_pos$source)
  
  mdl <- lm(conc ~ source + age + factor(sex) + batch + factor(sample),data = dataMat)
  smry <- data.frame(summary(mdl)$coefficients)
  
  c(coef = smry[c("sourceCapillary","sourceRBC","sourcevenous"), 1], pvalue =  smry[c("sourceplasma","sourceRBC","sourcevenous"), 4])
  
}
  

fitMatrix <- t(apply(MissingValues,1,fitlmFunction,dataMat=colData(vams_pos)))

aggregatedMeans <- aggregate(t(MissingValues),by=sourceList,FUN=mean)
par(mar = rep(2, 4))

col_source <- brewer.pal(4, name = "Set1")
col_source[1] <- "#DDDDDD" 


divideFunction <- function(Matrix,Vector){
  Matrix/Vector
  
}

pLimit <- -log10(0.01/length(fitMatrix[,"pvalue1"]))
foldLimit <- 1

colorFilterLowP <- -log10(fitMatrix[,4:6,drop=FALSE])>pLimit
colorFilterHighFold <- abs(log2( unlist(apply(aggregatedMeans[2:4,-1],1,divideFunction,Vector=aggregatedMeans[1,-1])))) > foldLimit


colorFilter <- 1*colorFilterLowP
colorFilter[colorFilterHighFold] <- 2
colorFilter[colorFilterHighFold*colorFilterLowP==1] <- 3
colorFilter <- colorFilter+1


plot(log2(unlist(aggregatedMeans[2,-1])/unlist(aggregatedMeans[1,-1])), -log10(fitMatrix[,"pvalue1"]),main="Plasma VS. Capillary", col=col_source[colorFilter[,1]],ylab = "-log10 , Bonferroni  adjusted p-value",xlab = "log2 fold change")
abline(h=pLimit)
abline(v=foldLimit)
abline(v=-foldLimit)
plot(log2(unlist(aggregatedMeans[3,-1])/unlist(aggregatedMeans[1,-1])), -log10(fitMatrix[,"pvalue2"]),main="Plasma VS. RBC", col=col_source[colorFilter[,2]],ylab = "-log10 , Bonferroni  adjusted p-value",xlab = "log2 fold change")
abline(h=pLimit)
abline(v=foldLimit)
abline(v=-foldLimit)
plot(log2(unlist(aggregatedMeans[4,-1])/unlist(aggregatedMeans[1,-1])), -log10(fitMatrix[,"pvalue3"]),main="Plasma VS. Venous", col=col_source[colorFilter[,3]],ylab = "-log10 , Bonferroni  adjusted p-value",xlab = "log2 fold change")
abline(h=pLimit)
abline(v=foldLimit)
abline(v=-foldLimit)


MissingValues <- na.omit(MissingValues)
colorFilter <- na.omit(colorFilter)


col_source <- brewer.pal(5, name = "Set1")[c(1, 2, 4, 5)]
names(col_source) <- c("RBC",           #' red
                       "plasma",        #' blue
                       "capillary",     #' purple
                       "venous")        #' orange



par(mfrow= c(1,2))
plot(density(t(aggregatedMeans[1,-1])),col=col_source[2],ylab="Density", xlab = expression(log[2]~abundance), main = "Density function of abunbance")
lines(density(t(aggregatedMeans[2,-1])),col=col_source[1])
lines(density(t(aggregatedMeans[3,-1])),col=col_source[3])
lines(density(t(aggregatedMeans[4,-1])),col=col_source[4])



plot(density(t(aggregatedMeans[1,-1])),col=col_source[2],xlim=c(0,0.2),ylim=(c(0,5)),ylab="Density", xlab = expression(log[2]~abundance), main = "Density function of abunbance - Zoomed")
lines(density(t(aggregatedMeans[2,-1])),col=col_source[1])
lines(density(t(aggregatedMeans[3,-1])),col=col_source[3])
lines(density(t(aggregatedMeans[4,-1])),col=col_source[4])
legend("topright", col = col_source[c(1,2,3,4)], legend = names(col_source), pch = 16)


upset(aggregatedMeans,      sets.bar.color = col_source[c("venous", "capillary", "RBC", "plasma")])

#' seeing this succes it was decided to set all missing values to 0 to see the impact

dataMissingValues <- (assay(vams_pos, "abundances"))
dataMissingValues[is.na(assay(vams_pos, "abundances"))] <- 0
pc <- prcomp(t(dataMissingValues), scale = FALSE, center = TRUE)
pchs <- ifelse(vams_pos$sex == "F", 21, 22)



par(mfrow = c(1, 2), mar = c(4.5, 4.5, 1, 1))
plot_pca(pc, pc_x = 1, pc_y = 2, col = paste0(col_source[vams_pos$source], "ce"),
         bg = paste0(col_source[vams_pos$source], 60), pch = pchs, cex = 1.5)
legend("topright", col = col_source, legend = names(col_source), pch = 16)
plot_pca(pc, pc_x = 3, pc_y = 4, col = paste0(col_source[vams_pos$source], 80),
         bg = paste0(col_source[vams_pos$source], 40), pch = pchs, cex = 1.5)
legend("topright", col = col_source, legend = names(col_source), pch = 16)



```

in the PCA plot It is found that the missing values to a large degree can determine
the differences between the different sources, with Plasma and especially Venous
clustering tightly. The first component is mainly determined by the plasma sample.
The second dimension is not strongly discriminative with the exception of the venous
blood. the first dimension can discriminate between RBC plasma and capillary with
some help from the second dimension.

Thus it was decided to make a linear model to determine what features were
responsible for the discriminatory power.
When comparing the Plasma to the other samples it is found, in the volcano plots,
that although many samples have a relative high fold difference, but the statistical
significance of many of the features are limited. This is no surprising, as seen
in the earlier plots the feautures unique to the different sample sources are
generally low concentration, and it is likely that the "unique" missing features
are simply lower concentration in the other sample sources.

Most samples are as expected found in all sources, and 



The prediction is not stable which together with the fact that more components than 


```{r PLSTest}
data(mdrr)
set.seed(1)
inTrain <- sample(seq(along = mdrrClass), 450)

nzv <- nearZeroVar(mdrrDescr)
filteredDescr <- mdrrDescr[, -nzv]

training <- filteredDescr[inTrain,]
test <- filteredDescr[-inTrain,]
trainMDRR <- mdrrClass[inTrain]
testMDRR <- mdrrClass[-inTrain]

preProcValues <- preProcess(training)

trainDescr <- predict(preProcValues, training)
testDescr <- predict(preProcValues, test)

useSoftmax <- plsda(trainDescr, trainMDRR, ncomp = 1)


confusionMatrix(predict(useSoftmax, testDescr),
                testMDRR)


histogram(~predict(useSoftmax, testDescr, type = "prob")[,"Active",]
          | testMDRR, xlab = "Active Prob", xlim = c(-.1,1.1))
```

```{r NamesTesting}

(TestMatrix <- matrix(,nrow=10,ncol=20))

TestDataFrame <- data.frame(TestMatrix)

colnames(TestDataFrame) <- letters[1:20]

TestDataFrame

```


## Comparison between venous and capillary blood

- 

## Code saved for future use

```{r Histogram tests}

plot(density(unlist(lapply(ints$plasma,log2))),col = col_source[names(ints[2])],ylab="Density", xlab = expression(log[2]~abundance), las = 2, main = "Density function of abunbance")
lines(density(unlist(lapply(ints$venous,log2))),col = col_source[names(ints[3])])
lines(density(unlist(lapply(ints$RBC,log2))),col = col_source[names(ints[4])])
lines(density(unlist(lapply(ints$capillary,log2))),col = col_source[names(ints[5])])


legend("topright", col = col_source, legend = names(col_source), pch = 16)


```
# Session information

```{r sessionInfo}
devtools::session_info()
```

# References
