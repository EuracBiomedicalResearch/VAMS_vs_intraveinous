---
title: "Normalization of the vams vs intraveneous untargeted metabolomics data"
author: "Johannes Rainer, Giuseppe Paglia and Sigurdur Smarason"
graphics: yes
output:
  BiocStyle::html_document:
    toc_float: true
bibliography: references.bib
csl: biomed-central.csl
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

```{r biocstyle, echo = FALSE, results = "asis"}
library(BiocStyle)
BiocStyle::markdown()
```

**Modified**: `r file.info("vams_preprocessing.Rmd")$mtime`<br />
**Compiled**: `r date()`

```{r settings, echo = FALSE, results = "hide", message = FALSE}
##' Set general options
options(useFancyQuotes = FALSE)
set.seed(18011977)

##' Define paths:
filename <- "vams_normalization"
##' Path to save the images; remove all old images.
IMAGE_PATH <- paste0("images/", filename, "/")
if (file.exists(IMAGE_PATH))
    unlink(IMAGE_PATH, recursive = TRUE)
dir.create(IMAGE_PATH, recursive = TRUE)
##' Path to store RData files
RDATA_PATH <- paste0("data/RData/", filename, "/")
if (!file.exists(RDATA_PATH)) dir.create(RDATA_PATH, recursive = TRUE)

use_cached <- TRUE
if (!file.exists(paste0(RDATA_PATH, "data_pos.RData")))
    use_cached <- FALSE

##' Get the number of cpus allocated or fall back to 3
ncores <- as.integer(Sys.getenv("SLURM_JOB_CPUS_PER_NODE", 3))
```

# Introduction

In this document we perform the normalization of the feature abundances of the
*MitYOU* project. This comprises quality assessment based on the feature's
abundances, eventual normalization of a injection order-dependent signal drift
within each batch (if this proves to increase signal quality as determined by
the comparison of abundances from replicated measurements) and removal of
between batch effects. The preprocessing of the data is described in file
*vams_preprocessing.Rmd*.


## Metabolomics data normalization

Untargeted meatabolomics data biased by a variety of different biological and
technical variances. Biological variances include e.g. the amount or
concentration of biofluids while technical variances comprise batch effects
(laboratory conditions, reagent lots), sample degradation over time in long runs
of samples, matrix specific effects (such as ion suppression), temperature
changes within instruments, and variations during sample extraction and
preparation. Sample degratation over time in long runs, oxidization or build-up
of contaminants can lead to signal drifts dependent on the injection order.

Different approaches for the normalization of metabolomics data exist (briefly
described also in [@Livera:2015bo]). Batch correction methods use per-feature
regression models to remove batch effects and signal drifts
[@Dunn:2011bq],[@Wang:2013fe],[@Wehrens:2016ie] but don't usually remove biases
related to the processing of individual samples (with the exception of Batch
Normalizer [@Wang:2013fe]). Other methods such as scaling (e.g. by the total sum
of signal) or RUV (removal of unwanted variance) [@Livera:2015bo] adjust for
such sample-specific biases, but do not remove feature specific signal drifts.

Combinations of such feature-wise and sample-wise normalization strategies
should be possible. Feature-wise normalization approaches, if applied before
normalization adjusting between sample differences, should however be based only
on QC samples, as these are thought to be (at least within the same batch),
independent of any sample processing differences.


## Experimental design and normalization strategy

The samples of the present experiment consist of samples from 20 healthy
volunteers. From each an intravenous and two capillary blood sample were taken,
the latter using 2 Mitra tips. After sampling intravenous blood with two Mitra
tips the blood in the EDTA tube was further processed and centrifuged to
separate peripheral blood cells (PBCs) from plasma. From each of the two
fractions two Mitra tips each were used to collect material. From each
individual thus in total 8 samples are available, 2 capillary, 2 intravenous, 2
plasma and 2 PBC samples. Mitra tips were dried and stored at -80. Next the tips
were resuspended with a solvent containing also internal standards. After sample
preparation, an aliquot was taken from each sample and pooled to create the QC
sample pool. Individual samples were randomly distributed on two 96 well plates,
with the two replicates per individual being put on the same well. The two
plates were measured on consecutive days.

QC samples, that are by design independent of the sample preparation step, can
hence be used to estimate and correct LC-MS specific biases, including a
potential injection order dependent signal drift and batch/run specific
biases. Such effects are thought to be specific for each metabolite. Sample
preparation dependent biases between samples (but independent of the metabolite)
can be estimated or evaluated using internal standards and replicated samples.

It is not clear whether between-sample normalization should be performed before
or after adjustment for LC-MS specific biases. If batch and injection-order
dependent effects are adjusted using QC samples the order should not be
problematic as QC samples are independent of sample processing based
biases. Still, since biases related to the LC-MS system have been added to the
signal *after* biases related to sample processing, removing them first seems to
be more natural.

# Data import and initial quality assessment

Below we load all libraries required for the analysis and the data. We also
fill-in missing peak values, i.e. for features for which not a peak was
identified in all samples, we integrate the signal from the feature area in
these samples. 

```{r libraries-data, message = FALSE}
library(xcms)
library(RColorBrewer)
library(pander)
## register(bpstart(MulticoreParam(ncores)))
library(doParallel)
registerDoParallel(ncores)
register(DoparParam(), default = TRUE)
library(DESeq2)
library(edgeR)

##' Define colors for the groups.
col_source <- brewer.pal(5, name = "Set1")
names(col_source) <- c("RBC",           #' red
                       "plasma",        #' blue
                       "all",           #' green
                       "capillary",     #' purple
                       "venous")        #' orange

load("data/RData/vams_preprocessing/data_pos.RData")
data_pos$batch <- factor(data_pos$batch)
```

```{r local-utility-functions, echo = FALSE, message = FALSE}
#' @description
#'
#' Flags a single model. Returns `TRUE` if it should be flagged, `FALSE`
#' otherwise.
#'
#' @param x a linear model object such as generated by [lm()] or [lmrob()].
#' 
#' @param diff_residual `numeric(1)` defining the cut-off to flag models with
#'     large residuals. All models with a difference between the 25 and 75
#'     percent percentile of residuals are removed.
#'
#' @return `logical(1)`
#'
#' @noRd
flag_model_residual <- function(x, diff_residual = 1) {
    if (length(x) > 1) {
        if (diff(quantile(residuals(x), probs = c(0.25, 0.75))) > diff_residual)
            TRUE
        else FALSE
    } else NA
}

#' @description
#'
#' Flags a single model based on the absolute `mean` of the residuals.
#' Returns `TRUE` if it should be flagged, `FALSE` otherwise.
#'
#' @param x a linear model object such as generated by [lm()] or [lmrob()].
#' 
#' @param cut_off `numeric(1)` defining the cut-off to flag models with
#'     large average residuals.
#'
#' @return `logical(1)`
#'
#' @noRd
flag_model_mean_residual <- function(x, cut_off = 0.5) {
    if (length(x) > 1)
        mean(abs(residuals(x))) > cut_off
    else NA
}


#' @description
#' 
#' Flags model for which valid measurements don't span a minimum required
#' injection index range. This requires `x` being a model of the type
#' `y ~ inj_idx`.
#'
#' @param x a linear model object such as generated by [lm()] or [lmrob()].
#'
#' @param min_range `numeric(1)` defining the minimum range. This is an absolute
#'     value, not a percentage. Means, the function compares the
#'     `diff(range(x$x[, column]))` with `min_range` and flags models that
#'     don't fit that criteria (i.e. have a smaller range).
#'
#' @return `logical(1)`
#'
#' @noRd
flag_model_inj_range <- function(x, min_range = 1, column = "inj_idx") {
    if (length(x) > 1)
        diff(range(x$model[, column])) < min_range
    else NA
}

#' Utility functions to plot model fits for features

#' @description
#'
#' Plot model fits for a *global* model like `y ~ inj_idx * batch`
plot_feature_slopes <- function(y, yfill, data, lmod, main) {
    ##' Two plots, one per batch.
    par(mar = c(0.5, 4.5, 1, 0), mfrow = c(1, 2))
    a <- which(data$batch == data$batch[1])
    y_a <- y[a]
    yfill_a <- yfill[a]
    dta <- data[a, ]
    plot(main = paste0(main, " batch a"), xlab = "", xaxt = "n",
         ylab = expression(log[2]~abundance), ylim = range(yfill, na.rm = TRUE),
         col = paste0(col_source[dta$source], 80), x = dta$inj_idx,
         y = yfill_a)
    points(x = dta$inj_idx, y = y_a, col = paste0(col_source[dta$source], 80),
           pch = 16)
    grid()
    if (!missing(lmod)) {
        if (!is.na(lmod)) {
            if (is.finite(lmod$coefficients[1]) &
                is.finite(lmod$coefficients[2]))
                abline(lmod$coefficients[1:2], col = col_source["all"])
            else warning("Feature ", ft, " has non-finite coeffs in batch a")
        }
    }
    par(mar = c(0.5, 0, 1, 4.5))
    a <- which(data$batch != data$batch[1])
    y_a <- y[a]
    yfill_a <- yfill[a]
    dta <- data[a, ]
    plot(main = paste0(main, " batch b"), xlab = "", xaxt = "n",
         ylab = expression(log[2]~abundance), ylim = range(yfill, na.rm = TRUE),
         col = paste0(col_source[dta$source], 80), x = dta$inj_idx,
         y = yfill_a, yaxt = "n")
    points(x = dta$inj_idx, y = y_a, col = paste0(col_source[dta$source], 80),
           pch = 16)
    grid()
    if (!missing(lmod)) {
        if (!is.na(lmod)) {
            a <- sum(lmod$coefficients[c(1, 3)])
            b <- sum(lmod$coefficients[c(2, 4)])
            if (is.finite(a) & is.finite(b))
                abline(a, b, col = col_source["all"])
            else warning("Feature ", ft, " has non-finite coeffs in batch b")
        }
    }
}

#' @description
#'
#' Plot model fit for separate model fits in two batches a and b.
#'
#' @param y `numeric` vector with the intensities to plot.
#'
#' @param is_filled `logical` indicating which of the data points are filled-in.
plot_feature_slopes_batch <- function(y, is_filled, data, lmoda,
                                      lmodb, main, legend = TRUE, ...) {
    ##' Two plots, one per batch.
    par(mar = c(0.5, 4.5, 1, 0), mfrow = c(1, 2))
    a <- which(data$batch == data$batch[1])
    y_a <- y[a]
    if (!missing(is_filled))
        pch <- ifelse(is_filled[a], yes = 1, no = 16)
    else
        pch <- 16
    dta <- data[a, ]
    plot(main = paste0(main, " batch a"), xlab = "", xaxt = "n",
         ylab = expression(log[2]~abundance), ylim = range(y, na.rm = TRUE),
         col = paste0(col_source[dta$source], 80), x = dta$inj_idx,
         y = y_a, pch = pch, ...)
    grid()
    if (!missing(lmoda)) {
        if (length(lmoda) > 1) {
            if (is.finite(lmoda$coefficients[1]) &
                is.finite(lmoda$coefficients[2]))
                abline(lmoda$coefficients[1:2], col = col_source["all"])
            else warning("Feature ", ft, " has non-finite coeffs in batch a")
            ##' diff_res <- diff(quantile(residuals(lmoda), probs = c(0.1, 1)))
            diff_res <- mean(abs(residuals(lmoda)))
            if (legend)
                legend("topright",
                       legend = paste0(c("res: ", "R2: "),
                                       c(format(diff_res, digits = 3),
                                         format(summary(lmoda)$adj.r.squared,
                                                digits = 3))))
        }
    }
    par(mar = c(0.5, 0, 1, 4.5))
    a <- which(data$batch != data$batch[1])
    y_a <- y[a]
    if (!missing(is_filled))
        pch <- ifelse(is_filled[a], yes = 1, no = 16)
    else
        pch <- 16
    dta <- data[a, ]
    plot(main = paste0(main, " batch b"), xlab = "", xaxt = "n",
         ylab = expression(log[2]~abundance), ylim = range(y, na.rm = TRUE),
         col = paste0(col_source[dta$source], 80), x = dta$inj_idx,
         y = y_a, yaxt = "n", pch = pch)
    grid()
    if (!missing(lmodb)) {
        if (length(lmodb) > 1) {
            if (is.finite(lmodb$coefficients[1]) &
                is.finite(lmodb$coefficients[2]))
                abline(lmodb$coefficients[1:2], col = col_source["all"])
            else warning("Feature ", ft, " has non-finite coeffs in batch a")
            ##' diff_res <- diff(quantile(residuals(lmodb), probs = c(0.1, 1)))
            diff_res <- mean(abs(residuals(lmodb)))
            if (legend)
                legend("topright",
                       legend = paste0(c("res: ", "R2:"),
                                       c(format(diff_res, digits = 3),
                                         format(summary(lmodb)$adj.r.squared,
                                                digits = 3))))
        }
    }
}

#' @description
#'
#' Apply a function to sets of columns, i.e. to sub-matrices of selected
#' columns defined with parameter `colgroup`.
#'
#' @param x `matrix` with numeric values.
#'
#' @param colgroup `character` or `factor` defining the sets of columns.
#'
#' @param FUN `function` to be applied to the sub-matrix.
#'
#' @param simplify `logical(1)` whether `cbind` should be called on the result.
#'
#' @return `matrix` with aggregated values. Number of columns represent the
#'     number of unique groups/sets defined by `colgroup`. Number of rows is
#'     either one (for `FUN` being e.g. `mean`, `sum` etc) or equal to the
#'     number of rows of `x` (for `FUN` being e.g. `rowSums`).
apply_colgroup <- function(x, colgroup, FUN, simplify = TRUE, ...) {
    if (missing(FUN)) stop("'FUN' is missing")
    if (length(colgroup) != ncol(x))
        stop("length of 'colgroup' should match ncol of 'x'")
    grps <- unique(colgroup)
    res <- lapply(grps, function(z) {
        x_sub <- x[, colgroup == z, drop = FALSE]
        FUN(x_sub, ...)
    })
    names(res) <- grps
    if (simplify)
        do.call(cbind, res)
    else res
}

#' @description
#'
#' Function to calculate row-wise maximum ratio of abundances, i.e. the ratio of
#' the largest difference of replicated measurements.
#'
#' @param x `matrix` with values. These have to be in **natural scale**.
#'
#' @return The *MRA* or `NA` if only a single value is available.
rowMra <- function(x) {
    mra <- function(z) {
        z <- z[!is.na(z)]
        if (length(z) > 1) {
            rng <- range(z)
            rng[2]/rng[1]
        } else {
            NA
        }
    }
    apply(x, MARGIN = 1, mra)
}

plot_pca <- function(pc, pch = 16, col = "#000000", pc_x = 1, pc_y = 2, 
                     main = "", labels = NULL, ...) {
    pcSummary <- summary(pc)
    plot(pc$x[, pc_x], pc$x[, pc_y], pch = NA, main = main,
         xlab = paste0("PC", pc_x, ": ",
                       format(pcSummary$importance[2, pc_x] * 100, 
                              digits = 3), " % variance"),
         ylab = paste0("PC", pc_y, ": ",
                       format(pcSummary$importance[2, pc_y] * 100, 
                              digits = 3), " % variance"))
    grid()
    if (!is.null(labels)) 
        text(pc$x[, pc_x], pc$x[, pc_y], labels = labels, col = col, 
             ...)
    else points(pc$x[, pc_x], pc$x[, pc_y], pch = pch, col = col, 
                ...)
}
rsd <- function(x, na.rm = TRUE) {
    sd(x, na.rm = na.rm) / abs(mean(x, na.rm = na.rm))
}
rowRsd <- function(x, na.rm = TRUE)
    apply(x, MARGIN = 1, rsd, na.rm = na.rm)

#' @description
#'
#' Calculates MRA values (maximum ratio of abundances) between replicated
#' columns (defined with argument `grp` and returns a `matrix` with these.
#' 
#' @param x matrix of normalized abundances.
#'
#' @param nofill matrix, same dimensions than x, that contain only detected
#'     signal. If provided, all values in `x` that are not detected are
#'     replaced with `NA`.
#'
#' @param grp vector defining which samples are replicates.
#'
#' @param drop_samples `character` with names of samples that should be
#'     dropped.
mra_for_mat <- function(x, nofill, grp, drop_samples) {
    if (!missing(nofill))
        x[is.na(nofill)] <- NA
    mras <- apply_colgroup(x, grp, rowMra)
    mras[, !(colnames(mras) %in% drop_samples)]
}

#' @description
#'
#' Calculates column-wise summary statistic on a matrix with MRA values.
mra_summary_quant <- function(x, probs = 0.75, na.rm = TRUE, ...) {
    apply(x, 2, quantile, probs = probs, na.rm = na.rm, ...)
}
mra_summary_count <- function(x, cut = 2, na.rm = TRUE) {
    apply(x, 2, function(z) {
        if (all(is.na(z))) NA
        else sum(z > cut, na.rm = na.rm)
    })
}

```

We restrict the analysis to features with multiple peaks per sample in less than
10% of samples in which a peak was found (excluding QC samples). In addition we
require a feature to be found in 30% of the samples of at least one group
(excluding QC samples). An overview of features used for the analysis is given
in the table below.

```{r feature-summary, message = FALSE, echo = FALSE, results = "asis"}
fsumm <- featureSummary(data_pos, data_pos$source)
study_src <- names(col_source)[names(col_source) != "all"]

##' Determine the proportion of samples with multi peaks in the study group.
##' Have to relate that to the number of samples in which a peak was found,
##' and not to the total number of samples!!!
tmp <- rowSums(fsumm[, paste0(study_src, "_multi_count")]) /
    rowSums(fsumm[, paste0(study_src, "_count")])

##' Further require a feature to be found in more than 30% of samples in at
##' least one group.
tmp_perc <- apply(fsumm[, paste0(study_src, "_perc")], 1,
                  function (z) any(z > 30))
fts_used <- rownames(featureDefinitions(data_pos))[which(tmp < 0.1 & tmp_perc)]


tab <- rbind(total_features = length(fts_used),
             `RBC > 50%` = sum(fsumm[fts_used, "RBC_perc"] > 50),
             `plasma > 50%` = sum(fsumm[fts_used, "plasma_perc"] > 50),
             `capillary > 50%` = sum(fsumm[fts_used, "capillary_perc"] > 50),
             `venous > 50%` = sum(fsumm[fts_used, "venous_perc"] > 50))
colnames(tab) <- "count"
cptn <- paste("Summary of features used for the analysis. All features found",
              "in more than 30% of samples of at least one sample group and",
              "with less than 10% of samples with multiple peaks per sample (",
              "relative to the samples in which a peak was identified).")
pandoc.table(tab, style = "rmarkdown", caption = cptn)

```

Next we fill-in data for samples in which no peak was detected. The signal
integration bases on the m/z and retention time range of the features, which in
fact represents the extent in which the apexes of the individual peaks differ
between samples. While we will eventually exclude filled-in signals in the
estimation of the normalization factors for the within and between-batch
normalization, we will normalize these intensities as they might be affected by
the same effects than the *real* signal. Imputation of signals that are still
missing after filling in will be performed **after** normalization.

Below we fill-in missing peak data by expanding the retention time window of
each feature by a constant value (1 second on each side) and the m/z by 20 ppm.

```{r fill-in, message = FALSE, warning = FALSE, eval = !use_cached}
fcp <- FillChromPeaksParam(ppm = 20, fixedRt = 1)
data_pos <- fillChromPeaks(data_pos, param = fcp)

save(data_pos, file = paste0(RDATA_PATH, "data_pos.RData"))
```

```{r load-again, echo = FALSE, results = "hide"}
load(paste0(RDATA_PATH, "data_pos.RData"))
```

Below we compare the signal distribution of detected and filled-in peak signals.

```{r compare-detected-filled-plot, fig.path = IMAGE_PATH, message = FALSE, echo = FALSE, warning = FALSE, fig.cap = "Distribution of (log2) signal intensities of detected (green) and filled-in peaks (blue). Left: all features/peaks, right: only peaks of features used in the present analysis based on the above definition.", fig.width = 8, fig.height = 4}

##' First all features.
tmp_pks <- chromPeaks(data_pos)
dpks_dens <- density(log2(tmp_pks[tmp_pks[, "is_filled"] == 0, "into"]))
fpks_dens <- density(log2(tmp_pks[tmp_pks[, "is_filled"] == 1, "into"]))
yl <- c(0, max(dpks_dens$y, fpks_dens$y))
xl <- range(dpks_dens$x, fpks_dens$x)

par(mfrow = c(1, 2), mar = c(4, 4.5, 1, 0.5))
plot(4, 4, pch = NA, xlim = xl, ylim = yl, xlab = expression(log[2]~abundance),
     ylab = "Density", main = "All peaks")
points(dpks_dens$x, dpks_dens$y, type = "l", lwd = 2, col = "#00ce0080")
points(fpks_dens$x, fpks_dens$y, type = "l", lwd = 2, col = "#0000ce80")
legend("topright", col = c("#00ce0080", "#0000ce80"), lwd = 2,
       legend = c("detected peaks", "filled-in peaks"))

##' Features being used in the analysis: fts_used
pk_idxs <- sort(unlist(featureDefinitions(data_pos)[fts_used, "peakidx"]))
tmp_pks <- chromPeaks(data_pos)[pk_idxs, ]
dpks_dens <- density(log2(tmp_pks[tmp_pks[, "is_filled"] == 0, "into"]))
fpks_dens <- density(log2(tmp_pks[tmp_pks[, "is_filled"] == 1, "into"]))
yl <- c(0, max(dpks_dens$y, fpks_dens$y))
xl <- range(dpks_dens$x, fpks_dens$x)

plot(4, 4, pch = NA, xlim = xl, ylim = yl, xlab = expression(log[2]~abundance),
     ylab = "Density", main = "Peaks of selected features")
points(dpks_dens$x, dpks_dens$y, type = "l", lwd = 2, col = "#00ce0080")
points(fpks_dens$x, fpks_dens$y, type = "l", lwd = 2, col = "#0000ce80")
legend("topright", col = c("#00ce0080", "#0000ce80"), lwd = 2,
       legend = c("detected peaks", "filled-in peaks"))

```

As expected, abundances from filled-in peaks have on average lower intensities
than truly detected peaks. Abundances are however relatively similar suggesting
that for many missing peaks a signal from an ion was recorded, but peak
detection failed.

Next we extract the matrix of feature abundances with the integrated peak area
(column `"into"`) used as estimate. For multi-peak features, the integrated peak
area of all peaks of a sample assigned to a feature are summed to create the
final abundance estimate. We might however change this in future updates with
alternative approaches being `method = "maxint"` and `intensity = "maxo"`
(select the aggregated intensity of the peak with the highest intensity at the
apex) or `method = "maxint"` and `intensity = "into"` (select the largest
integrated intensity). For comparison reasons we also extract the feature data
without any filled-in information.

```{r extract-featureValues, message = FALSE}
##' Use method = "sum"... for now.
fv <- featureValues(data_pos, method = "sum", value = "into")[fts_used, ]
fv_nofill <- featureValues(data_pos, method = "max",
                           value = "into", filled = FALSE)[fts_used, ]

```

Next we calculate and compare for each feature in QC samples the difference
between the detected and filled-in peak data. Evaluation in QC samples avoids
any potential differences being caused by biological differences of the compared
samples.

```{r per-feature-difference-filled-detected, message = FALSE, fig.cap = "Difference (log2 scale) of detected against filled-in signal.", fig.path = IMAGE_PATH, fig.height = 5, fig.width = 5, echo = FALSE}
##' Get only the filled-in signals.
fv_onlyfill <- fv
fv_onlyfill[!is.na(fv_nofill)] <- NA

is_QC <- data_pos$sample == "POOL"
M_QC <- numeric(nrow(fv_onlyfill))
names(M_QC) <- rownames(fv_onlyfill)
for (i in seq_along(M_QC))
    M_QC[i] <- log2(mean(fv_nofill[i, is_QC], na.rm = TRUE)) -
        log2(mean(fv_onlyfill[i, is_QC], na.rm = TRUE))
boxplot(M_QC, ylab = expression(log[2](detected/filled)))
grid(nx = NA, ny = NULL)

```

On average, detected peak signals are twice as high as filled-in peak
signals. For 75% of the features detected peak signals are less than 4-fold
higher than filled in signals. This suggests that filled-in data does to some
extend represent signal from the ion, but mostly underestimates the *real*
signal.

Below we plot the number of non-missing values and the distribution of feature
intensities first for the data without and then with filled-in data.

```{r raw-nofill-boxplot, fig.path = IMAGE_PATH, message = FALSE, warning = FALSE, echo = FALSE, fig.cap = "Counts of non-missing values and feature abundance distribution.", fig.width = 10, fig.height = 5}
layout(mat = matrix(1:2, ncol = 1), height = c(0.2, 0.8))
par(mar = c(0.2, 4.5, 0.2, 0.5))
barplot(apply(fv_nofill, MARGIN = 2, function(x) sum(!is.na(x))),
        col = paste0(col_source[data_pos$source], 80), ylab = "features",
        xaxt = "n")
boxplot(log2(fv_nofill), ylab = expression(log[2]~feature~abundance),
        col = paste0(col_source[data_pos$source]), cex = 0.5, pch = 16,
        border = paste0(col_source[data_pos$source], 40), xaxt = "n")
grid(nx = NA, ny = NULL)
```

Plasma samples (blue) have less valid values for features compared to samples
from other sources. Some of the RBC (red) samples also have a considerably lower
number of detected features. The distribution of feature intensities seems to
be comparable between samples, sources and batches. The high similarity of
average abundances between samples visible above might however be misleading,
since only signal from identified peaks are considered. Comparing signal
intensities **after** filling-in missing peak data might be better, because it
also reflects the fact that some features are simply not present in the data.

```{r raw-boxplot, fig.path = IMAGE_PATH, message = FALSE, warning = FALSE, echo = FALSE, fig.cap = "Counts of non-missing values and feature abundance distribution for the filled-in data.", fig.width = 10, fig.height = 5}

layout(mat = matrix(1:2, ncol = 1), height = c(0.2, 0.8))
par(mar = c(0.2, 4.5, 0.2, 0.5))
barplot(apply(fv, MARGIN = 2, function(x) sum(!is.na(x))),
        col = paste0(col_source[data_pos$source], 80), ylab = "features",
        xaxt = "n")
boxplot(log2(fv), ylab = expression(log[2]~feature~abundance),
        col = paste0(col_source[data_pos$source]), cex = 0.5, pch = 16,
        border = paste0(col_source[data_pos$source], 40), xaxt = "n")
grid(nx = NA, ny = NULL)
```

After filling in missing peak values the proportion of detected features is
highly comparable between samples, but more differences between abundances are
visible. Plasma samples (blue) show however considerably lower signal
intensities than all other samples, which reflects that less peaks were detected
for these features in these samples (and intensities were thus filled-in).

Next we create relative log abundance plots that represent the difference of the
(log) abundances of each feature in a sample compared to the median abundance of
that feature in samples from the same sample group (source).

```{r raw-nofill-rla-plot, fig.path = IMAGE_PATH, message = FALSE, warning = FALSE, echo = FALSE, fig.cap = "RLA plot for the raw data. Note: outliers are not drawn.", fig.width = 10, fig.height = 5}
boxplot(rowRla(fv_nofill, group = data_pos$source), cex = 0.5, pch = 16, 
        col = col_source[data_pos$source], ylab = "RLA",
        border = paste0(col_source[data_pos$source], 40), notch = TRUE,
        outline = FALSE, xaxt = "n", main = "raw data")
grid(nx = NA, ny = NULL)
abline(v = sum(data_pos$batch == 31012018) + 0.5, col = "grey")
```

The RLA plot above shows some potentially systematic drifts in signal
intensities that includes also consistently lower average RLA values in the
last samples from the first, and consistently higher average RLA values in the
last samples from the second batch. Next we plot the RLA plots after filling-in
missing peak data. 

```{r raw-rla-plot, fig.path = IMAGE_PATH, message = FALSE, warning = FALSE, echo = FALSE, fig.cap = "RLA plot for the raw data after filling-in missing peak data. Note: outliers are not drawn.", fig.width = 10, fig.height = 5}
boxplot(rowRla(fv, group = data_pos$source), cex = 0.5, pch = 16, 
        col = col_source[data_pos$source], ylab = "RLA",
        border = paste0(col_source[data_pos$source], 40), notch = TRUE,
        outline = FALSE, xaxt = "n", main = "raw data, filled-in")
grid(nx = NA, ny = NULL)
abline(v = sum(data_pos$batch == 31012018) + 0.5, col = "grey")
text(y = -2, x = 1:length(data_pos$sample), labels = data_pos$sample, cex = 0.5,
     srt = -90)
```

The RLA plots after filling-in missing peak data look similar but the trends
become more pronounced.

At last we plot the average abundances per sample separately for the 4 sources
to see whether the drift is independent of the sample source.

```{r rla-split-source-plot, message = FALSE, echo = FALSE, fig.cap = "Plot of per-source average (mean) RLA values per sample.", fig.path = IMAGE_PATH, fig.width = 10, fig.height = 6}
crlas <- colMeans(rowRla(fv, group = data_pos$source), na.rm = TRUE)
injidx <- data_pos$inj_idx
injidx[data_pos$batch == 1022018] <- injidx[data_pos$batch == 1022018] + 100

par(mfrow = c(5, 1), mar = c(0.2, 4.5, 0.7, 0.5))
X <- injidx[data_pos$source == "all"]
Y <- crlas[data_pos$source == "all"]
plot(X, xlim = range(injidx), Y, col = col_source["all"], pch = 16,
     ylab = "RLA", xaxt = "n", type = "b", main = "Pool")
grid()
abline(v = 100.5, col = "grey")
X <- injidx[data_pos$source == "RBC"]
Y <- crlas[data_pos$source == "RBC"]
plot(X, xlim = range(injidx), Y, col = col_source["RBC"], pch = 16,
     ylab = "RLA", xaxt = "n", type = "b", main = "RBC")
grid()
abline(v = 100.5, col = "grey")
X <- injidx[data_pos$source == "plasma"]
Y <- crlas[data_pos$source == "plasma"]
plot(X, xlim = range(injidx), Y, col = col_source["plasma"], pch = 16,
     ylab = "RLA", xaxt = "n", type = "b", main = "plasma")
grid()
abline(v = 100.5, col = "grey")
X <- injidx[data_pos$source == "capillary"]
Y <- crlas[data_pos$source == "capillary"]
plot(X, xlim = range(injidx), Y, col = col_source["capillary"], pch = 16,
     ylab = "RLA", xaxt = "n", type = "b", main = "capillary")
grid()
abline(v = 100.5, col = "grey")
X <- injidx[data_pos$source == "venous"]
Y <- crlas[data_pos$source == "venous"]
plot(X, xlim = range(injidx), Y, col = col_source["venous"], pch = 16,
     ylab = "RLA", xaxt = "n", type = "b", main = "venous")
grid()
abline(v = 100.5, col = "grey")

```

The trend seen on QC pools seems, to some extend, also be present in venous
blood samples and plasma blood samples. RBC and capillary samples show a higher
variability. Over and above it seems also that the samples from the second batch
have slightly higher abundances.


## Internal standards

Internal standards have been added to the sample mix before sample
processing. Below we load the table with the internal standards and their
expected mass to charge ration m/z. Features detected at these m/z are then
identified.

```{r internal-standards-read, message = FALSE, warning = FALSE}
int_std <- read.table("data/txt/_input_Internal_Standards.txt", sep = "\t",
                      as.is = TRUE, header = TRUE, check.names = FALSE)
#' int_std$mz <- int_std[, "[M+H]+"]
mass_h <- 1.007276455
mass_na <- 22.989218
int_std$mz <- int_std$molecular_weight + mass_h
int_std$mz[grep("^Glucose", int_std$name)] <-
    int_std$molecular_weight[grep("^Glucose", int_std$name)] + mass_na
int_std <- int_std[!is.na(int_std$mz), ]

#' Identify features at the expected m/z
fts_int_std <- lapply(int_std$mz, function(mz) {
    featureDefinitions(data_pos, mz = mz, ppm = 10, type = "apex_within")
})

```

```{r internal-standards-plot, echo = FALSE, message = FALSE, warning = FALSE}
#' Plot the features for the internal standards.
col <- paste0(col_source[data_pos$source], 80)
#' col <- c("#ce000080", "#0000ce80")[as.integer(data_pos$batch)]

dr <- paste0(IMAGE_PATH, "internal-standards/")
dir.create(dr, showWarnings = FALSE)
for (i in 1:length(fts_int_std)) {
    if (nrow(fts_int_std[[i]]) == 0)
        next
    fn <- gsub("%", "", paste0(dr, "int_std_", i, "_",
                               int_std[i, "name"], ".png"))
    fts <- fts_int_std[[i]]
    pks <- chromPeaks(data_pos)[unlist(fts$peakidx), ]
    mzr <- range(pks[, c("mzmin", "mzmax")])
    rtr <- range(pks[, c("rtmin", "rtmax")])
    rtr[1] <- rtr[1] - 5
    rtr[2] <- rtr[2] + 5
    chrs <- chromatogram(data_pos, mz = mzr, rt = rtr, aggregationFun = "max")
    png(fn, width = 10, height = 5, units = "cm", res = 200, pointsize = 4)
    plot(chrs, col = col)
    highlightChromPeaks(data_pos, mz = mzr, rt = rtr,
                        border = sub("80$", 20, col),
                        whichPeaks = "apex_within")
    abline(v = fts$rtmed)
    dev.off()
}

##' Plot peaks of a certain feature.
##' pks <- chromPeaks(data_pos)[fts$peakidx[[1]], ]
##' rect(xleft = pks[, "rtmin"], xright = pks[, "rtmax"], ybottom = 0,
##'      ytop = pks[, "maxo"], border = "#ff000080")
##' pks <- chromPeaks(data_pos)[fts$peakidx[[2]], ]
##' rect(xleft = pks[, "rtmin"], xright = pks[, "rtmax"], ybottom = 0,
##'      ytop = pks[, "maxo"], border = "#0000ff80")

##' Manually select features/internal standards.
int_std$feature <- rep(NA_character_, nrow(int_std))
int_std[3, "feature"] <- rownames(fts_int_std[[3]])
int_std[5, "feature"] <- rownames(fts_int_std[[5]])
int_std[6, "feature"] <- rownames(fts_int_std[[6]])[2] #' the one at 192sec
int_std[7, "feature"] <- rownames(fts_int_std[[7]])
int_std[8, "feature"] <- rownames(fts_int_std[[8]]) #' only in plasma???
int_std[9, "feature"] <- rownames(fts_int_std[[9]])
int_std[10, "feature"] <- rownames(fts_int_std[[10]])
int_std[11, "feature"] <- rownames(fts_int_std[[11]])[1] #' the one at rt 193
##' 12 and 13 L-IsoLeucine and L-Leucine each have 3 peaks - don't know which
##' one might be the best/correct one.
int_std[14, "feature"] <- rownames(fts_int_std[[14]])
##' 15 L-Methionine, 16 L-Phenylalanine and 17 L-Proline each have two peaks,
##' seems that in some samples two and in some a single peak is present.
##' Thus we're not using them.
int_std[18, "feature"] <- rownames(fts_int_std[[18]])
int_std[19, "feature"] <- rownames(fts_int_std[[19]])
##' int_std[20, "feature"] <- rownames(fts_int_std[[20]]) #' check: large diffs
##' 21 L-Valine has several peaks over a large rt window. Unclear which signal
##' belongs to valine.

fts_int_std <- int_std$feature
names(fts_int_std) <- int_std$name
fts_int_std <- fts_int_std[!is.na(fts_int_std)]
fts_int_std <- fts_int_std[!(fts_int_std %in% c("FT01143", "FT00827"))]
```

All features possibly related to internal standards have been manually evaluated
and only features have been assigned to internal standards if the signal was
unambiguous. For L-Leucine and L-Isoleucine several chromatographic peaks (3)
were present at the expected m/z and it was unclear which one was the *right*
one for the standard. Similarly, the extracted chromatogram for the m/z of
L-Methionine, L-Phenylalanine and L-Proline each featured two chromatographic
peaks close in retention time. Also for L-Valine several peaks were present over
a larger retention time window and thus no feature was assigned because it was
unclear which of the signal/peaks belong to Valine. Similarly, no feature was
assigned to L-Tyrosine. The table below lists the internal standards and their
assigned feature with mean abundance and its standard deviation.

Note that the internal standard *L-Cystine (13C6, 99%; 15N2, 99%)* was manually
removed as it showed consistently much larger signal in plasma samples compared
to all other samples. Also *Glucose (6,6-D2)* was removed as it had higher
concentrations in capillary compared to other samples while it was mostly absent
in plasma samples.

```{r internal-standard-table, echo = FALSE, results = "asis", message = FALSE, warning = FALSE}
#' table of internal standards with mean and sd of abundances (in log2 scale)
tmp_fv <- fv_nofill[int_std$feature[!is.na(int_std$feature)], ]
idx <- match(rownames(tmp_fv), int_std$feature)
int_std$mean_abd <- rep(NA_real_, nrow(int_std))
int_std$mean_abd[idx] <- rowMeans(log2(tmp_fv), na.rm = TRUE)
int_std$sd_abd <- rep(NA_real_, nrow(int_std))
int_std$sd_abd[idx] <- rowSds(log2(tmp_fv), na.rm = TRUE)
int_std$RSD <- rep(NA_real_, nrow(int_std))
int_std$RSD[idx] <- rowRsd(tmp_fv, na.rm = TRUE)
int_std$diff_weight <- int_std[, 3] - int_std[, 2]

cpt <- paste("Internal standards with detected and assigned features, mean and",
             "standard deviation of (log2) abundance and RSD.")
pandoc.table(int_std[int_std$feature %in% fts_int_std,
                     c("name", "mean_abd", "sd_abd", "RSD")],
             style = "rmarkdown", caption = cpt)
```

At last we evaluate the separation of samples bases on the raw metabolite
profiles and on the raw abundances of internal standards.

```{r internal-standard-pca, echo = FALSE, fig.width = 10, fig.height = 10, fig.cap = "PCA grouping samples based on raw abundances. Upper row: all features, lower row: internal standards."}

fts_sub <- fts_int_std

col_2 <- col
## col_2 <- c("#ff000080", "#0000ff80")[as.numeric(data_pos$batch)]

fv_imp <- imputeRowMinRand(fv)
pc_all <- prcomp(t(log2(fv_imp)), scale = FALSE, center = TRUE)
pc_int <- prcomp(t(log2(fv_imp[fts_sub, ])), scale = FALSE, center = TRUE)

par(mfrow = c(2, 2), mar = c(4.5, 4.5, 1, 1))
plot_pca(pc_all, pc_x = 1, pc_y = 2, col = col_2)
legend("topright", col = col_source, legend = names(col_source), pch = 16)
plot_pca(pc_all, pc_x = 3, pc_y = 4, col = col_2)
plot_pca(pc_int, pc_x = 1, pc_y = 2, col = col_2)
plot_pca(pc_int, pc_x = 3, pc_y = 4, col = col_2)

```

For all samples a clear grouping by source is visible. Also some source-related
separation is visible for the internal standards, for which this is rather
unexpected and could indicate that some internal standards might be problematic.


# Between-sample normalization

Per-sample normalization aims to remove global abundance differences between
samples due to variations in sample collection, extraction, processing and
possibly amount. The simplest approach is to normalize abundances based on
either the total signal sum or the median abundance. They rely however on the
self-averaging property assuming that an increase in abundances of a group of
metabolites is balanced by a decrease in abundances in another group
[@Livera:2015bo]. Also, these approaches tend to be biased by highly abundant
metabolites. Methods robust against such a bias, like the median ratio method
(MRM [@Anders:2010fu]) or the trimmed mean of M-values (TMM [@Robinson:2010dd])
used in RNAseq data normalization might be used instead. Alternatively, we will
evaluate also the performance of RUV [@Livera:2015bo] which requires however
internal standards (or metabolites correlating with their abundance) to estimate
the technical variance in the data and the NOMIS method [@SysiAho:2007bt] that
normalizes features by *their best internal standard*.

Note that, since the internal standards were added before sample preparation,
but after sample collection and extraction, they can only assess
sample-preparation-related effects.

Below we calculate normalization factors based on the total sum of the signal,
the median abundance per sample and using the MRM and TMM methods. The
calculations are based on abundances of detected peaks. Subsequently we
normalize the feature abundance (also of filled-in signal) based on the
estimated sample-wise normalization factors.

**TODO**: consider performing the normalization on filled-in and imputed data:
- using only the detected signal ignores that e.g. many peaks are simply not
  detected in that sample, i.e. the overall sample might have been added in a
  too low concentration and hence many features might be below detection limit.


```{r, eval = FALSE, echo = FALSE}
#' compare: median abundance
#' - only detected signal
#' - filled in signal
#' - filled in and imputed
conc_median_nofill <- apply(fv_nofill, MARGIN = 2, median, na.rm = TRUE)
conc_median <- apply(fv, MARGIN = 2, median, na.rm = TRUE)
conc_median_imp <- apply(fv_imp, MARGIN = 2, median, na.rm = TRUE)

nf_median_nofill <- conc_median_nofill / median(conc_median_nofill)
nf_median <- conc_median / median(conc_median)
nf_median_imp <- conc_median_imp / mean(conc_median_imp)

par(mfrow = c(1, 3))
plot(nf_median_nofill, nf_median)
abline(0, 1)
plot(nf_median_nofill, nf_median_imp)
abline(0, 1)
plot(nf_median, nf_median_imp)
abline(0, 1)

#' Conclusion:
#' - difference between detected and filled-in or imputed is considerable.
#' - almost no difference between imputed and filled-in.
```

```{r estimate-norm-factors, message = FALSE, warning = FALSE}
fv_imp <- imputeRowMinRand(fv)

#' sum of signal.
sms <- colSums(fv_nofill, na.rm = TRUE)
nf_sm <- sms / mean(sms)

#' median signal
mdns <- apply(fv_nofill, MARGIN = 2, median, na.rm = TRUE)
nf_mdn <- mdns / median(mdns)

#' MRM
nf_mrm <- estimateSizeFactorsForMatrix(fv_nofill)

#' TMM
tmp <- fv_nofill
tmp[is.na(tmp)] <- 0
nf_tmm <- calcNormFactors(tmp, method = "TMM")
rm(tmp)

#' Normalize
fv_sm <- sweep(fv, MARGIN = 2, nf_sm, `/`)
fv_mdn <- sweep(fv, MARGIN = 2, nf_mdn, `/`)
fv_mrm <- sweep(fv, MARGIN = 2, nf_mrm, `/`)
fv_tmm <- sweep(fv, MARGIN = 2, nf_tmm, `*`)

```

In addition we perform the normalization using approaches that base on internal
standards. Below we apply the NOMIS method [@SysiAho:2007bt]. Note that we have
to apply this method on the filled-in and imputed data set as it does not allow
missing values.

```{r nomis, warning = FALSE, message = FALSE}
#' Use the NormalizeMets package
library(NormalizeMets)
fv_nms <- 2^t(NormQcmets(
                t(log2(fv_imp)), method = "nomis",
                qcmets = which(rownames(fv) %in% fts_int_std))$featuredata)
#' re-add the internal standards!
fv_nms <- rbind(fv_nms, fv_imp[!(rownames(fv_imp) %in% rownames(fv_nms)), ])
fv_nms <- fv_nms[rownames(fv_imp), ]

```

Another approach that has been proposed for metabolomics data normalization
is RUV (removal of unwanted variances) [@Livera:2015bo]. RUV aims to remove
variance using the signal from /negative control features/, i.e. features that
are known to not change between conditions. This approach hence requires prior
knowledge of metabolites that are known to not change between samples, but does
not require QC samples.

The definition of the negative control metabolites is crucial to the RUV method.
One possibility proposed by De Livera et al [@Livera:2015bo] was to select all
metabolites featuring a high correlation with internal standard
compounds. Specifically, they used all metabolites with a correlation
coefficient > 0.6 to the average of internal control compounds.

```{r ruv-norm-define-ctrls, message = FALSE, warning = FALSE}
fts_int_std_mean <- colMeans(fv[fts_int_std, ], na.rm = TRUE)

cor_int_std <- apply(log2(fv), MARGIN = 1, cor, y = log2(fts_int_std_mean))

neg_ctrls <- which(cor_int_std > 0.6)
neg_ctrls_int <- which(rownames(fv) %in% fts_int_std)

```

RUV is available in a variety of flavors. We use the *RUV-rand* method described
in [@Livera:2015bo] as well as *RUVIII* that uses also replicate
information. Note that other variants, such as RUV-2 include the factors of
interest into the linear model and should hence **not** be used prior to PCA or
other unsupervised clustering approaches [@Livera:2015bo]. Note also that RUV
does not accept missing values. We are thus performing the normalization on the
imputed data set.

```{r ruvs, message = FALSE, results = "hide"}
library(MetNorm)

ruv_rand <- NormalizeRUVRand(t(log2(fv_imp)), ctl = neg_ctrls_int, k = 6,
                             plotk = FALSE)
fv_ruvr <- 2^t(ruv_rand$newY)

library(ruv)
ruv_3 <- RUVIII(t(log2(fv_imp)), ctl = neg_ctrls_int, k = 6,
                M = design.matrix(data_pos$sample))
fv_ruv3 <- 2^t(ruv_3)

```

## Evaluation of normalization performance

Next we compare the results of the different normalization approaches and try to
identify the best performing method. Since all measurements of QC samples are
from the same sample processing, we can not use them for evaluation. Also,
internal standards have been added after the initial sample processing to each
sample and hence differences between them are not related to individual sample
processing.  Two measurements are however available for each study sample that,
while originating from the same tube, were processed separately. These
replicates are thus ideal to evaluate the performance of the between-sample
normalization as that aims to remove sample processing related variances.

We thus calculate below the MRA (maximum ratio of abundances) between replicated
samples (using only the detected signal). From these we calculate the 75%
quantile of the absolute MRM per sample as a proxy for between replicate
difference. Seventy five percent of the features per sample have an absolute
difference between replicated measurement that is smaller than this value.

```{r per-sample-mra-calculation, message = FALSE, warning = FALSE}

grp <- paste(data_pos$source, data_pos$sample, sep = "-")

mra_raw <- mra_for_mat(fv_nofill, grp = grp, drop_samples = "all-POOL")
mra_sm <- mra_for_mat(fv_sm, fv_nofill, grp, "all-POOL")
mra_mdn <- mra_for_mat(fv_mdn, fv_nofill, grp, "all-POOL")
mra_mrm <- mra_for_mat(fv_mrm, fv_nofill, grp, "all-POOL")
mra_tmm <- mra_for_mat(fv_tmm, fv_nofill, grp, "all-POOL")
mra_ruvr <- mra_for_mat(fv_ruvr, fv_nofill, grp, "all-POOL")
mra_ruv3 <- mra_for_mat(fv_ruv3, fv_nofill, grp, "all-POOL")
mra_nms <- mra_for_mat(fv_nms, fv_nofill, grp, "all-POOL")

```

The distribution of these 75% MRAs per method (across samples) as well as the
count of samples with a more than two-fold difference in abundances is shown in
the boxplots below.

```{r per-sample-mra-75-boxplot, message = FALSE, echo = FALSE, fig.path = IMAGE_PATH, fig.cap = "Impact of normalization on differences between replicates. Distribution of per-sample 75% quantile MRA for the raw and between-sample normalized data (left) and number of features (per replicate pair) with a more than two-fold difference in abundances. Only detected peak signal is considered.", fig.width = 8, fig.height = 5}

#' Calculate summary statistics
mra_raw_q <- mra_summary_quant(mra_raw)
mra_raw_c <- mra_summary_count(mra_raw)
mra_sm_q <- mra_summary_quant(mra_sm)
mra_sm_c <- mra_summary_count(mra_sm)
mra_mdn_q <- mra_summary_quant(mra_mdn)
mra_mdn_c <- mra_summary_count(mra_mdn)
mra_mrm_q <- mra_summary_quant(mra_mrm)
mra_mrm_c <- mra_summary_count(mra_mrm)
mra_tmm_q <- mra_summary_quant(mra_tmm)
mra_tmm_c <- mra_summary_count(mra_tmm)
mra_ruvr_q <- mra_summary_quant(mra_ruvr)
mra_ruvr_c <- mra_summary_count(mra_ruvr)
mra_ruv3_q <- mra_summary_quant(mra_ruv3)
mra_ruv3_c <- mra_summary_count(mra_ruv3)
mra_nms_q <- mra_summary_quant(mra_nms)
mra_nms_c <- mra_summary_count(mra_nms)

#' Note: median and 80% quantile did not show any improvement.
mra_df <- data.frame(raw = mra_raw_q,
                     sum = mra_sm_q,
                     median = mra_mdn_q,
                     MRM = mra_mrm_q,
                     TMM = mra_tmm_q,
                     `RUV rand` = mra_ruvr_q,
                     RUVIII = mra_ruv3_q,
                     NOMIS = mra_nms_q
                     )

par(mar = c(6, 4.5, 1, 0.5), mfrow = c(1, 2))
boxplot(mra_df, las = 2, ylab = "75% quantile MRA", ylim = c(1, 3))
grid(nx = NA, ny = NULL)

mra_c_df <- data.frame(raw = mra_raw_c,
                       sum = mra_sm_c,
                       median = mra_mdn_c,
                       MRM = mra_mrm_c,
                       TMM = mra_tmm_c,
                       `RUV rand` = mra_ruvr_c,
                       RUVIII = mra_ruv3_c,
                       NOMIS = mra_nms_c)
boxplot(mra_c_df, las = 2, ylab = "count M > 1")
grid(nx = NA, ny = NULL)

```

A summary of the boxplots above is provided in the table below.

```{r per-sample-mra-75-table, echo = FALSE, results = "asis"}
#' normalization better for some sources?
#' vns <- mra_df[grep("venous", rownames(mra_df)), ]
#' rbc <- mra_df[grep("RBC", rownames(mra_df)), ]
#' cap <- mra_df[grep("capillary", rownames(mra_df)), ]
#' pls <- mra_df[grep("plasma", rownames(mra_df)), ]
#' Conclusion: no.

T <- apply(mra_df, 2, quantile, na.rm = TRUE)
T <- rbind(T,
           `count M > 1` = c(mean(mra_raw_c, na.rm = TRUE),
                             mean(mra_sm_c, na.rm = TRUE),
                             mean(mra_mdn_c, na.rm = TRUE),
                             mean(mra_mrm_c, na.rm = TRUE),
                             mean(mra_tmm_c, na.rm = TRUE),
                             mean(mra_ruvr_c, na.rm = TRUE),
                             mean(mra_ruv3_c, na.rm = TRUE),
                             mean(mra_nms_c, na.rm = TRUE)))
cpt <- paste0("Distribution of per-replicate 75% MRA quantile for the raw ",
              "and between-sample normalized data and average count of ",
              "features with a more than 2-fold difference in abundance.")
pandoc.table(T, style = "rmarkdown", caption = cpt)
```

The improvement of the between-sample normalization is only marginal with the
best performing methods, in terms of reducing the average 75% quantile MRA and
the average number of replicates with a more than two-fold difference in
abundance, being the median scaling and the MRM. Methods using the internal
standards for normalization (RUV and NOMIS) result in larger differences between
replicates.

```{r lm_replicates, eval = FALSE, echo = FALSE}
lm_for_mat <- function(x, nofill, grp) {
    lm_fun <- function(z) {
        if (ncol(z) == 2) {
            X <- z[, 1]
            Y <- z[, 2]
            summary(lm(Y ~ X))
        } else NA
    }
    if (!missing(nofill))
        x[is.na(nofill)] <- NA
    lms <- apply_colgroup(x, grp, lm_fun, simplify = FALSE)
    lms[!is.na(lms)]
}

lm_raw <- lm_for_mat(fv, fv_nofill, grp)
lm_sm <- lm_for_mat(fv_sm, fv_nofill, grp)
lm_mdn <- lm_for_mat(fv_mdn, fv_nofill, grp)
lm_mrm <- lm_for_mat(fv_mrm, fv_nofill, grp)
lm_tmm <- lm_for_mat(fv_tmm, fv_nofill, grp)
lm_ruvr <- lm_for_mat(fv_ruvr, fv_nofill, grp)
lm_ruv3 <- lm_for_mat(fv_ruv3, fv_nofill, grp)
lm_nms <- lm_for_mat(fv_nms, fv_nofill, grp)

lm_slope_df <- data.frame(
    raw = vapply(lm_raw, function(z) z$coefficients[2], numeric(1)),
    sum = vapply(lm_sm, function(z) z$coefficients[2], numeric(1)),
    median = vapply(lm_mdn, function(z) z$coefficients[2], numeric(1)),
    MRM = vapply(lm_mrm, function(z) z$coefficients[2], numeric(1)),
    TMM = vapply(lm_tmm, function(z) z$coefficients[2], numeric(1)),
    `RUV rand` = vapply(lm_ruvr, function(z) z$coefficients[2], numeric(1)),
    RUVIII = vapply(lm_ruv3, function(z) z$coefficients[2], numeric(1)),
    NOMIS = vapply(lm_nms, function(z) z$coefficients[2], numeric(1))
)

par(mar = c(6, 4.5, 1, 0.5))
boxplot(lm_slope_df, las = 2, ylab = "slope", ylim = c(0, 2))
grid(nx = NA, ny = NULL)

lm_r2_df <- data.frame(
    raw = vapply(lm_raw, function(z) z$r.squared, numeric(1)),
    sum = vapply(lm_sm, function(z) z$r.squared, numeric(1)),
    median = vapply(lm_mdn, function(z) z$r.squared, numeric(1)),
    MRM = vapply(lm_mrm, function(z) z$r.squared, numeric(1)),
    TMM = vapply(lm_tmm, function(z) z$r.squared, numeric(1)),
    `RUV rand` = vapply(lm_ruvr, function(z) z$r.squared, numeric(1)),
    RUVIII = vapply(lm_ruv3, function(z) z$r.squared, numeric(1)),
    NOMIS = vapply(lm_nms, function(z) z$r.squared, numeric(1))
)

par(mar = c(6, 4.5, 1, 0.5))
boxplot(lm_r2_df, las = 2, ylab = "R squared", ylim = c(0.5, 1))
grid(nx = NA, ny = NULL)

```

The impact of the per-sample normalization approaches on the abundances is shown
below.


```{r per-sample-norm-boxplot, message = FALSE, warning = FALSE, echo = FALSE, fig.path = IMAGE_PATH, fig.cap = "Distribution of abundances before and after per-sample normalization. Detected and filled-in signals are plotted.", fig.width = 8, fig.height = 16}

dobox <- function(x, col = paste0(col_source[data_pos$source], "ff"),
                  outline = FALSE, notch = TRUE, range = 0,
                  border = paste0(col_source[data_pos$source], "60"),
                  ylab = expression(log[2]~abundance), xaxt = "n", xlab = "",
                  ...) {
    boxplot(x, col = col, outline = outline, notch = notch, range = range,
            border = border, ylab = ylab, xaxt = xaxt, xlab = xlab, ...)
    grid(nx = NA, ny = NULL)
}

par(mfrow = c(8, 1), mar = c(0.5, 4.5, 1, 0.1))
dobox(log2(fv), main = "raw data", ylim = c(5, 20))
points(colMeans(log2(fv), na.rm = TRUE), type = "l")
dobox(log2(fv_sm), main = "sum normalized", ylim = c(5, 20))
points(colMeans(log2(fv_sm), na.rm = TRUE), type = "l")
dobox(log2(fv_mdn), main = "median normalized", ylim = c(5, 20))
points(colMeans(log2(fv_mdn), na.rm = TRUE), type = "l")
dobox(log2(fv_mrm), main = "MRM normalized", ylim = c(5, 20))
points(colMeans(log2(fv_mrm), na.rm = TRUE), type = "l")
dobox(log2(fv_tmm), main = "TMM normalized", ylim = c(5, 20))
points(colMeans(log2(fv_tmm), na.rm = TRUE), type = "l")
dobox(log2(fv_ruvr), main = "RUV rand normalized")
points(colMeans(log2(fv_ruvr), na.rm = TRUE), type = "l")
dobox(log2(fv_ruv3), main = "RUVIII normalized")
points(colMeans(log2(fv_ruv3), na.rm = TRUE), type = "l")
dobox(log2(fv_nms), main = "NOMIS normalized")
points(colMeans(log2(fv_nms), na.rm = TRUE), type = "l")

```

No big improvements/changes can be observed between the raw and normalized
abundance distributions. Note however that the methods using internal standards
for the normalization drastically changed the abundance levels while the scale
for the methods using global, per sample, abundance levels remained the same.



# Within-batch normalization

Next we perform a within-batch normalization to remove potential injection order
dependent signal drifts. In order to define whether there is a similar injection
order dependent signal drift in each batch (i.e. the drift is independent of the
batch) we fit feature-wise linear models to the (log2 transformed) data of QC
samples within each batch and compare the slopes for each feature between the
batches. 

Note that the models describing the batch effect and injection dependent signal
drift is estimated on the detected peak data, i.e. prior to filling-in missing
peak data.

```{r estimate-slopes-per-batch, message = FALSE, warning = FALSE, fig.path = IMAGE_PATH, fig.cap = "Plot of per-feataure estimates for the injection order dependent signal drift from the two batches.", fig.width = 6, fig.height = 6, echo = FALSE}
smps <- data_pos$batch == 31012018 & data_pos$source == "all"
lm_btch1 <- xcms:::rowFitModel(
                       y ~ inj_idx, y = log2(fv_nofill[, smps]),
                       method = "lmrob",
                       data = data.frame(inj_idx = data_pos$inj_idx[smps]))
smps <- data_pos$batch == 1022018 & data_pos$source == "all"
lm_btch2 <- xcms:::rowFitModel(
                       y ~ inj_idx, y = log2(fv_nofill[, smps]),
                       method = "lmrob",
                       data = data.frame(inj_idx = data_pos$inj_idx[smps]))

slps_btch1 <- unlist(lapply(lm_btch1, function(z)
    ifelse(any(!is.na(z)), z$coefficients[2], NA)))
slps_btch2 <- unlist(lapply(lm_btch2, function(z)
    ifelse(any(!is.na(z)), z$coefficients[2], NA)))

plot(slps_btch1, slps_btch2, pch = 16, col = "#00000040", xlab = "batch 1",
     ylab = "batch 2", main = "slopes")
grid()
lmod <- lm(slps_btch2 ~ slps_btch1)
abline(lmod, lty = 2)

```

Not unexpectedly, there is only a very low correlation of the slopes between the
batches suggesting that the injection dependent signal drift is for the most
part batch dependent. If the model is fitted to all values, a higher correlation
can however be observed (data not shown).

<!-- TODO CHANGE THIS -->

<!-- Since the signal drift is also batch dependent we fit the model `y ~ inj_idx * -->
<!-- batch` to the data. Because abundances measured in QC samples are supposed to be -->
<!-- identical within and between batches we estimate the effect on QC samples -->
<!-- only. Also, we log2 transform the data assuming the drift being caused by -->
<!-- multiplicative effects. The linear models are fitted using robust regression -->
<!-- \cite{Koller:2017jsa}. The fit fails for features with a) less than 4 data -->
<!-- points to fit the data on, or b) no measurements in one of the two -->
<!-- batches. These features will have to be adjusted using a global, not -->
<!-- feature-specific model. We are fitting the model only on detected peak -->
<!-- signals. An analysis including filled-in peak data was also performed (with -->
<!-- down-weighting filled-in signals), but the fits were too dependent on the -->
<!-- filled-in signals for cases with only few detected peaks. -->

```{r fit-model-global, echo = FALSE, eval = FALSE, message = FALSE, warning = FALSE}
smpls <- data_pos$sample == "POOL"
pdata <- pData(data_pos)[smpls, ]
##' Replace the numeric batch column with character to avoid it being treated
##' as a continuous variable!
pdata$batch[pdata$batch == 31012018] <- "a"
pdata$batch[pdata$batch == 1022018] <- "b"

##' Fit the model on only detected peaks.
mdls <- xcms:::rowFitModel(y ~ inj_idx * batch, data = pdata,
                           y = log2(fv_nofill[, smpls]), method = "lmrob")


```

Next we fit the linear models describing an (log scale) injection index
dependent signal drift to the abundances of QC samples separately in each
batch. The advantage of performing the analysis separately in each batch is that
the drift can be adjusted also for features for which only in one of the two
batches enough valid measurements would be available. The rationale of the
separate analysis is that the signal drift seemed to be batch dependent, thus a
different slope would have to be estimated for each batch anyway. Below we fit
linear models `y ~ inj_idx` to the log2 transformed abundances (only of detected
peaks) using robust regression \cite{Koller:2017jsa}. Model fitting is skipped
for features with less than 4 valid signals.

```{r fit-model-batch, message = FALSE, warning = FALSE}
smpls_a <- data_pos$batch == 31012018
qcs_a <- data_pos$sample == "POOL" & smpls_a
mdls_a <- xcms:::rowFitModel(y ~ inj_idx, data = pData(data_pos)[qcs_a, ],
                             y = log2(fv_nofill[, qcs_a]), method = "lmrob",
                             minVals = 4)

smpls_b <- data_pos$batch == 1022018
qcs_b <- data_pos$sample == "POOL" & smpls_b
mdls_b <- xcms:::rowFitModel(y ~ inj_idx, data = pData(data_pos)[qcs_b, ],
                             y = log2(fv_nofill[, qcs_b]), method = "lm",
                             minVals = 4)
```

We next remove fitted linear models for features for which valid measurements do
not span more than 2/3 of the injection index range or with the mean of the
absolute residuals being larger than 0.5.

<!-- a difference -->
<!-- between the 25 and 75% percentile of residuals larger than 1 (i.e. more than -->
<!-- two-fold deviation from the linear fit). -->

```{r fit-model-table-batch, message = FALSE, echo = FALSE, fig.cap = "Distribution of slopes of the fitted models for batch a and b. Red and blue represents slopes for models flagged because of too large range of residuals and too low span of injection index, respectively.", fig.width = 8, fig.height = 4, fig.path = IMAGE_PATH}

##' Calculating flags for batch a
##' flgs_res_a <- vapply(mdls_a, flag_model_residual, logical(1), diff_residual = 1)
flgs_res_a <- vapply(mdls_a, flag_model_mean_residual, logical(1), cut_off = 0.5)
flgs_inj_range_a <- vapply(mdls_a, flag_model_inj_range, logical(1),
                           min_range = diff(range(data_pos$inj_idx)) * 2/3)

##' Calculate slopes for batch a
slps_a <- vapply(mdls_a, function(z) {
    if (length(z) > 1) {
        coefficients(z)[2]
    } else NA_real_
}, numeric(1))

##' Calculate flags for batch b
##' flgs_res_b <- vapply(mdls_b, flag_model_residual, logical(1), diff_residual = 1)
flgs_res_b <- vapply(mdls_b, flag_model_mean_residual, logical(1), cut_off = 0.5)
flgs_inj_range_b <- vapply(mdls_b, flag_model_inj_range, logical(1),
                           min_range = diff(range(data_pos$inj_idx)) * 2/3)

##' Calculate slopes for batch b
slps_b <- vapply(mdls_b, function(z) {
    if (length(z) > 1) {
        coefficients(z)[2]
    } else NA_real_
}, numeric(1))

##' Plot the distribution of slopes.
par(mfrow = c(1, 2), mar = c(4, 4.5, 1, 0.5))
hist(slps_a, breaks = 128, xlab = "slope", main = "Batch a")
hist(slps_a[which(flgs_res_a)], breaks = 128, add = TRUE, col = "#ff000080")
hist(slps_a[which(flgs_inj_range_a)], breaks = 128, add = TRUE,
     col = "#0000ff80")
hist(slps_b, breaks = 128, xlab = "slope", main = "Batch b")
hist(slps_b[which(flgs_res_b)], breaks = 128, add = TRUE, col = "#ff000080")
hist(slps_b[which(flgs_inj_range_b)], breaks = 128, add = TRUE,
     col = "#0000ff80")

#' Split into excluded and good mdls
mdls_res_a <- mdls_a[which(flgs_res_a)]
mdls_inj_range_a <- mdls_a[which(flgs_inj_range_a)]
mdls_res_b <- mdls_b[which(flgs_res_b)]
mdls_inj_range_b <- mdls_b[which(flgs_inj_range_b)]

##' Remove model fits for the flagged friends.
mdls_a[unique(c(which(flgs_res_a), which(flgs_inj_range_a)))] <- NA
mdls_b[unique(c(which(flgs_res_b), which(flgs_inj_range_b)))] <- NA
slps_a[unique(c(which(flgs_res_a), which(flgs_inj_range_a)))] <- NA
slps_b[unique(c(which(flgs_res_b), which(flgs_inj_range_b)))] <- NA

#' Identify the features that are adjusted either in batch a or b
fts_adj <- sort(unique(c(
    names(mdls_a)[!is.na(mdls_a)],
    names(mdls_b)[!is.na(mdls_b)]
)))
```

Most of the slopes representing the estimated injection order-dependent signal
drift are 0 suggesting that most features are not affected by such a shift. The
injection index range filter removed most of the fits with the largest slopes.

The table below lists the number of features for which the model was fitted and
the number of features for which model fitting was skipped or discarded.

```{r fit-model-table, message = FALSE, echo = FALSE, results = "asis"}

tab <- cbind(batch_a = c(length(mdls_a), length(which(flgs_res_a)),
                         length(which(flgs_inj_range_a)),
                         sum(!is.na(mdls_a))),
             batch_b = c(length(mdls_b), length(which(flgs_res_b)),
                         length(which(flgs_inj_range_b)),
                         sum(!is.na(mdls_b)))
             )
rownames(tab) <- c("total features", "large residuals", "low inj idx range",
                   "valid model fits")
cptn <- paste("Numbers of features for which an injection index dependent",
              "model could be fitted.")
pandoc.table(tab, style = "rmarkdown", caption = cptn)
```

For about half of the features a model describing the injection dependent signal
drift has been defined.

Most of the slopes from the models describing the injection dependent signal
drift are close to 0 suggesting only a relatively low influence. Only about 60
have a absolute slope larger than 0.025.

```{r features-large-slopes-plots, echo = FALSE, message = FALSE, warning = FALSE}
#' Plotting all features with an absolute slope larger than some value.
#' Plots are created but not displayed here.

##' Features with absolute slope > 0.025
dr <- paste0(IMAGE_PATH, "largest_slopes_batch_a/")
dir.create(dr, showWarnings = FALSE)
fts <- names(mdls_a)[which(abs(slps_a) > 0.025)]
for (ft in fts) {
    png(paste0(dr, ft, ".png"), width = 10, height = 5, pointsize = 6,
        res = 200, units = "cm")
    plot_feature_slopes_batch(y = log2(fv[ft, ]),
                              is_filled = is.na(fv_nofill[ft, ]),
                              data = pData(data_pos), lmoda = mdls_a[[ft]],
                              lmodb = mdls_b[[ft]], main = ft)
    dev.off()
}

dr <- paste0(IMAGE_PATH, "largest_slopes_batch_b/")
dir.create(dr, showWarnings = FALSE)
fts <- names(mdls_b)[which(abs(slps_b) > 0.025)]
for (ft in fts) {
    png(paste0(dr, ft, ".png"), width = 10, height = 5, pointsize = 6,
        res = 200, units = "cm")
    plot_feature_slopes_batch(y = log2(fv[ft, ]),
                              is_filled = is.na(fv_nofill[ft, ]),
                              data = pData(data_pos), lmoda = mdls_a[[ft]],
                              lmodb = mdls_b[[ft]], main = ft)
    dev.off()
}
##' Most of the features seem to represent signal from the same compound
##' (different adducts?).
##' Question also is if we would be better of with simple lm instead of lmrob.

```

```{r features-large-r-squared, echo = FALSE, message = FALSE, warning = FALSE}
#' Plot features with largest or smallest R squared.

##' Calculate adjusted R squared
adjr_a <- vapply(mdls_a, function(z) {
    if (length(z) > 1)
        summary(z)$adj.r.squared
    else NA_real_
}, numeric(1))
adjr_b <- vapply(mdls_b, function(z) {
    if (length(z) > 1)
        summary(z)$adj.r.squared
    else NA_real_
}, numeric(1))


##' Features with poos R2
fts <- names(sort(abs(adjr_a)))[1:20]
dr <- paste0(IMAGE_PATH, "lowest_R_batch_a/")
dir.create(dr, showWarnings = FALSE)
for (ft in fts) {
    png(paste0(dr, ft, ".png"), width = 10, height = 5, pointsize = 6,
        res = 200, units = "cm")
    plot_feature_slopes_batch(y = log2(fv[ft, ]),
                              is_filled = is.na(fv_nofill[ft, ]),
                              data = pData(data_pos), lmoda = mdls_a[[ft]],
                              lmodb = mdls_b[[ft]], main = ft)
    dev.off()
}
fts <- names(sort(abs(adjr_b)))[1:20]
dr <- paste0(IMAGE_PATH, "lowest_R_batch_b/")
dir.create(dr, showWarnings = FALSE)
for (ft in fts) {
    png(paste0(dr, ft, ".png"), width = 10, height = 5, pointsize = 6,
        res = 200, units = "cm")
    plot_feature_slopes_batch(y = log2(fv[ft, ]),
                              is_filled = is.na(fv_nofill[ft, ]),
                              data = pData(data_pos), lmoda = mdls_a[[ft]],
                              lmodb = mdls_b[[ft]], main = ft)
    dev.off()
}
##' Mostly nice fits but with slope ~ 0 or those that don't fit that nicely.

##' Features with very good R2
fts <- names(sort(abs(adjr_a), decreasing = TRUE))[1:20]
dr <- paste0(IMAGE_PATH, "highest_R_batch_a/")
dir.create(dr, showWarnings = FALSE)
for (ft in fts) {
    png(paste0(dr, ft, ".png"), width = 10, height = 5, pointsize = 6,
        res = 200, units = "cm")
    plot_feature_slopes_batch(y = log2(fv[ft, ]),
                              is_filled = is.na(fv_nofill[ft, ]),
                              data = pData(data_pos), lmoda = mdls_a[[ft]],
                              lmodb = mdls_b[[ft]], main = ft)
    dev.off()
}
fts <- names(sort(abs(adjr_b), decreasing = TRUE))[1:20]
dr <- paste0(IMAGE_PATH, "highest_R_batch_b/")
dir.create(dr, showWarnings = FALSE)
for (ft in fts) {
    png(paste0(dr, ft, ".png"), width = 10, height = 5, pointsize = 6,
        res = 200, units = "cm")
    plot_feature_slopes_batch(y = log2(fv[ft, ]),
                              is_filled = is.na(fv_nofill[ft, ]),
                              data = pData(data_pos), lmoda = mdls_a[[ft]],
                              lmodb = mdls_b[[ft]], main = ft)
    dev.off()
}
##' Mostly nice fits with relatively large slopes.

```

Some examples for nice model fits for features with large injection order
dependent drifts are shown below.

```{r out.width = "750px", echo = FALSE}
knitr::include_graphics(paste0(IMAGE_PATH, "highest_R_batch_a/FT00642.png"))
```

```{r out.width = "750px", echo = FALSE}
knitr::include_graphics(paste0(IMAGE_PATH, "highest_R_batch_a/FT07853.png"))
```


```{r features-excluded-residuals, echo = FALSE, warning = FALSE, message = FALSE}
#' Plot data for features that were excluded due to large residuals

#' Identify top 20 with largest slopes
tmp_slps <- vapply(mdls_res_a, function(z) {
    coefficients(z)[2]
}, numeric(1))
fts <- names(sort(abs(tmp_slps), decreasing = TRUE))[1:20]
dr <- paste0(IMAGE_PATH, "largest_slopes_batch_a_residuals_excluded/")
dir.create(dr, showWarnings = FALSE)
for (ft in fts) {
    png(paste0(dr, ft, ".png"), width = 10, height = 5, pointsize = 6,
        res = 200, units = "cm")
    plot_feature_slopes_batch(y = log2(fv[ft, ]),
                              is_filled = is.na(fv_nofill[ft, ]),
                              data = pData(data_pos), lmoda = mdls_res_a[[ft]],
                              lmodb = mdls_res_b[[ft]], main = ft)
    dev.off()
}
tmp_slps <- vapply(mdls_res_b, function(z) {
    coefficients(z)[2]
}, numeric(1))
fts <- names(sort(abs(tmp_slps), decreasing = TRUE))[1:20]
dr <- paste0(IMAGE_PATH, "largest_slopes_batch_b_residuals_excluded/")
dir.create(dr, showWarnings = FALSE)
for (ft in fts) {
    png(paste0(dr, ft, ".png"), width = 10, height = 5, pointsize = 6,
        res = 200, units = "cm")
    plot_feature_slopes_batch(y = log2(fv[ft, ]),
                              is_filled = is.na(fv_nofill[ft, ]),
                              data = pData(data_pos), lmoda = mdls_res_a[[ft]],
                              lmodb = mdls_res_b[[ft]], main = ft)
    dev.off()
}
#' Now, most of the excluded model fits are indeed problematic, but some would
#' represent more or less the overall data trend, but the measurements seem to
#' be noisy. Here there has to be some tradeoff between introducing too much
#' noise and not adjusting the trend for some features.
```

Examples for linear models that were **excluded** because of too large residuals
are shown below (the first excluded in batch a and the second in batch b).

```{r out.width = "750px", echo = FALSE}
knitr::include_graphics(
           paste0(IMAGE_PATH,
                  "largest_slopes_batch_a_residuals_excluded/FT06751.png"))
```

```{r out.width = "750px", echo = FALSE}
knitr::include_graphics(
           paste0(IMAGE_PATH,
                  "largest_slopes_batch_b_residuals_excluded/FT05318.png"))
```


```{r features-excluded-inj-range, echo = FALSE, warning = FALSE, message = FALSE}
#' Plot data for features excluded because their data points do not span a
#' large enough portion of the injection range.
#' Identify top 20 with largest slopes
tmp_slps <- vapply(mdls_inj_range_a, function(z) {
    coefficients(z)[2]
}, numeric(1))
fts <- names(sort(abs(tmp_slps), decreasing = TRUE))[1:20]
dr <- paste0(IMAGE_PATH, "largest_slopes_batch_a_inj_range_excluded/")
dir.create(dr, showWarnings = FALSE)
for (ft in fts) {
    png(paste0(dr, ft, ".png"), width = 10, height = 5, pointsize = 6,
        res = 200, units = "cm")
    plot_feature_slopes_batch(y = log2(fv[ft, ]),
                              is_filled = is.na(fv_nofill[ft, ]),
                              data = pData(data_pos),
                              lmoda = mdls_inj_range_a[[ft]],
                              lmodb = mdls_inj_range_b[[ft]], main = ft)
    dev.off()
}
tmp_slps <- vapply(mdls_inj_range_b, function(z) {
    coefficients(z)[2]
}, numeric(1))
fts <- names(sort(abs(tmp_slps), decreasing = TRUE))[1:20]
dr <- paste0(IMAGE_PATH, "largest_slopes_batch_b_inj_range_excluded/")
dir.create(dr, showWarnings = FALSE)
for (ft in fts) {
    png(paste0(dr, ft, ".png"), width = 10, height = 5, pointsize = 6,
        res = 200, units = "cm")
    plot_feature_slopes_batch(y = log2(fv[ft, ]),
                              is_filled = is.na(fv_nofill[ft, ]),
                              data = pData(data_pos),
                              lmoda = mdls_inj_range_a[[ft]],
                              lmodb = mdls_inj_range_b[[ft]], main = ft)
    dev.off()
}
#' These are for the most part disastrous. Some seem to follow the overall data
#' trend (mostly those with small slopes) but it is still better to remove
#' model fits that span only a limited injection index range.
```

Next we apply the within batch correction adjusting all (including filled-in)
feature abundances based on the estimated models. Adjustment resulted in three
measurements with negative (log2) abundances. These were replaced by half of the
minimum non negative intensity for that feature. Note however that quite some
log2 abundances are smaller than 1, which represents negative intensities in
natural scale.

```{r apply-within-batch-adjustment, message = FALSE, warning = FALSE}
#' Applying the adjustment to the full (filled-in) data. Note that
#' adjustment of the detected peak values did not result in negative
#' log2 abundances.
fv_adj <- fv
fv_adj[, smpls_a] <- xcms:::applyModelAdjustment(
                                y = log2(fv[, smpls_a]), lmod = mdls_a,
                                data = pData(data_pos)[smpls_a, ],
                                shiftNegative = "replaceHalfMin")
fv_adj[, smpls_b] <- xcms:::applyModelAdjustment(
                                y = log2(fv[, smpls_b]), lmod = mdls_b,
                                data = pData(data_pos)[smpls_b, ],
                                shiftNegative = "replaceHalfMin")
```

Next we plot the data before and after adjustment for some selected features.

```{r feature-plots-before-after-within-adjustment, echo = FALSE, message = FALSE, warning = FALSE}

#' Select sone with the best R squared in batch a, one for batch b
#' fts <- c(names(sort(abs(adjr_a), decreasing = TRUE)[1:5]),
#'          names(sort(abs(adjr_b), decreasing = TRUE)[1:5]))
#' Manually specifying features... these are from the largest R squared and
#' large slope candidates
fts <- sort(c("FT00642", "FT05680", "FT07853", "FT00988", "FT09056"))
dr <- paste0(IMAGE_PATH, "within-batch-examples/")
dir.create(dr, showWarnings = FALSE)
for (ft in fts) {
    png(paste0(dr, ft, "_raw.png"), width = 10, height = 5, pointsize = 6,
        res = 200, units = "cm")
    plot_feature_slopes_batch(y = log2(fv[ft, ]),
                              is_filled = is.na(fv_nofill[ft, ]),
                              data = pData(data_pos), lmoda = mdls_a[[ft]],
                              lmodb = mdls_b[[ft]], main = ft, legend = FALSE)
    dev.off()
    png(paste0(dr, ft, "_adj.png"), width = 10, height = 5, pointsize = 6,
        res = 200, units = "cm")
    y_sub <- fv_adj[ft, ]
    y_sub[!is.na(fv_onlyfill[ft, ])] <- NA
    lmoda <- xcms:::fitModel(y ~ inj_idx, data = pData(data_pos)[qcs_a, ],
                             method = "lmrob", y = y_sub[qcs_a])
    lmodb <- xcms:::fitModel(y ~ inj_idx, data = pData(data_pos)[qcs_b, ],
                             method = "lmrob", y = y_sub[qcs_b])
    plot_feature_slopes_batch(y = fv_adj[ft, ],
                              is_filled = is.na(fv_nofill[ft, ]),
                              data = pData(data_pos), lmoda = lmoda,
                              lmodb = lmodb, main = ft, legend = FALSE)
    dev.off()
}

```

The plots below show some examples for feature signals before and after
within-batch correction.

```{r out.width = 8, echo = FALSE, fig.cap = "Feature abundances before adjustment."}
knitr::include_graphics(paste0(dr, "FT09056_raw.png"))
```

```{r out.width = 8, echo = FALSE, fig.cap = "Feature abundances after within-batch adjustment."}
knitr::include_graphics(paste0(dr, "FT09056_adj.png"))
```

For each sample two measurements are available within the same batch. These
replicates derive from the same original tube (sample), but all further
processing was performed separately. LLLLL These replicates can thus be used to
estimate the performance of the within-batch adjustment as the difference
between measured abundances should be reduced by a successfull normalization. We
perform this quality assessment only on **detected** peaks since the filled-in
signal was shown to be considerably lower than detected peak data therefore
artificially increasing the difference between replicated measurements if only
in one sample a peak was identified.

Below we calculate the difference in abundances between replicated measurements
on detected peak data only.

```{r calculate-mra, message = FALSE, warning = FALSE}
grp <- paste(data_pos$source, data_pos$sample, sep = "-")

#' Remove adjusted filled-in signal
fv_nofill_adj <- fv_adj
fv_nofill_adj[is.na(fv_nofill)] <- NA

#' Calculate the raw and adjusted MRAs within batch a
mra_raw_a <- apply_colgroup(fv_nofill[, smpls_a], grp[smpls_a], rowMra)
mra_adj_a <- apply_colgroup(2^fv_nofill_adj[, smpls_a], grp[smpls_a], rowMra)
#' same for batch b
mra_raw_b <- apply_colgroup(fv_nofill[, smpls_b], grp[smpls_b], rowMra)
mra_adj_b <- apply_colgroup(2^fv_nofill_adj[, smpls_b], grp[smpls_b], rowMra)

```

To evaluate the impact of within-batch normalization we calculate the 75%
quantile of all adjusted features' MRA per sample. 75% of adjusted features for
a specific sample have a maximum ratio of abundances between replicated
measurements that is smaller than this value.

```{r mra-75}
mra_raw_a_75 <- apply(mra_raw_a[fts_adj, ], 2, quantile,
                      probs = 0.75, na.rm = TRUE)
mra_adj_a_75 <- apply(mra_adj_a[fts_adj, ], 2, quantile,
                      probs = 0.75, na.rm = TRUE)

mra_raw_b_75 <- apply(mra_raw_b[fts_adj, ], 2, quantile,
                      probs = 0.75, na.rm = TRUE)
mra_adj_b_75 <- apply(mra_adj_b[fts_adj, ], 2, quantile,
                      probs = 0.75, na.rm = TRUE)

```

A comparison between the raw and adjusted 75% MRAs is shown in the plot below.

```{r mra-75-scatterplot, message = FALSE, warning = FALSE, fig.path = IMAGE_PATH, fig.cap = "Raw against adjusted 75% MRA for replicated samples in batch a (left) and batch b (right). Each point represents the 75% MRA for one replicated sample pair. Colors indicate the sample source, the solid line the identity line.", fig.width = 12, fig.height = 6, echo = FALSE}

cols_mra_a <- col_source[vapply(strsplit(colnames(mra_adj_a), "-"),
                                function(z) z[1], character(1))]
cols_mra_b <- col_source[vapply(strsplit(colnames(mra_adj_b), "-"),
                                function(z) z[1], character(1))]

par(mfrow = c(1, 2), mar = c(4.3, 4.3, 1, 0.5))
YL <- range(c(mra_raw_a_75, mra_adj_a_75), na.rm = TRUE)
plot(mra_raw_a_75, mra_adj_a_75, main = "batch a", col = paste0(cols_mra_a, 80),
     pch = 16, xlim = YL, ylim = YL, xlab = "raw 75% MRA", ylab = "adj 75% MRA")
abline(0, 1)
grid()
legend("topleft", legend = unique(names(cols_mra_a)),
       col = cols_mra_a[unique(names(cols_mra_a))], pch = 16)
YL <- range(c(mra_raw_b_75, mra_adj_b_75), na.rm = TRUE)
plot(mra_raw_b_75, mra_adj_b_75, main = "batch b", col = paste0(cols_mra_a, 80),
     pch = 16, xlim = YL, ylim = YL, xlab = "raw 75% MRA", ylab = "adj 75% MRA")
abline(0, 1)
grid()

```

The 75% MRA of replicated samples is between 1.2 and 2.5 which is actually quite
good, meaning that most samples have a less than 2-fold difference between
replicated measurements. Within-batch normalization had however no big impact on
the MRA. This might be explained by the relatively moderate signal drift present
in only few features (for most features the estimated signal drift slope was
about 0 suggesting an almost absent signal drift).

The boxplot below summarizes the results by comparing the distribution of raw
and adjusted 75% MRA for both batches.

```{r mra-75-boxplot, message = FALSE, warning = FALSE, fig.path = IMAGE_PATH, fig.cap = "Distribution of 75% MRAs for the raw and adjusted features in batch a and b.", fig.width = 6, fig.height = 6, echo = FALSE}

par(mar = c(6, 4.3, 1, 1), mfrow = c(1, 1))
boxplot(data.frame(`raw btch a` = mra_raw_a_75, `adj btch a` = mra_adj_a_75,
                   `raw btch b` = mra_raw_b_75, `adj btch b` = mra_adj_b_75),
        ylab = "75% MRA", las = 2)
grid(ny = NULL, nx = NA)
```

Within-batch adjustment did reduce the 75% MRAs slightly, especially the 75%
quantile and the value ranges.



# Between-batch normalization

The between-batch normalization aims to remove batch specific effects from the
data. These batch effects are assumed to affect each sample measured in the same
batch (same run, from the same plate) in the same way. The effect is estimated
based on abundances in QC samples and differences of these between batches are
leveled. Note that this between-batch normalization does **not** account for
biases that result from pipetting or injection amount differences. Such effects
would have to be normalized based on a per-sample normalization strategy similar
to what is performed in gene expression experiments.

```{r estimate-betwee-batch-effect, message = FALSE, warning = FALSE}
#' Use the linear model fit on DETECTED QC samples
data_pos$batch <- factor(data_pos$batch) #' avoid batch being treated as number
mdls_batch <- xcms:::rowFitModel(y ~ batch,
                                 data = pData(data_pos)[qcs_a | qcs_b, ],
                                 y = fv_nofill_adj[, qcs_a | qcs_b],
                                 method = "lm", minVals = 6)

#' get the slopes and the intercepts.
mdls_slp <- vapply(mdls_batch, function(z) {
    if (length(z) > 1) z$coefficients[2]
    else NA_real_
}, numeric(1))
mdls_int <- vapply(mdls_batch, function(z) {
    if (length(z) > 1) z$coefficients[1]
    else NA_real_
}, numeric(1))

par(mfrow = c(1, 2))
hist(mdls_int)
hist(mdls_slp)

```



**Questions**: 

- QC pool: is it the pool of all samples from batch a and b, or is the QC pool
  in batch a only the pool from samples from batch a and the QC pool in batch b
  the pool from samples from batch b? Pool is the same in both plates.
- Replicated measurements: technical replicates? Same blood source (tube)
  sampling was done twice.
- Batch effect: global or per-feature based? Can test that: compare the
  distribution of per-feature batch effects. If they are not strongly
  different -> global. **Answer** combination of global and feature specific. To
  what amount -> use the CHRIS normalization data set.
- What with per-sample normalization? That would account for pipetting
  differences or injection amount differences resulting in a different amount of
  sample being processed. There is nothing such reverse transcription or
  amplification efficiency that we would have to consider here - still.
  **Siggi**: from a liquid sample, always the same amount is taken, thus the
  amount should be the same for all samples. Nevertheless, many people do such
  per-sample normalization: using internal standards (added at the beginning;
  can still be tricky) or approaches such as normalizing on the total sum of
  signal.



# Final QA

For samples for which even peak filling does not result in a
signal we impute the data by setting it to half of the smallest value adding
also a random value (from a normal distribution with mean being half of the
smallest value and standard deviation being 1 fourth of the standard deviation
of values for that feature). 

+ Load the data
+ Check average abundances.
+ RLA plots for abundances.
+ Adjust injection order dependent drift... do I have to? Really?
  - In log2 scale.
  - Use all samples, check for QCs if it improved.
  - Overall RSD.
  - Features with an RSD < 0.3, 0.2, 0.1.
+ Adjust batch effect.



```{r}

#' tmp <- na.omit(fv)
#' pc <- prcomp(t(log2(tmp)), scale = FALSE, center = TRUE)
#' par(mfrow = c(1, 2))
#' BioCHRIStes::plot_pca(pc, col = col_source[data_pos$source],
#'                       pc_x = 1, pc_y = 2)
#' BioCHRIStes::plot_pca(pc, col = col_source[data_pos$source],
#'                       pc_x = 3, pc_y = 4)

#' quartz()
#' tmp <- na.omit(fv_adj)
#' pc <- prcomp(t(tmp), scale = FALSE, center = TRUE)
#' par(mfrow = c(1, 2))
#' BioCHRIStes::plot_pca(pc, col = col_source[data_pos$source],
#'                       pc_x = 1, pc_y = 2)
#' BioCHRIStes::plot_pca(pc, col = col_source[data_pos$source],
#'                       pc_x = 3, pc_y = 4)


```

```{r}

#' #' This code chunk generates the data for Chiara (after filling in peak values):
#' fv <- featureValues(data_pos, method = "sum", value = "into")[fts_used, ]

#' pd <- pData(data_pos)
#' write.table(pd, file = "data/txt/sample-descriptions.txt", sep = "\t",
#'             row.names = FALSE)

#' fv <- data.frame(feature_id = rownames(fv),
#'                  featureDefinitions(data_pos)[fts_used,
#'                                               c("mzmed", "mzmin", "mzmax",
#'                                                 "rtmed", "rtmin", "rtmax")],
#'                  fv, check.names = FALSE)
#' write.table(fv, file = "data/txt/feature-values-filled.txt", sep = "\t",
#'             row.names = FALSE)


#' fv <- featureValues(data_pos, method = "sum",
#'                     value = "into", filled = FALSE)[fts_used, ]

#' fv <- data.frame(feature_id = rownames(fv),
#'                  featureDefinitions(data_pos)[fts_used,
#'                                               c("mzmed", "mzmin", "mzmax",
#'                                                 "rtmed", "rtmin", "rtmax")],
#'                  fv, check.names = FALSE)
#' write.table(fv, file = "data/txt/feature-values-not-filled.txt", sep = "\t",
#'             row.names = FALSE)

```


# References
