---
title: "Normalization of the vams vs intraveneous untargeted metabolomics data, positive polarity"
author: "Christa Malfertheiner, Chiara Volani, Beatrice Giaier, Mar Garcia-Aloy, Vinicius Veri Hernandes and Johannes Rainer"
graphics: yes
output:
  BiocStyle::html_document:
    toc_float: true
bibliography: references.bib
csl: biomed-central.csl
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

```{r biocstyle, echo = FALSE, results = "asis"}
library('knitr')
library(BiocStyle)
BiocStyle::markdown()
```

**Modified**: `r file.info("vams_normalization.Rmd")$mtime`<br />
**Compiled**: `r date()`

```{r settings, echo = FALSE, results = "hide", message = FALSE}
## Set general options
options(useFancyQuotes = FALSE)
set.seed(123)

## Setting golden ratio to save images
phi <- (1+sqrt(5))/2

## Define paths:
filename <- "vams_normalization_pos"
## Path to save the images; remove all old images.
IMAGE_PATH <- paste0("C:/Users/User/Documents/Masterarbeit/R/images/", filename, "/")
dir.create(IMAGE_PATH, recursive = TRUE, showWarnings = FALSE)
## Path to store RData files
RDATA_PATH <- paste0("data/RData/", filename, "/")
if (!file.exists(RDATA_PATH)) dir.create(RDATA_PATH, recursive = TRUE)

## Define the path where we can find the mzML files:
MZML_PATH <- "C:/Users/User/Documents/mzML_pos"
if (!file.exists(MZML_PATH))
    stop("Can not find the directory with the mzML files: ", MZML_PATH)

## Where to cut the chromatogram (i.e. subset to spectra within rt 0-rt_cut)
rt_cut <- 340

## Get the number of cpus allocated or fall back to 3 
ncores <- as.integer(Sys.getenv("SLURM_JOB_CPUS_PER_NODE", 3))

#' Whether or not to plot the EICs for all standards - takes loooong time
plot_eics <- TRUE

#' rt_tol: accepted deviation of a standards retention time to the theoretical
#' one.
rt_tol <- 40
```

# Abstract

This document defines the normalization of the feature abundance of the
*MitYOU* project. This comprises a first quality assessment, fill-in of
missing values, between-sample normalization and normalization of injection
order-dependent signal drift within the measurement run.

# Introduction

Untargeted metabolomics experiments are, similar to any other data from high
throughput assays, subject to unwanted variation: this can stem from many
sources, such as experimental equipment and unwanted technical or biological
differences among samples. The former kind of variation includes batch-to-batch
variation due to environmental conditions, such as temperature changes,
instrument performance, sample preparation and subsequent degradation. The
latter can arise from different weights or volumes of the samples or a different
size of cells among samples [@Livera:2015bo].

These effects are unavoidable and several methods have been developed to
accommodate them in statistical models or to remove them, as described in
[@Livera:2015bo]. Many algorithms are based on regression models to achieve the
goal of batch correction, while other approaches use scaling factors to remove
unwanted variation. The first type is used for example in the approach of
Wehrens et al. [@Wehrens:2016ie] to perform a featyre-wise normalization of
batch effects and signal drifts. This approach is however unable to account for
between-sample differences such as differences in volumes injected, which can
however be adjusted for by simple scaling methods. For this reason, the two
approaches can be combined to provide a better outcome for the normalization of
experimental measurements, in order to make the data more comparable.

In this document we perform the normalization of the feature abundances of the
*MitYOU* project. This comprises quality assessment based on the feature's
abundances, eventual normalization of a injection order-dependent signal drift
within each batch (if this proves to increase signal quality as determined by
the comparison of abundances from replicated measurements) and removal of
between batch effects. The preprocessing of the data is described in file
*vams_preprocessing.Rmd*.

## Metabolomics data normalization

Untargeted meatabolomics data biased by a variety of different biological and
technical variances. Biological variances include e.g. the amount or
concentration of biofluids while technical variances comprise batch effects
(laboratory conditions, reagent lots), sample degradation over time in long runs
of samples, matrix specific effects (such as ion suppression), temperature
changes within instruments, and variations during sample extraction and
preparation. Sample degratation over time in long runs, oxidization or build-up
of contaminants can lead to signal drifts dependent on the injection order.

Different approaches for the normalization of metabolomics data exist (briefly
described also in [@Livera:2015bo]). Batch correction methods use per-feature
regression models to remove batch effects and signal drifts
[@Dunn:2011bq],[@Wang:2013fe],[@Wehrens:2016ie] but don't usually remove biases
related to the processing of individual samples (with the exception of Batch
Normalizer [@Wang:2013fe]). Other methods such as scaling (e.g. by the total sum
of signal) or RUV (removal of unwanted variance) [@Livera:2015bo] adjust for
such sample-specific biases, but do not remove feature specific signal drifts.

Combinations of such feature-wise and sample-wise normalization strategies
should be possible. Feature-wise normalization approaches, if applied before
normalization adjusting between sample differences, should however be based only
on QC samples, as these are thought to be (at least within the same batch),
independent of any sample processing differences.

## Experimental design and normalization strategy

The samples of the present experiment consist of samples from 20 healthy
volunteers. From each an intravenous and two capillary blood sample were taken,
the latter using 2 Mitra tips. After sampling intravenous blood with two Mitra
tips the blood in the EDTA tube was further processed and centrifuged to
separate peripheral blood cells (PBCs) from plasma. From each of the two
fractions two Mitra tips each were used to collect material. From each
individual thus in total 8 samples are available, 2 capillary, 2 intravenous, 2
plasma and 2 PBC samples. Mitra tips were dried and stored at -80. Next the tips
were resuspended with a solvent containing also internal standards. After sample
preparation, an aliquot was taken from each sample and pooled to create the QC
sample pool. Individual samples were randomly distributed on two 96 well plates,
with the two replicates per individual being put on the same well. The two
plates were measured on consecutive days.

QC samples, that are by design independent of the sample preparation step, can
be used to estimate and correct LC-MS specific biases, including a potential
injection order dependent signal drift and batch/run specific biases. Such
effects are thought to be specific for each metabolite. Sample preparation
dependent biases between samples (but independent of the metabolite) can be
estimated or evaluated using internal standards and replicated samples (two
samples for each individual and matrix).

It is not clear whether between-sample normalization should be performed before
or after adjustment for LC-MS specific biases. If batch and injection-order
dependent effects are adjusted using QC samples the order should not be
problematic as QC samples are independent of sample processing based
biases. Still, since biases related to the LC-MS system have been added to the
signal *after* biases related to sample processing, removing them first seems to
be more natural.

# Data import and initial quality assessment

First, we load all the required libraries and the preprocessed data. The
`quantify` method is then used to extract raw feature intensities from the
preprocessed data; we set the method to `sum` so that we sum the intensities
of all peaks detected for one feature in one sample. This function returns a
`SummarizedExperiment` object, where each column represents a sample and each
row contains a feature; this object can contain one or more matrices, in the
form of `assays`, which can be easily accessed with the `assay` function.
A `SummarizedExperiment` also allows us to retain annotation for each row and
column, which will later help us to subset columns and rows, in order to easily
access them with `colData` and `rowData`, respectively. Then, we assign
different colours to each experimental group, as we did for the preprocessing. 

```{r libraries-data, message = FALSE, warning = FALSE}
library(xcms)
library(RColorBrewer)
library(pander)

## register(bpstart(MulticoreParam(ncores)))
library(doParallel)
#registerDoParallel(ncores)
register(DoparParam(), default = TRUE)
library(DESeq2)
library(CompMetaboTools)

## Load utility functions for this document
## source("util-functions.R")
source("vams_normalization_functions.R")

## Define colors for the groups.
col_source <- brewer.pal(5, name = "Set1")
names(col_source) <- c("RBC",           #' red
                       "plasma",        #' blue
                       "all",           #' green
                       "capillary",     #' purple
                       "venous")        #' orange

load("data/RData/vams_preprocessing_pos/data_pos.RData")
data_pos$batch <- factor(data_pos$batch)
```

Next we extract the feature abundances as a `SummarizedExperiment`, subsetting
also to the features defined above.

```{r extract-as-se}
res_pos <- quantify(data_pos, method = "sum", filled = FALSE)
```

# Gap filling and imputation of missing values

We fill-in data for samples in which no peak was detected. While we will
eventually exclude filled-in signals in the estimation of the normalization
factors for the within and between-batch normalization, we will normalize these
intensities as they might be affected by the same effects than the *real*
signal. Imputation of signals that are still missing after filling in will be
performed **after** normalization.

Below we fill-in missing peak data from an m/z - retention time slice defined by
the m/z range of the feature and the retention time window of the feature
definition that is extended by a constant value (i.e. the median retention time
width of all identified peaks). The retention time window from which the signal is
integrated should be expanded, because the feature's retention time range
represents the minimal and maximal apex position of the associated peaks in the
time dimension, and is thus unrelated to the actual retention time width of the
peaks. The m/z range is also extended by 20ppm.

Many underlying causes can be at the root of these
missing intensities: a signal may be not detectable because a compound is absent
from a sample or it may be noisy (hence failing in the peak detection step to be
identified) and/or below the detection limit of the
instrument. We can use the `fillChromPeaks` function to rescue missing signals
with the so-called *gap filling*: this method uses the area under the curve of
the samples where the specific peak was identified to define plausible intensity
values where they are missing. We are then able to distinguish the filled-in
peaks from the detected peaks in the `chromPeakData` data frame: the
`"is_filled"` column is created, where `TRUE` will be annotated in case of
filled-in peaks. This information is added to `res_pos` as the `raw_filled`
assay: this will be later used to retrieve filled-in data only. It is important
to remember that even after gap filling, a signal can still be missing.

```{r fill-in, message = FALSE, warning = FALSE}
## Fill-in missing values
data_pos <- fillChromPeaks(data_pos, param = ChromPeakAreaParam())
save(data_pos, file = paste0(RDATA_PATH, "data_pos_filled.RData"))
```

```{r load, messgage = FALSE}
load(paste0(RDATA_PATH, "data_pos_filled.RData"))

## Add filled-in data to the result object
assays(res_pos)$raw_filled <- featureValues(data_pos, method = "sum",
                                            filled = TRUE)
## Add the only-filled-in signal to the result object
tmp <- assay(res_pos, "raw_filled")
tmp[!is.na(assay(res_pos, "raw"))] <- NA
assays(res_pos)$raw_only_filled <- tmp
```

Below we compare the signal distribution of detected and filled-in peak signals.

```{r compare-detected-filled-plot, fig.path = IMAGE_PATH, message = FALSE, echo = FALSE, warning = FALSE, fig.cap = "Distribution of (log2) signal intensities of detected and filled-in peaks. Left: all features/peaks, right: only peaks of features used in the present analysis based on the above definition.", fig.width = 8, fig.height = 4}
## Distribution raw data
ints_det <- chromPeaks(data_pos)[!chromPeakData(data_pos)$is_filled, "into"]
ints_fil <- chromPeaks(data_pos)[chromPeakData(data_pos)$is_filled, "into"]

par(mfrow = c(1, 2), mar = c(4, 4.5, 4, 0.5))
boxplot(list(detected = log2(ints_det), filled = log2(ints_fil)),
        varwidth = TRUE, main = "all peaks",
        ylab = expression(log[2]~abundance))

## Peaks assigned to features
pk_idxs <- sort(unlist(featureDefinitions(data_pos)[, "peakidx"]))
tmp <- chromPeaks(data_pos)[pk_idxs, "into"]
ints_det <- tmp[!chromPeakData(data_pos)$is_filled[pk_idxs]]
ints_fil <- tmp[chromPeakData(data_pos)$is_filled[pk_idxs]]
boxplot(list(detected = log2(ints_det), filled = log2(ints_fil)),
        varwidth = TRUE, main = "feature peaks",
        ylab = expression(log[2]~abundance))

```

As expected, abundances from filled-in peaks have on average lower intensities
than truly detected peaks. Abundances are however relatively similar suggesting
that for many missing peaks a signal from an ion was recorded, but peak
detection failed.

Afterwards, we compare the filled-in with the detected signal for *QC samples*. 
We start by calculating the mean of both, then we proceed with plotting the results.
Ideally, the plotted dots should be found along the diagonal `y = x` 
(maximum correlation). Also, we compute the Pearson's correlation coefficient,
specifying `use = "pairwise.complete.obs"`: this string is used to make explicit
how to handle missing data, in this case calculating the correlation only using
all complete pairs of values. Ideally, the filled-in signal should be correlated
to the detected signal.

```{r correlation-filled-detected, fig.path = IMAGE_PATH, fig.cap = "Correlation of per-feature averaged detected and filled-in signal in QC samples.", echo = FALSE}
avg_det <- rowMeans(assay(res_pos, "raw")[, res_pos$sample == "POOL"], na.rm = TRUE)
avg_fil <- rowMeans(assay(res_pos, "raw_only_filled")[, res_pos$sample == "POOL"],
                    na.rm = TRUE)
plot(log2(avg_det), log2(avg_fil), xlab = "detected", ylab = "filled-in",
     main = "Feature abundances, QC samples", pch = 16, col = "#00000080")
abline(0, 1, col = "grey")
cor(log2(avg_det), log2(avg_fil), use = "pairwise.complete.obs")
```

We can see a relatively high correlation between the detected and filled-in
signal, especially for features with higher abundances. For low abundant
features (below ~ 1000) detected abundances are systematically higher than
filled-in.

We now calculate and compare for each feature in QC samples the difference
between the detected and filled-in peak data. Evaluation in QC samples avoids
any potential differences being caused by biological differences of the compared
samples.

First, we plot the detected data:

```{r raw-boxplot-detected, fig.path =IMAGE_PATH, fig.height = 7, fig.width = 7 * phi, fig.cap = "Number of features and log2 abundance of raw detected data.", echo = FALSE}
dobox <- function(
 x, col = paste0(col_source[as.character(data_pos$source)], "ff"),
 outline = FALSE, notch = TRUE, range = 0,
 border = paste0(col_source[as.character(data_pos$source)], "60"),
 ylab = expression(log[2]~abundance), xaxt = "n", xlab = "",
 ...) {
 boxplot(x, col = col, outline = outline, notch = notch, range = range,
 border = border, ylab = ylab, xaxt = xaxt, xlab = xlab, ...)
 grid(nx = NA, ny = NULL)
}

layout(mat = matrix(1:2, ncol = 1), height = c(0.3, 0.7))
cols <- col_source[as.character(res_pos$source)]
par(mar = c(0.2, 4.5, 2, 0.5))
barplot(apply(assay(res_pos, "raw"), MARGIN = 2, function(x) sum(!is.na(x))),
        col = paste0(cols, 80), ylim = c(0, 8000),
        ylab = "Features", xaxt = "n", main = "Detected raw data")
legend("top", horiz = TRUE, col = col_source, legend = names(col_source), lwd = 1)
par(mar = c(0.2, 4.5, 0, 0.5))
dobox(log2(assay(res_pos, "raw")), col = paste0(cols, "ff"), xaxt = "n",
      border = paste0(cols, 60))
points(colMeans(log2(assay(res_pos, "raw")), na.rm = TRUE), type = "l")
grid(nx = NA, ny = NULL)
```

In the plot above, we find the samples with lower intensity signals that we
also found in the preprocessing step: in these samples considerably less peaks
were identified; the mean intensity of these samples, though, is comparable to
that of the others.

Plasma samples (blue) have less valid values for features compared to samples
from other sources. Some of the RBC (red) samples also have a considerably lower
number of detected features. The distribution of feature intensities seems to
be comparable between samples, sources and batches. The high similarity of
average abundances between samples visible above might however be misleading,
since only signal from identified peaks are considered. Comparing signal
intensities **after** filling-in missing peak data might be better, because it
also reflects the fact that some features are simply not present in the data.

Next, we show the filled-in values:

```{r raw-boxplot-only-filled, fig.path = IMAGE_PATH, fig.height = 7, fig.width = 7 * phi, fig.cap = "Number of features and log2 abundance of filled-in data.", message = FALSE, echo = FALSE}
layout(mat = matrix(1:2, ncol = 1), height = c(0.3, 0.7))
cols <- col_source[as.character(res_pos$source)]
par(mar = c(0.2, 4.5, 2, 0.5))
barplot(apply(assay(res_pos, "raw_only_filled"), MARGIN = 2,
              function(x) sum(!is.na(x))),
        col = paste0(cols, 80), ylim = c(0, 8000),
        ylab = "Features", xaxt = "n", main = "Filled-in raw data")
legend("top", horiz = TRUE, col = col_source, legend = names(col_source), lwd = 1)
par(mar = c(0.2, 4.5, 0, 0.5))
dobox(log2(assay(res_pos, "raw_only_filled")), col = paste0(cols, "ff"),
      xaxt = "n", border = paste0(cols, 60))
points(colMeans(log2(assay(res_pos, "raw_only_filled")), na.rm = TRUE),
       type = "l")
grid(nx = NA, ny = NULL)
```

We can see that there is a higher number of rescued signals in the ambiguous
samples: this indicates that a low intensity signal was probably not detected or
discarded during the course of peak detection. In this case, it is observed that
the mean abundance of these samples is lower than that of the others; this is
expected and consistent with the boxplots showed above (lower intensity for
filled-in signals).

After filling in missing peak values the proportion of detected features is
highly comparable between samples, but more differences between abundances are
visible. Plasma samples (blue) show however considerably lower signal
intensities than all other samples, which reflects that less peaks were detected
for these features in these samples (and intensities were thus filled-in).

Next we create relative log abundance plots that represent the difference of the
(log) abundances of each feature in a sample compared to the median abundance of
that feature in samples from the same sample group (source).

Finally, we plot the complete data set (detected and filled-in signals):

```{r raw-boxplot-all, fig.path = IMAGE_PATH, fig.height = 7, fig.width = 7 * phi, fig.cap = "Number of features and log2 abundance of detected and filled-in data.", message = FALSE, echo = FALSE}
layout(mat = matrix(1:2, ncol = 1), height = c(0.3, 0.7))
cols <- col_source[as.character(res_pos$source)]
par(mar = c(0.2, 4.5, 2, 0.5))
barplot(apply(assay(res_pos, "raw_filled"), MARGIN = 2,
              function(x) sum(!is.na(x))),
        col = paste0(cols, 80), ylim = c(0, 10000),
        ylab = "Features", xaxt = "n", main = "Detected and filled-in raw data")
legend("top", horiz = TRUE, col = col_source, legend = names(col_source), lwd = 1)
par(mar = c(0.2, 4.5, 0, 0.5))
dobox(log2(assay(res_pos, "raw_filled")), col = paste0(cols, "ff"), xaxt = "n",
      border = paste0(cols, 60))
points(colMeans(log2(assay(res_pos, "raw_filled")), na.rm = TRUE), type = "l")
grid(nx = NA, ny = NULL)
```

From this image, we can conclude that most of the missing signals have been
rescued during the gap-filling step: the number of features, in fact, is
comparable among all samples, though a significant signal deficiency is still
observed in the 7 samples seen before.

```{r per-feature-difference-filled-detected, message = FALSE, fig.cap = "Difference (log2 scale) of detected against filled-in signal.", fig.path = IMAGE_PATH, fig.height = 5, fig.width = 5, echo = FALSE}
is_QC <- res_pos$sample == "POOL"
M_QC <- numeric(nrow(assay(res_pos, "raw_only_filled")))
names(M_QC) <- rownames(res_pos)
for (i in seq_along(M_QC))
    M_QC[i] <- log2(mean(assay(res_pos, "raw")[i, is_QC], na.rm = TRUE)) -
        log2(mean(assay(res_pos, "raw_only_filled")[i, is_QC], na.rm = TRUE))
boxplot(M_QC, ylab = expression(log[2](detected/filled)))
grid(nx = NA, ny = NULL)
```

On average, detected peak signals are twice as high as filled-in peak
signals. For 75% of the features detected peak signals are less than 4-fold
higher than filled in signals. This suggests that filled-in data does to some
extend represent signal from the ion, but mostly underestimates the *real*
signal.

We also plot the Relative Log Abundance (RLA) values for the raw data and for
data after gap filling; these will be later used to assess the efficiency of
normalization.

```{r r raw-rla-plot, fig.path = IMAGE_PATH, fig.height = 7, fig.width = 7 * phi, fig.cap = "Relative Log Abundance (RLA) of raw data compared to the filled-in data.", echo = FALSE}
## RLA of raw data
par(mfrow = c(2, 1), mar = c(0.2, 4.5, 4.5, 0.5))
boxplot(xcms::rowRla(assay(res_pos, "raw"), group = res_pos$source),
        cex = 0.5, pch = 16, col = col_source[as.character(res_pos$source)],
        border = paste0(col_source[as.character(res_pos$source)], 40),
        notch = TRUE, outline = FALSE, ylim = c(-6, 4),
        main = "Raw data", xaxt = "n", ylab = "RLA")
grid(nx = NA, ny = NULL)
## RLA after filling-in missing data
boxplot(xcms::rowRla(assay(res_pos, "raw_filled"), group = res_pos$source),
        cex = 0.5, pch = 16, col = col_source[as.character(res_pos$source)],
        border = paste0(col_source[as.character(res_pos$source)], 40),
        notch = TRUE, outline = FALSE,
        main = "Filled-in data", xaxt = "n", ylab = "RLA")
grid(nx = NA, ny = NULL)
```


The RLA plot showing the raw data indicates some potentially systematic drifts in signal
intensities that includes also consistently lower average RLA values in the
last samples from the first, and consistently higher average RLA values in the
last samples from the second batch. Next we plot the RLA plots after filling-in
missing peak data. 

The RLA plots after filling-in missing peak data look similar but the trends
become more pronounced.

At last we plot the average abundances per sample separately for the 4 sources
to see whether the drift is independent of the sample source.

```{r rla-split-source-plot, message = FALSE, echo = FALSE, fig.cap = "Plot of per-source average (mean) RLA values per sample.", fig.path = IMAGE_PATH, fig.width = 10, fig.height = 6}
crlas <- colMeans(rowRla(assay(res_pos, "raw_filled"), data_pos$source),
                  na.rm = TRUE)
injidx <- data_pos$inj_idx
injidx[data_pos$batch == 1022018] <- injidx[data_pos$batch == 1022018] + 100

par(mfrow = c(5, 1), mar = c(0.2, 4.5, 0.7, 0.5))
X <- injidx[data_pos$source == "all"]
Y <- crlas[data_pos$source == "all"]
plot(X, xlim = range(injidx), Y, col = col_source["all"], pch = 16,
     ylab = "RLA", xaxt = "n", type = "b", main = "Pool")
grid()
abline(v = 100.5, col = "grey")
X <- injidx[data_pos$source == "RBC"]
Y <- crlas[data_pos$source == "RBC"]
plot(X, xlim = range(injidx), Y, col = col_source["RBC"], pch = 16,
     ylab = "RLA", xaxt = "n", type = "b", main = "RBC")
grid()
abline(v = 100.5, col = "grey")
X <- injidx[data_pos$source == "plasma"]
Y <- crlas[data_pos$source == "plasma"]
plot(X, xlim = range(injidx), Y, col = col_source["plasma"], pch = 16,
     ylab = "RLA", xaxt = "n", type = "b", main = "plasma")
grid()
abline(v = 100.5, col = "grey")
X <- injidx[data_pos$source == "capillary"]
Y <- crlas[data_pos$source == "capillary"]
plot(X, xlim = range(injidx), Y, col = col_source["capillary"], pch = 16,
     ylab = "RLA", xaxt = "n", type = "b", main = "capillary")
grid()
abline(v = 100.5, col = "grey")
X <- injidx[data_pos$source == "venous"]
Y <- crlas[data_pos$source == "venous"]
plot(X, xlim = range(injidx), Y, col = col_source["venous"], pch = 16,
     ylab = "RLA", xaxt = "n", type = "b", main = "venous")
grid()
abline(v = 100.5, col = "grey")
```

The trend seen on QC pools seems, to some extend, also be present in venous
blood samples and plasma blood samples. RBC and capillary samples show a higher
variability. Over and above it seems also that the samples from the second batch
have slightly higher abundances.


## Internal standards

Internal standards are chemical species that resemble molecules in a sample, but
they have a distinct characteristic that helps us discriminate them from the
metabolites of interest (i.e. these internal standards are artificially modified
metabolites not occurring in a normal human sample). Internal standards are
added in the sample mix before data acquisition.

In the chunk code below, we load the table with the internal standards and their
expected mass-to-charge ratio m/z. Features detected at these m/z that also have
a retention time within a range of 30 seconds from the internal standard of
reference are then identified and their ID is added to the table.

```{r internal-standards-read, message = FALSE, warning = FALSE}
library(Rdisop)
#library(CompoundDb)
library("MetaboCoreUtils")
is_info <- read.table(
    "https://raw.githubusercontent.com/EuracBiomedicalResearch/lcms-standards/master/data/internal_standards.txt",
    sep = "\t", header = TRUE, as.is = TRUE)
is_info <- is_info[!is.na(is_info$POS), ]
is_info$class <- "IS"
is_info$mzneut = NA
is_info$mz_ion = NA
for (i in seq(nrow(is_info))) {
    if (grepl("C", is_info$formula[i])){
        is_info$mzneut[i] <- getMolecule(
            as.character(is_info$formula[i]))$exactmass
    } else {
        is_info$mzneut[i] = as.numeric(is_info$formula[i])
    }
    #' Calculate also the m/z
    is_info$mz_ion[i] <- MetaboCoreUtils::mass2mz(
        is_info$mzneut[i], adduct = is_info$POS[i])[1, 1]
}
is_info <- is_info[!is.na(is_info$mz_ion), ]
```

We plot now the EIC for each identified internal standard:

```{r internal-standards-plot, echo = FALSE, message = FALSE, warning = FALSE}
#' For each internal standard, try to find features that overlap the m/z
#' and are close to the expected retention time.
rt_tol <- 30
is_info$feature_id <- NA_character_
for (i in seq_len(nrow(is_info))) {
    fts <- featureDefinitions(data_pos, mz = is_info$mz_ion[i], ppm = 50)
    if (nrow(fts)) {
        rtdiff <- abs(fts$rtmed - is_info$RT[i])
        keep <- rtdiff < rt_tol
        if (sum(keep) == 1)
            is_info$feature_id[i] <- rownames(fts)[keep]
    }
}
is_info <- is_info[!is.na(is_info$feature_id), ]

is_info_features <- featureChromatograms(
    data_pos, features = is_info$feature_id, expandRt = 5)

#' Plot the features for the internal standards.
col <- col_source[as.character(data_pos$source)]

dr <- paste0(IMAGE_PATH, "internal-standards/")
dir.create(dr, showWarnings = FALSE)
for (i in seq_len(nrow(is_info))) {
    fn <- gsub("%", "", paste0(dr, "IS_", is_info[i, "name"], "_POS.png"))
    chr <- is_info_features[i, ]
    cls <- col[chromPeaks(chr)[, "sample"]]
    png(fn, width = 16, height = 8, units = "cm", res = 200, pointsize = 4)
    plot(chr, peakBg = paste0(cls, 20),
         main = paste0(is_info$name[i], ": ",
                       format(mz(chr)[1], digits = 6), "-",
                       format(mz(chr)[2], digits = 6)),
         peakCol = paste0(cls, 60))
    abline(v = is_info$RT[i], lty = 2)
    dev.off()
}

```

All features possibly related to internal standards (i.e. with a matching m/z
and a retention time within 30 seconds to the expected one) have been manually
evaluated and only features have been assigned to internal standards if the
signal was unambiguous. Some features for internal standards have been removed
if a very strong matrix dependent intensity difference was apparent.

The plots of three internal standards, L-Cystine, L-Methionine and 
L-Phenylalanine don't look good, therefore we want to exclude those.
Also, we create two subsets of internal standards, one with "problematic"" ones
according to the created plots and the other with the "good" ones.

```{r subsetting IS}
is_std_prob <- subset(is_info, is_info$feature_id %in% c('FT0375','FT0063',
                                                         'FT0088', 'FT0191'))
is_std = subset(is_info, !(is_info$feature_id %in% c('FT0375','FT0063',
                                                    'FT0088', 'FT0191','FT0548',
                                                    'FT0315','FT0249')))
table(is_std$name)

```

The table below lists the problmatic and unproblematicinternal standards and 
their assigned feature with mean abundance and its standard deviation.

```{r}
#' table of internal standards with mean and sd of abundances (in log2 scale)
tmp_fv <- assay(res_pos, "raw")[is_std$feature_id, ]
is_std$mean_abd <- rowMeans(log2(tmp_fv), na.rm = TRUE)
is_std$sd_abd <- rowSds(log2(tmp_fv), na.rm = TRUE)
is_std$RSD <- rowRsd(tmp_fv, na.rm = TRUE)

tmp_fv <- assay(res_pos, "raw")[is_std_prob$feature_id, ]
is_std_prob$mean_abd <- rowMeans(log2(tmp_fv), na.rm = TRUE)
is_std_prob$sd_abd <- rowSds(log2(tmp_fv), na.rm = TRUE)
is_std_prob$RSD <- rowRsd(tmp_fv, na.rm = TRUE)

cpt <- paste("Internal standards with detected and assigned features, mean and",
             "standard deviation of (log2) abundance and RSD.")
pandoc.table(is_std[, c("name", "mean_abd", "sd_abd", "RSD")],
             style = "rmarkdown", caption = cpt)
pandoc.table(is_std_prob[, c("name", "mean_abd", "sd_abd", "RSD")],
             style = "rmarkdown", caption = cpt)
```



# Between-sample normalization

Between-sample normalization aims to remove global abundance differences between
samples due to variations in sample collection, extraction, processing and
possibly amount. The simplest approach is to normalize abundances based on the
total sum of the signal or its median. Such approaches rely however on the
self-averaging property assuming that an increase in abundances of a group of
metabolites is balanced by a decrease in abundances in another group
[@Livera:2015bo]. Also, these approaches tend to be biased by highly abundant
metabolites. Methods robust against such a bias, like the median ratio method
(MRM [@Anders:2010fu]) or the trimmed mean of M-values (TMM [@Robinson:2010dd])
used in RNAseq data normalization could be used instead. Note that we did
exclude the TMM from our analyses due to the lower performance compared to the
MRM.

Alternatively, we will evaluate also the performance of RUV [@Livera:2015bo]
which requires however internal standards (or metabolites correlating with their
abundance) to estimate the technical variance in the data and the NOMIS method
[@SysiAho:2007bt] that normalizes features by *their best internal standard*.

Note that, since the internal standards were added before sample preparation,
but after sample collection and extraction, they can only assess
sample-preparation related effects.

Below we calculate normalization factors based on the total sum of the signal,
the median abundance per sample and using the MRM and TMM methods. The
calculations are based on abundances of detected peaks (i.e. excluding filled-in
peak data). Subsequently we normalize the feature abundance (also of filled-in
and imputed signal) based on the estimated sample-wise normalization factors.

```{r estimate-norm-factors, echo = TRUE, message = FALSE}
## Calculate median and scaling factors
mdns <- apply(assay(res_pos, "raw_filled"), MARGIN = 2, median, na.rm = TRUE)
nf_mdn <- mdns / median(mdns)
```

```{r normalization, echo = TRUE, message = FALSE}
## Perform normalization
assays(res_pos)$median_filled <- sweep(assay(res_pos, "raw_filled"),
                                       MARGIN = 2, nf_mdn, `/`)
```

We plot boxplots showing the data before and after between-sample normalization
to evaluate the outcome of the procedure:

```{r norm-boxplot-raw-median, fig.path = IMAGE_PATH, fig.height = 7, fig.width = 7, fig.cap = "Comparison of the boxplots before and after normalization by the median.", echo = FALSE, message = FALSE}
## Raw data_pos
par(mfrow = c(2, 1), mar = c(0.2, 4.5, 4.5, 0.5))
cols <- col_source[as.character(res_pos$source)]
## Before between-sample normalization
dobox(log2(assay(res_pos, "raw_filled")), col = paste0(cols, "ff"),
      xaxt = "n", border = paste0(cols, 60),
      main = "Before between-sample normalization")
points(colMeans(log2(assay(res_pos, "raw_filled")), na.rm = TRUE), type = "l")
grid(nx = NA, ny = NULL)

## After normalization by median
dobox(log2(assay(res_pos, "median_filled")), col = paste0(cols, "ff"),
      xaxt = "n", border = paste0(cols, 60),
      main = "After normalization by median")
points(colMeans(log2(assay(res_pos, "median_filled")), na.rm = TRUE),
       type = "l")
grid(nx = NA, ny = NULL)
```

We can now see that the median is the same across the whole range of samples,
thus concluding that this first step of normalization worked as desired.

We also generate RLA plots:

```{r norm-rla-plot, fig.path = IMAGE_PATH, fig.height = 7, fig.width = 7, fig.cap = "Comparison of RLA values before and after before and after normalization by the median.", message = FALSE, echo = FALSE}
## RLA for median normalization
par(mfrow = c(2, 1), mar = c(0.2, 4.5, 4.5, 0.5))
boxplot(xcms::rowRla(assay(res_pos, "raw_filled"), group = res_pos$source),
        cex = 0.5, pch = 16, col = col_source[as.character(res_pos$source)],
        border = paste0(col_source[as.character(res_pos$source)], 40),
        notch = TRUE, outline = FALSE, ylim = c(-7, 5),
        xaxt = "n", ylab = "RLA", main = "Before between-sample normalization")
grid(nx = NA, ny = NULL)
boxplot(xcms::rowRla(assay(res_pos, "median_filled"), group = res_pos$source),
        cex = 0.5, pch = 16, col = col_source[as.character(res_pos$source)],
        border = paste0(col_source[as.character(res_pos$source)], 40),
        notch = TRUE, outline = FALSE, ylim = c(-7, 5),
        xaxt = "n", ylab = "RLA", main = "After normalization by median")
grid(nx = NA, ny = NULL)
```

From the plot above, we can see that the normalization step performed so far
greatly helped in reducing variability, especially for the four problematic
samples.

# Within-batch normalization

Next we perform a within-batch normalization to remove potential injection order
dependent signal drifts. In order to define whether there is a similar injection
order dependent signal drift in each batch (i.e. the drift is independent of the
batch) we fit feature-wise linear models to the (log2 transformed) data of QC
samples within each batch and compare the slopes for each feature between the
batches. 

Note that the models describing the batch effect and injection dependent signal
drift is estimated on the detected peak data, i.e. prior to filling-in missing
peak data.

Within-batch normalization is useful to remove injection-order-dependent signal
drifts: these discrepancies arise in the course of the analysis because the
intensity of the signal detected by the instrument changes with time
[@Wehrens:2016ie]. While the exact reason of this drift is unknown, it seems to
affect individual features differently.
Many algorithms have been developed to solve this problem, the best choice depends
on the type of data collected: internal standards, quality control samples
(POOL), study samples or quality control metabolites [@Livera:2015bo].
For our analysis, we assume a log-linear time-dependent signal drift, thus we
have tried to fit three different subsets to the linear model `y ~ inj_idx`, to
find the better fit, based on the relative standard deviation (RSD). More
precisely, we tried to fit only the intensities of the detected features in the
POOL samples, then we tried to fit all the features of the POOL samples
(detected and filled-in) and finally we fit all the collected signals (i.e. POOL
and study samples). The best result was obtained using only the detected POOL
subset, which has been therefore used for further normalizing the data. Since
abundances in POOL samples are not expected to differ between injections, we can
also safely assume that any changes seen on them are due to technical
variance. We are thus estimating the signal drift on the POOL samples and
adjusting the study samples accordingly, assuming that the same bias affects
their feature abundance.

We also define below the variable `req_prop` to set the minimum range that the
injection indices must span to consider a fitting valid.

In a first try we used only POOL samples for the fitting of the normalization
model, whereas in this approach we use all samples.

```{r fit-model-plate, message = FALSE, warning = FALSE, echo = TRUE}
tmp_a <- res_pos[, res_pos$batch == "31012018"]
tmp <- log2(assay(tmp_a, "median_filled"))
tmp[is.na(assay(tmp_a, "raw"))] <- NA
mdls_a <- xcms:::rowFitModel(
                   y ~ inj_idx,
                   data = as.data.frame(
                          colData(tmp_a)),
                   y = tmp,
                   method = "lm",
                   minVals = 60)
req_prop <- 3/4
```


```{r fit-model-plate 2, message = FALSE, warning = FALSE, echo = TRUE}
tmp_b <- res_pos[, res_pos$batch == "01022018"]
tmp <- log2(assay(tmp_b, "median_filled"))
tmp[is.na(assay(tmp_b, "raw"))] <- NA
mdls_b <- xcms:::rowFitModel(
                   y ~ inj_idx,
                   data = as.data.frame(
                          colData(tmp_b)),
                   y = tmp,
                   method = "lm",
                   minVals = 60)
req_prop <- 3/4
```


```{r estimate-slopes-per-batch, message = FALSE, warning = FALSE, fig.path = IMAGE_PATH, fig.cap = "Plot of per-feataure estimates for the injection order dependent signal drift from the two batches.", fig.width = 6, fig.height = 6, echo = FALSE}
#smps <- res_pos$batch == "31012018" & res_pos$source == "all"
#lm_btch1 <- xcms:::rowFitModel(
#                       y ~ inj_idx,
 #                      y = log2(assay(res_pos, "norm_nofill")[, smps]),
 #                      method = "lmrob",
 #                      data = data.frame(inj_idx = res_pos$inj_idx[smps]))
#smps <- res_pos$batch == "01022018" & res_pos$source == "all"
#lm_btch2 <- xcms:::rowFitModel(
 #                      y ~ inj_idx,
 #                      y = log2(assay(res_pos, "norm_nofill")[, smps]),
  #                     method = "lmrob",
  #                     data = data.frame(inj_idx = res_pos$inj_idx[smps]))

slps_btch1 <- vapply(mdls_a, function(z)
    ifelse(any(!is.na(z)), z$coefficients[2], NA_real_), numeric(1))
slps_btch2 <- vapply(mdls_b, function(z)
    ifelse(any(!is.na(z)), z$coefficients[2], NA_real_), numeric(1))

plot(slps_btch1, slps_btch2, pch = 16, col = "#00000040", xlab = "batch 1",
     ylab = "batch 2", main = "slopes")
grid()
lmod <- lm(slps_btch2 ~ slps_btch1)
abline(lmod, lty = 2)
```

Not unexpectedly, there is only a very low correlation of the slopes between the
batches suggesting that the injection dependent signal drift is for the most
part batch dependent. If the model is fitted to all values, a higher correlation
can however be observed (data not shown).

In this case, we set `req_prop` to `r req_prop`, meaning that the injection
range of the signals used in the fitting must span at least `r req_prop * 100`%
of the total injection range; the features for which this is not valid will be
then removed.

Next, we calculate the slopes for each fitting and plot their distribution; we
highlight in blue the slopes of the features calculated with a low injection
range.

```{r within-norm-slope-dist, fig.path = IMAGE_PATH, fig.height = 5, fig.width = 5, fig.cap = "Distribution of slopes.", message = FALSE, echo = FALSE}
## Calculating flags
flgs_inj_range_a <- vapply(mdls_a, flag_model_inj_range, logical(1),
                         min_range = diff(range(tmp_a$inj_idx)) * req_prop)
flgs_inj_range_b <- vapply(mdls_b, flag_model_inj_range, logical(1),
                         min_range = diff(range(tmp_b$inj_idx)) * req_prop)

## Calculate slopes for
slps_a <- vapply(mdls_a, function(z) {
    if (length(z) > 1) {
        coefficients(z)[2]
    } else NA_real_
}, numeric(1))

slps_b <- vapply(mdls_b, function(z) {
    if (length(z) > 1) {
        coefficients(z)[2]
    } else NA_real_
}, numeric(1))

## Plot the distribution of slopes.
par(mfrow = c(1, 2), mar = c(4, 4.5, 1, 0.5))
hist(slps_a, breaks = 128, xlab = "slope", main = "Distribution of slopes")
hist(slps_a[which(flgs_inj_range_a)], breaks = 128, add = TRUE,
     col = "#0000ff80")
par(mar = c(4, 4.5, 1, 0.5))
hist(slps_b, breaks = 128, xlab = "slope", main = "Distribution of slopes")
hist(slps_b[which(flgs_inj_range_b)], breaks = 128, add = TRUE,
     col = "#0000ff80")
## Split into excluded and good mdls
mdls_inj_range_a <- mdls_a[which(flgs_inj_range_a)]
mdls_inj_range_b <- mdls_b[which(flgs_inj_range_b)]
## Remove model fits for the flagged friends.
mdls_a[unique(which(flgs_inj_range_a))] <- NA
slps_a[unique(which(flgs_inj_range_a))] <- NA
mdls_b[unique(which(flgs_inj_range_b))] <- NA
slps_b[unique(which(flgs_inj_range_b))] <- NA
## Identify the features that are adjusted
#fts_adj_a <- sort(unique(c(
#    names(mdls_a)[!is.na(mdls)],
#    names(mdls_a)[!is.na(mdls)],
#    names(mdls_a)[!is.na(mdls)]
#)))
#fts_adj_b <- sort(unique(c(
#    names(mdls_b)[!is.na(mdls)],
#    names(mdls_b)[!is.na(mdls)],
#    names(mdls_b)[!is.na(mdls)]
#)))
```
Most of the slopes, that represent the estimated injection order-dependent
signal drift, are close to 0 suggesting most features not being affected by this
bias. Note that the *injection index range filter* removed more models/fits in
batch a than in batch b.


The table below lists the number of features for which the model was fitted and
the number of features for which model fitting was skipped or discarded.

```{r fit-model-table, message = FALSE, echo = FALSE, results = "asis", fig.cap = "Summary of features used for the linear fitting."}
tab <- cbind(batch_a = c(length(mdls_a),
                         length(which(flgs_inj_range_a)),
                         sum(!is.na(mdls_a))),
             batch_b = c(length(mdls_b),
                         length(which(flgs_inj_range_b)),
                         sum(!is.na(mdls_b)))
             )
rownames(tab) <- c("total features", "low inj idx range",
                   "valid model fits")
cptn <- paste("Numbers of features for which an injection index dependent",
              "model could be fitted.")
pandoc.table(tab, style = "rmarkdown", caption = cptn)

```
For almost all features a model describing the injection dependent signal drift
was defined.

Most of the slopes from the models describing the injection dependent signal
drift are close to 0 suggesting only a relatively low influence. Only about 35
have a absolute slope larger than 0.025.

Next, we compute and visually inspect the plots of the features where the
absolute slope is larger than 0.025.

```{r features-large-slopes-plots, echo = FALSE, message = FALSE, warning = FALSE}
## Plotting all features with an absolute slope larger than some value.
## Plots are created but not displayed here.
## Features with absolute slope > 0.025
dr <- paste0(IMAGE_PATH, "largest_slopes_a/")
dir.create(dr, showWarnings = FALSE)
fts <- names(mdls_a)[which(abs(slps_a) > 0.025)]
plot_feature <- function(x, y, model, ...) {
  plot(x, y, ...)
  if (length(model) > 1)
    abline(model)
  grid()
}
plot_slopes <- function(x,y ) {
  for (ft in fts) {
    png(paste0(dr, ft, ".png"), width = 14, height = 7, pointsize = 4,
        res = 200, units = "cm")
    plot_feature(x = x$inj_idx,
                 y = log2(assay(x, "median_filled")[ft, ]),
                 model = y[[ft]],
                 pch = ifelse(is.na(assay(x, "raw")[ft, ]),
                              yes = 1, no = 16),
                 col = col_source[as.character(x$source)], main = ft,
                 xaxt = "n", xlab = "", ylab = expression(log[2]~abundance))
    dev.off()
  }
}
plot_slopes(tmp_a, mdls_a)
dr <- paste0(IMAGE_PATH, "largest_slopes_b/")
dir.create(dr, showWarnings = FALSE)
fts <- names(mdls_b)[which(abs(slps_b) > 0.025)]
plot_slopes(tmp_b, mdls_b)

```

From the plotted slopes, we can conclude that not in all cases the fitting
is a good representation of features in study samples. An example is the feature
FT1250: we can see that the abundance of the POOL samples differs a lot from the
abundance of the study samples and the regression line does not follow their
trend.


```{r features-large-r-squared, echo = FALSE, message = FALSE, warning = FALSE}
#' Plot features with largest or smallest R squared.

#' Calculate adjusted R squared
adjr_a <- vapply(mdls_a, function(z) {
    if (length(z) > 1)
        summary(z)$adj.r.squared
    else NA_real_
}, numeric(1))
adjr_b <- vapply(mdls_b, function(z) {
    if (length(z) > 1)
        summary(z)$adj.r.squared
    else NA_real_
}, numeric(1))


#' Features with poor R2
fts <- names(sort(abs(adjr_a)))[1:20]
dr <- paste0(IMAGE_PATH, "lowest_R_batch_a/")
dir.create(dr, showWarnings = FALSE)
for (ft in fts) {
    png(paste0(dr, ft, ".png"), width = 14, height = 7, pointsize = 6,
        res = 200, units = "cm")
    plot_feature_slopes_batch(y = log2(assay(res_pos, "median_filled")[ft, ]),
                              is_filled = is.na(assay(res_pos, "raw")[ft, ]),
                              data = as.data.frame(colData(res_pos)),
                              lmoda = mdls_a[[ft]],
                              lmodb = mdls_b[[ft]], main = ft)
    dev.off()
}
fts <- names(sort(abs(adjr_b)))[1:20]
dr <- paste0(IMAGE_PATH, "lowest_R_batch_b/")
dir.create(dr, showWarnings = FALSE)
for (ft in fts) {
    png(paste0(dr, ft, ".png"), width = 14, height = 7, pointsize = 6,
        res = 200, units = "cm")
    plot_feature_slopes_batch(y = log2(assay(res_pos, "median_filled")[ft, ]),
                              is_filled = is.na(assay(res_pos, "raw")[ft, ]),
                              data = as.data.frame(colData(res_pos)),
                              lmoda = mdls_a[[ft]],
                              lmodb = mdls_b[[ft]], main = ft)
    dev.off()
}
#' Mostly slope ~ 0 or those that don't fit that nicely.

#' Features with very good R2
fts_a <- names(sort(abs(adjr_a), decreasing = TRUE))[1:20]
dr <- paste0(IMAGE_PATH, "highest_R_batch_a/")
dir.create(dr, showWarnings = FALSE)
for (ft in fts_a) {
    png(paste0(dr, ft, ".png"), width = 14, height = 7, pointsize = 6,
        res = 200, units = "cm")
    plot_feature_slopes_batch(y = log2(assay(res_pos, "median_filled")[ft, ]),
                              is_filled = is.na(assay(res_pos, "raw")[ft, ]),
                              data = as.data.frame(colData(res_pos)),
                              lmoda = mdls_a[[ft]],
                              lmodb = mdls_b[[ft]], main = ft)
    dev.off()
}
fts_b <- names(sort(abs(adjr_b), decreasing = TRUE))[1:20]
dr <- paste0(IMAGE_PATH, "highest_R_batch_b/")
dir.create(dr, showWarnings = FALSE)
for (ft in fts_b) {
    png(paste0(dr, ft, ".png"), width = 14, height = 7, pointsize = 6,
        res = 200, units = "cm")
    plot_feature_slopes_batch(y = log2(assay(res_pos, "median_filled")[ft, ]),
                              is_filled = is.na(assay(res_pos, "raw")[ft, ]),
                              data = as.data.frame(colData(res_pos)),
                              lmoda = mdls_a[[ft]],
                              lmodb = mdls_b[[ft]], main = ft)
    dev.off()
}
#' Mostly fits to data in a single matrix
```

Some examples for nice model fits for features with large injection order
dependent drifts are shown below.

```{r out.width = "750px", echo = FALSE}
knitr::include_graphics(paste0(IMAGE_PATH, "highest_R_batch_a/",
                               fts_a[1], ".png"))
```

```{r out.width = "750px", echo = FALSE}
knitr::include_graphics(paste0(IMAGE_PATH, "highest_R_batch_b/",
                              fts_b[1], ".png"))
```

```{r features-excluded-inj-range, echo = FALSE, warning = FALSE, message = FALSE}
#' Plot data for features excluded because their data points do not span a
#' large enough portion of the injection range.
#' Identify top 20 with largest slopes
tmp_slps <- vapply(mdls_inj_range_a, function(z) {
    coefficients(z)[2]
}, numeric(1))
fts_a <- names(sort(abs(tmp_slps), decreasing = TRUE))[1:20]
dr <- paste0(IMAGE_PATH, "largest_slopes_batch_a_inj_range_excluded/")
dir.create(dr, showWarnings = FALSE)
for (ft in fts_a) {
    png(paste0(dr, ft, ".png"), width = 14, height = 7, pointsize = 6,
        res = 200, units = "cm")
    plot_feature_slopes_batch(y = log2(assay(res_pos, "median_filled")[ft, ]),
                              is_filled = is.na(assay(res_pos, "raw")[ft, ]),
                              data = as.data.frame(colData(res_pos)),
                              lmoda = mdls_inj_range_a[[ft]],
                              lmodb = mdls_inj_range_b[[ft]], main = ft)
    dev.off()
}
tmp_slps <- vapply(mdls_inj_range_b, function(z) {
    coefficients(z)[2]
}, numeric(1))
fts_b <- names(sort(abs(tmp_slps), decreasing = TRUE))[1:20]
dr <- paste0(IMAGE_PATH, "largest_slopes_batch_b_inj_range_excluded/")
dir.create(dr, showWarnings = FALSE)
for (ft in fts_b) {
    png(paste0(dr, ft, ".png"), width = 14, height = 7, pointsize = 6,
        res = 200, units = "cm")
    plot_feature_slopes_batch(y = log2(assay(res_pos, "median_filled")[ft, ]),
                              is_filled = is.na(assay(res_pos, "raw")[ft, ]),
                              data = as.data.frame(colData(res_pos)),
                              lmoda = mdls_inj_range_a[[ft]],
                              lmodb = mdls_inj_range_b[[ft]], main = ft)
    dev.off()
}
#' These are for the most part disastrous. Some seem to follow the overall data
#' trend (mostly those with small slopes) but it is still better to remove
#' model fits that span only a limited injection index range.
```

Examples for linear models that were **excluded** because of a too small range
of injection indices are shown below.

```{r out.width = "750px", echo = FALSE}
knitr::include_graphics(
           paste0(IMAGE_PATH,
                  "largest_slopes_batch_a_inj_range_excluded/",
                  fts_a[1], ".png"))
```	

```{r out.width = "750px", echo = FALSE}
knitr::include_graphics(
           paste0(IMAGE_PATH,
                  "largest_slopes_batch_b_inj_range_excluded/",
                  fts_b[1], ".png"))
```	

Next we apply the within batch correction adjusting all feature abundances (also
filled-in and imputed values) based on the estimated models. Adjustment resulted
in measurements with negative (log2) abundances. These were replaced by half
of the minimum non negative intensity for that feature. Note however that quite
some log2 abundances are smaller than 1, which represents negative intensities
in natural scale.

```{r apply-within-batch-adjustment, message = FALSE, warning = FALSE}
#' Applying the adjustment to the full (filled-in) data.
tmp <- assay(res_pos, "median_filled")
norm_before <- tmp
tmp[, colnames(tmp_a)] <- xcms:::applyModelAdjustment(
                             y = log2(assay(tmp_a, "median_filled")),
                             lmod = mdls_a,
                             data = as.data.frame(colData(tmp_a)),
                             shiftNegative = "replaceHalfMin")
tmp[, colnames(tmp_b)] <- xcms:::applyModelAdjustment(
                               y = log2(assay(tmp_b, "median_filled")), 
                               lmod = mdls_b,
                               data = as.data.frame(colData(tmp_b)),
                               shiftNegative = "replaceHalfMin")
assays(res_pos)$normalized_filled <- 2^tmp
tmp[is.na(assay(res_pos, "raw"))] <- NA
assays(res_pos)$normalized_nofill <- 2^tmp

rm(tmp)
```



# Final evaluation

We compare now the performances of the normalization steps, first plotting the
distribution of signal intensities of the filled-in raw data, the median-scaled
data and the normalized data.

```{r boxplot-after-within-normalization, fig.path = IMAGE_PATH, fig.height = 7, fig.width = 7, fig.cap = "Comparison between abundances (log2) of raw data, median-scaled data and normalized data.", message = FALSE, echo = FALSE}
##Raw data
par(mfrow = c(3, 1), mar = c(0.2, 4.5, 4.5, 0.5))
cols <- col_source[as.character(res_pos$source)]
dobox(log2(assay(res_pos, "raw_filled")), col = paste0(cols, "ff"),
      xaxt = "n", border = paste0(cols, 60), main = "Raw data")
points(colMeans(log2(assay(res_pos, "raw_filled")), na.rm = TRUE), type = "l")
grid(nx = NA, ny = NULL)
## Median normalized
dobox(log2(assay(res_pos, "median_filled")), col = paste0(cols, "ff"),
      xaxt = "n", border = paste0(cols, 60), main = "Median-scaled data")
points(colMeans(log2(assay(
                     res_pos, "median_filled")), na.rm = TRUE), type = "l")
grid(nx = NA, ny = NULL)
## Final normalized data
dobox(log2(assay(res_pos, "normalized_filled")), col = paste0(cols, "ff"),
      xaxt = "n", border = paste0(cols, 60), main = "Normalized data")
points(colMeans(log2(assay(res_pos, "normalized_filled")), na.rm = TRUE),
       type = "l")
grid(nx = NA, ny = NULL)
```

From the plots, we can see that most of the improvement comes from the
normalization by the median; only a few slight changes are visible after the
linear fitting.

Next, we plot the same boxplots calculated only on the internal standards:

```{r boxplot-after-within-norm-is, fig.path = IMAGE_PATH, fig.height = 7, fig.width = 7, fig.cap = "Comparison between abundances (log2) of raw data, median-scaled data and normalized data of Internal Standards.", message = FALSE, echo = FALSE}
##Raw data
par(mfrow = c(3, 1), mar = c(0.2, 4.5, 4.5, 0.5))
cols <- col_source[as.character(res_pos$source)]
tmp <- assay(res_pos, "raw_filled")[is_info$feature_id, ]
dobox(log2(tmp), col = paste0(cols, "ff"), notch = FALSE,
      xaxt = "n", border = paste0(cols, 60), main = "Raw data - IS")
points(colMeans(log2(tmp), na.rm = TRUE), type = "l")
grid(nx = NA, ny = NULL)
## Median normalized
tmp <- assay(res_pos, "median_filled")[is_info$feature_id, ]
dobox(log2(tmp), col = paste0(cols, "ff"), notch = FALSE,
      xaxt = "n", border = paste0(cols, 60), main = "Median-scaled data - IS")
points(colMeans(log2(tmp), na.rm = TRUE), type = "l")
grid(nx = NA, ny = NULL)
## Final normalized data
tmp <- assay(res_pos, "normalized_filled")[is_info$feature_id, ]
dobox(log2(tmp), col = paste0(cols, "ff"), notch = FALSE,
      xaxt = "n", border = paste0(cols, 60), main = "Normalized data - IS")
points(colMeans(log2(tmp), na.rm = TRUE), type = "l")
grid(nx = NA, ny = NULL)
```

For IS, the normlization seems not to work well. We now have a look at the 
difference between the problematic an unproblematic internal standards.

```{r}
##Raw data
par(mfrow = c(3, 1), mar = c(0.2, 4.5, 4.5, 0.5))
cols <- col_source[as.character(res_pos$source)]
tmp <- assay(res_pos, "raw_filled")[is_std$feature_id, ]
dobox(log2(tmp), col = paste0(cols, "ff"), notch = FALSE,
      xaxt = "n", border = paste0(cols, 60), main = "Raw data - unprob. IS")
points(colMeans(log2(tmp), na.rm = TRUE), type = "l")
grid(nx = NA, ny = NULL)
## Median normalized
tmp <- assay(res_pos, "median_filled")[is_std$feature_id, ]
dobox(log2(tmp), col = paste0(cols, "ff"), notch = FALSE,
      xaxt = "n", border = paste0(cols, 60), main = "Median-scaled data - unprob. IS")
points(colMeans(log2(tmp), na.rm = TRUE), type = "l")
grid(nx = NA, ny = NULL)
## Final normalized data
tmp <- assay(res_pos, "normalized_filled")[is_std$feature_id, ]
dobox(log2(tmp), col = paste0(cols, "ff"), notch = FALSE,
      xaxt = "n", border = paste0(cols, 60), main = "Normalized data - unprob. IS")
points(colMeans(log2(tmp), na.rm = TRUE), type = "l")
grid(nx = NA, ny = NULL)
```

```{r}
##Raw data
par(mfrow = c(3, 1), mar = c(0.2, 4.5, 4.5, 0.5))
cols <- col_source[as.character(res_pos$source)]
tmp <- assay(res_pos, "raw_filled")[is_std_prob$feature_id, ]
dobox(log2(tmp), col = paste0(cols, "ff"), notch = FALSE,
      xaxt = "n", border = paste0(cols, 60), main = "Raw data - problematic IS")
points(colMeans(log2(tmp), na.rm = TRUE), type = "l")
grid(nx = NA, ny = NULL)
## Median normalized
tmp <- assay(res_pos, "median_filled")[is_std_prob$feature_id, ]
dobox(log2(tmp), col = paste0(cols, "ff"), notch = FALSE,
      xaxt = "n", border = paste0(cols, 60), main = "Median-scaled data - problematic IS")
points(colMeans(log2(tmp), na.rm = TRUE), type = "l")
grid(nx = NA, ny = NULL)
## Final normalized data
tmp <- assay(res_pos, "normalized_filled")[is_std_prob$feature_id, ]
dobox(log2(tmp), col = paste0(cols, "ff"), notch = FALSE,
      xaxt = "n", border = paste0(cols, 60), main = "Normalized data -problematic IS")
points(colMeans(log2(tmp), na.rm = TRUE), type = "l")
grid(nx = NA, ny = NULL)
```


Next, we plot the RLA of the whole dataset and of the internal standards to
confirm the current hypotheses:

```{r rla-after-between-normalization, fig.path = IMAGE_PATH, fig.height = 7, fig.width = 7, fig.cap = "RLA of raw data, median-scaled data and normalized data.", message = FALSE, echo = FALSE}
## Raw data
par(mfrow = c(3, 1), mar = c(0.2, 4.5, 4.5, 0.5))
boxplot(xcms::rowRla(assay(res_pos, "raw_filled"), group = res_pos$sample),
        cex = 0.5, pch = 16, col = col_source[as.character(res_pos$source)],
        border = paste0(col_source[as.character(res_pos$source)], 40),
        notch = TRUE, outline = FALSE, ylim = c(-7, 5),
        xaxt = "n", ylab = "RLA", main = "Raw data")
grid(nx = NA, ny = NULL)
## Median scaled data
boxplot(xcms::rowRla(assay(res_pos, "median_filled"), group = res_pos$sample),
        cex = 0.5, pch = 16, col = col_source[as.character(res_pos$source)],
        border = paste0(col_source[as.character(res_pos$source)], 40),
        notch = TRUE, outline = FALSE, ylim = c(-7, 5),
        xaxt = "n", ylab = "RLA", main = "Median-scaled data")
grid(nx = NA, ny = NULL)
## Normalized data
boxplot(xcms::rowRla(assay(res_pos, "normalized_filled"), 
                     group = res_pos$sample),
        cex = 0.5, pch = 16, col = col_source[as.character(res_pos$source)],
        border = paste0(col_source[as.character(res_pos$source)], 40),
        notch = TRUE, outline = FALSE, ylim = c(-7, 5),
        xaxt = "n", ylab = "RLA", main = "Normalized data")
grid(nx = NA, ny = NULL)
```



```{r rla-after-within-normalization-is, fig.path = IMAGE_PATH, fig.height = 7, fig.width = 7, fig.cap = "Final RLA showing a comparison between raw data and normalized data of Internal Standards.", message = FALSE, echo = FALSE, warning = FALSE}
## Raw data
par(mfrow = c(3, 1), mar = c(1, 4.5, 4.5, 0.5))
tmp <- assay(res_pos, "raw_filled")
boxplot(xcms::rowRla(tmp[is_info$feature_id, ], group = res_pos$sample),
        cex = 0.5, pch = 16, col = col_source[as.character(res_pos$source)],
        notch = FALSE, outline = FALSE, ylim = c(-3, 1),
        xaxt = "n", ylab = "RLA", main = "Raw data - IS")
grid(nx = NA, ny = NULL)
## Median scaled data
tmp <- assay(res_pos, "median_filled")
boxplot(xcms::rowRla(tmp[is_info$feature_id, ], group = res_pos$sample),
        cex = 0.5, pch = 16, col = col_source[as.character(res_pos$source)],
        notch = FALSE, outline = FALSE, ylim = c(-3, 1),
        xaxt = "n", ylab = "RLA", main = "Median scaled - IS")
grid(nx = NA, ny = NULL)
## Normalized data
tmp <- assay(res_pos, "normalized_filled")
boxplot(xcms::rowRla(tmp[is_info$feature_id, ], group = res_pos$sample),
        cex = 0.5, pch = 16, col = col_source[as.character(res_pos$source)],
        notch = FALSE, outline = FALSE, ylim = c(-3, 1),
        xaxt = "n", ylab = "RLA", main = "Normalized data - IS")
grid(nx = NA, ny = NULL)
```


From the RLA plots we can observe the same thing seen above: most changes
occurred after normalization by the median. This is also confirmed after looking
at the RLA plot of the internal standards, which exhibit a similar behaviour.
Also the RLA plots of the internal standards show an unwnted shift after
normalization. Therefore we recreated the plot only using the unproblematic IS.

```{r rla-after-within-normalization-unproblematic is, fig.path = IMAGE_PATH, fig.height = 7, fig.width = 7 * phi, fig.cap = "Final RLA showing a comparison between raw data and normalized data of Internal Standards.", message = FALSE, echo = FALSE, warning = FALSE}
## Raw data
par(mfrow = c(3, 1), mar = c(1, 4.5, 4.5, 0.5))
tmp <- assay(res_pos, "raw_filled")
boxplot(xcms::rowRla(tmp[is_std$feature_id, ], group = res_pos$sample),
        cex = 0.5, pch = 16, col = col_source[as.character(res_pos$source)],
        notch = FALSE, outline = FALSE, ylim = c(-3, 1),
        xaxt = "n", ylab = "RLA", main = "Raw data - unproblematic IS")
grid(nx = NA, ny = NULL)
## Median scaled data
tmp <- assay(res_pos, "median_filled")
boxplot(xcms::rowRla(tmp[is_std$feature_id, ], group = res_pos$sample),
        cex = 0.5, pch = 16, col = col_source[as.character(res_pos$source)],
        notch = FALSE, outline = FALSE, ylim = c(-3, 1),
        xaxt = "n", ylab = "RLA", main = "Median scaled - unproblematic IS")
grid(nx = NA, ny = NULL)
## Normalized data
tmp <- assay(res_pos, "normalized_filled")
boxplot(xcms::rowRla(tmp[is_std$feature_id, ], group = res_pos$sample),
        cex = 0.5, pch = 16, col = col_source[as.character(res_pos$source)],
        notch = FALSE, outline = FALSE, ylim = c(-3, 1),
        xaxt = "n", ylab = "RLA", main = "Normalized data - unproblematic IS")
grid(nx = NA, ny = NULL)
```

Finally, we compute the coefficient of variation (CV or relative standard
deviation RSD) for each feature in POOL and study samples, and also for internal
standards, both in POOL and study samples. We plot then boxplots and show in a
table how the RSD changes across the different groups.

```{r RSD-POOL, message = FALSE, echo = FALSE, warning = FALSE}
## Calculate RSD on all POOL signals
rsd_raw <- rowRsd(
    assay(res_pos, "raw_filled")[, res_pos$sample == "POOL"])
rsd_scl <- rowRsd(
    assay(res_pos, "median_filled")[, res_pos$sample == "POOL"])
rsd_adj <- rowRsd(
    assay(res_pos, "normalized_filled")[, res_pos$sample == "POOL"])

## Calculate RSD only on detected POOL signals
tmp <- assay(res_pos, "raw_filled")
tmp[is.na(assay(res_pos, "raw"))] <- NA
rsd_raw_det <- rowRsd(tmp[, res_pos$sample == "POOL"])
tmp <- assay(res_pos, "median_filled")
tmp[is.na(assay(res_pos, "raw"))] <- NA
rsd_scl_det <- rowRsd(tmp[, res_pos$sample == "POOL"])
tmp <- assay(res_pos, "normalized_filled")
tmp[is.na(assay(res_pos, "raw"))] <- NA
rsd_adj_det <- rowRsd(tmp[, res_pos$sample == "POOL"])
```

```{r RSD-study-samples, message = FALSE, echo = FALSE, warning = FALSE}
## Calculate RSD on all study samples
rsd_raw_sts <- rowRsd(
    assay(res_pos, "raw_filled")[, res_pos$sample != "POOL"])
rsd_scl_sts <- rowRsd(
    assay(res_pos, "median_filled")[, res_pos$sample != "POOL"])
rsd_adj_sts <- rowRsd(
    assay(res_pos, "normalized_filled")[, res_pos$sample != "POOL"])
```

```{r RSD-internal-standards, message = FALSE, echo = FALSE, warning = FALSE}
## Calculate RSD on internal standards in POOL signals
tmp_is <- assay(res_pos, "raw_filled")[is_std$feature_id, ]
rsd_raw_is <- rowRsd(tmp_is[, res_pos$sample == "POOL"])
tmp_is <- assay(res_pos, "median_filled")[is_std$feature_id, ]
rsd_scl_is <- rowRsd(tmp_is[, res_pos$sample == "POOL"])
tmp_is <- assay(res_pos, "normalized_filled")[is_std$feature_id, ]
rsd_adj_is <- rowRsd(tmp_is[, res_pos$sample == "POOL"])

## Calculate RSD on internal standards in study samples
tmp_is <- assay(res_pos, "raw_filled")[is_std$feature_id, ]
rsd_raw_is_sts <- rowRsd(tmp_is[, res_pos$sample != "POOL"])
tmp_is <- assay(res_pos, "median_filled")[is_std$feature_id, ]
rsd_scl_is_sts <- rowRsd(tmp_is[, res_pos$sample != "POOL"])
tmp_is <- assay(res_pos, "normalized_filled")[is_std$feature_id, ]
rsd_adj_is_sts <- rowRsd(tmp_is[, res_pos$sample != "POOL"])
```

```{r norm-rsd-plot, fig.path = IMAGE_PATH, message = FALSE, echo = FALSE, fig.height = 7, fig.width = 7, fig.cap = "Coefficient Of Variation (RSD)."}
par(mfrow = c(2, 3))
boxplot(list(raw = rsd_raw, scaled = rsd_scl, normalized = rsd_adj),
        main = "All signals - POOL samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)

boxplot(list(raw = rsd_raw_det, scaled = rsd_scl_det, normalized = rsd_adj_det),
        main = "Detected signals - POOL samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)

boxplot(list(raw = rsd_raw_sts, scaled = rsd_scl_sts, normalized = rsd_adj_sts),
        main = "All signals - Study samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)

boxplot(list(raw = rsd_raw_is, scaled = rsd_scl_is, normalized = rsd_adj_is),
        main = "IS - POOL samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)

boxplot(list(raw = rsd_raw_is_sts, scaled = rsd_scl_is_sts,
             normalized = rsd_adj_is_sts),
        main = "IS - Study samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)
```

We now have a look at the venous samples: 

```{r RSD-venous, message = FALSE, echo = FALSE, warning = FALSE}
## Calculate RSD on all POOL signals
rsd_raw <- rowRsd(
    assay(res_pos, "raw_filled")[, res_pos$source == "venous"])
rsd_scl <- rowRsd(
    assay(res_pos, "median_filled")[, res_pos$source == "venous"])
rsd_adj <- rowRsd(
    assay(res_pos, "normalized_filled")[, res_pos$source == "venous"])

## Calculate RSD only on detected POOL signals
tmp <- assay(res_pos, "raw_filled")
tmp[is.na(assay(res_pos, "raw"))] <- NA
rsd_raw_det <- rowRsd(tmp[, res_pos$source == "venous"])
tmp <- assay(res_pos, "median_filled")
tmp[is.na(assay(res_pos, "raw"))] <- NA
rsd_scl_det <- rowRsd(tmp[, res_pos$source == "venous"])
tmp <- assay(res_pos, "normalized_filled")
tmp[is.na(assay(res_pos, "raw"))] <- NA
rsd_adj_det <- rowRsd(tmp[, res_pos$source == "venous"])
```

```{r RSD-study-samples venous, message = FALSE, echo = FALSE, warning = FALSE}
## Calculate RSD on all study samples
rsd_raw_sts <- rowRsd(
    assay(res_pos, "raw_filled")[, res_pos$source != "venous"])
rsd_scl_sts <- rowRsd(
    assay(res_pos, "median_filled")[, res_pos$source != "venous"])
rsd_adj_sts <- rowRsd(
    assay(res_pos, "normalized_filled")[, res_pos$source != "venous"])
```

```{r RSD-internal-standards venous, message = FALSE, echo = FALSE, warning = FALSE}
## Calculate RSD on internal standards in venous signals
tmp_is <- assay(res_pos, "raw_filled")[is_std$feature_id, ]
rsd_raw_is <- rowRsd(tmp_is[, res_pos$source == "venous"])
tmp_is <- assay(res_pos, "median_filled")[is_std$feature_id, ]
rsd_scl_is <- rowRsd(tmp_is[, res_pos$source == "venous"])
tmp_is <- assay(res_pos, "normalized_filled")[is_std$feature_id, ]
rsd_adj_is <- rowRsd(tmp_is[, res_pos$source == "venous"])

## Calculate RSD on internal standards in study samples
tmp_is <- assay(res_pos, "raw_filled")[is_std$feature_id, ]
rsd_raw_is_sts <- rowRsd(tmp_is[, res_pos$sample != "venous"])
tmp_is <- assay(res_pos, "median_filled")[is_std$feature_id, ]
rsd_scl_is_sts <- rowRsd(tmp_is[, res_pos$sample != "venous"])
tmp_is <- assay(res_pos, "normalized_filled")[is_std$feature_id, ]
rsd_adj_is_sts <- rowRsd(tmp_is[, res_pos$sample != "venous"])
```

```{r norm-rsd-plot venous, fig.path = IMAGE_PATH, message = FALSE, echo = FALSE, fig.height = 7, fig.width = 7, fig.cap = "Coefficient Of Variation (RSD)."}
par(mfrow = c(2, 3))
boxplot(list(raw = rsd_raw, scaled = rsd_scl, normalized = rsd_adj),
        main = "All signals - venous samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)

boxplot(list(raw = rsd_raw_det, scaled = rsd_scl_det, normalized = rsd_adj_det),
        main = "Detected signals - venous samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)

boxplot(list(raw = rsd_raw_sts, scaled = rsd_scl_sts, normalized = rsd_adj_sts),
        main = "All signals - Study samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)

boxplot(list(raw = rsd_raw_is, scaled = rsd_scl_is, normalized = rsd_adj_is),
        main = "IS - venous samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)

boxplot(list(raw = rsd_raw_is_sts, scaled = rsd_scl_is_sts,
             normalized = rsd_adj_is_sts),
        main = "IS - Study samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)
```

We proceed with the capillary samples:

```{r RSD-capillary, message = FALSE, echo = FALSE, warning = FALSE}
## Calculate RSD on all POOL signals
rsd_raw <- rowRsd(
    assay(res_pos, "raw_filled")[, res_pos$source == "capillary"])
rsd_scl <- rowRsd(
    assay(res_pos, "median_filled")[, res_pos$source == "capillary"])
rsd_adj <- rowRsd(
    assay(res_pos, "normalized_filled")[, res_pos$source == "capillary"])

## Calculate RSD only on detected POOL signals
tmp <- assay(res_pos, "raw_filled")
tmp[is.na(assay(res_pos, "raw"))] <- NA
rsd_raw_det <- rowRsd(tmp[, res_pos$source == "capillary"])
tmp <- assay(res_pos, "median_filled")
tmp[is.na(assay(res_pos, "raw"))] <- NA
rsd_scl_det <- rowRsd(tmp[,

 res_pos$source == "capillary"])
tmp <- assay(res_pos, "normalized_filled")
tmp[is.na(assay(res_pos, "raw"))] <- NA
rsd_adj_det <- rowRsd(tmp[, res_pos$source == "capillary"])
```

```{r RSD-study-samples capillary, message = FALSE, echo = FALSE, warning = FALSE}
## Calculate RSD on all study samples
rsd_raw_sts <- rowRsd(
    assay(res_pos, "raw_filled")[, res_pos$source != "capillary"])
rsd_scl_sts <- rowRsd(
    assay(res_pos, "median_filled")[, res_pos$source != "capillary"])
rsd_adj_sts <- rowRsd(
    assay(res_pos, "normalized_filled")[, res_pos$source != "capillary"])
```

```{r RSD-internal-standards capillary, message = FALSE, echo = FALSE, warning = FALSE}
## Calculate RSD on internal standards in venous signals
tmp_is <- assay(res_pos, "raw_filled")[is_std$feature_id, ]
rsd_raw_is <- rowRsd(tmp_is[, res_pos$source == "capillary"])
tmp_is <- assay(res_pos, "median_filled")[is_std$feature_id, ]
rsd_scl_is <- rowRsd(tmp_is[, res_pos$source == "capillary"])
tmp_is <- assay(res_pos, "normalized_filled")[is_std$feature_id, ]
rsd_adj_is <- rowRsd(tmp_is[, res_pos$source == "capillary"])

## Calculate RSD on internal standards in study samples
tmp_is <- assay(res_pos, "raw_filled")[is_std$feature_id, ]
rsd_raw_is_sts <- rowRsd(tmp_is[, res_pos$sample != "capillary"])
tmp_is <- assay(res_pos, "median_filled")[is_std$feature_id, ]
rsd_scl_is_sts <- rowRsd(tmp_is[, res_pos$sample != "capillary"])
tmp_is <- assay(res_pos, "normalized_filled")[is_std$feature_id, ]
rsd_adj_is_sts <- rowRsd(tmp_is[, res_pos$sample != "capillary"])
```

```{r norm-rsd-plot capillary, fig.path = IMAGE_PATH, message = FALSE, echo = FALSE, fig.height = 7, fig.width = 7, fig.cap = "Coefficient Of Variation (RSD)."}
par(mfrow = c(2, 3))
boxplot(list(raw = rsd_raw, scaled = rsd_scl, normalized = rsd_adj),
        main = "All signals - capillary samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)

boxplot(list(raw = rsd_raw_det, scaled = rsd_scl_det, normalized = rsd_adj_det),
        main = "Detected signals - capillary samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)

boxplot(list(raw = rsd_raw_sts, scaled = rsd_scl_sts, normalized = rsd_adj_sts),
        main = "All signals - Study samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)

boxplot(list(raw = rsd_raw_is, scaled = rsd_scl_is, normalized = rsd_adj_is),
        main = "IS - capillary samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)

boxplot(list(raw = rsd_raw_is_sts, scaled = rsd_scl_is_sts,
             normalized = rsd_adj_is_sts),
        main = "IS - Study samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)
```


We proceed with the plasma samples:

```{r RSD-plasma, message = FALSE, echo = FALSE, warning = FALSE}
## Calculate RSD on all POOL signals
rsd_raw <- rowRsd(
    assay(res_pos, "raw_filled")[, res_pos$source == "plasma"])
rsd_scl <- rowRsd(
    assay(res_pos, "median_filled")[, res_pos$source == "plasma"])
rsd_adj <- rowRsd(
    assay(res_pos, "normalized_filled")[, res_pos$source == "plasma"])

## Calculate RSD only on detected POOL signals
tmp <- assay(res_pos, "raw_filled")
tmp[is.na(assay(res_pos, "raw"))] <- NA
rsd_raw_det <- rowRsd(tmp[, res_pos$source == "plasma"])
tmp <- assay(res_pos, "median_filled")
tmp[is.na(assay(res_pos, "raw"))] <- NA
rsd_scl_det <- rowRsd(tmp[, res_pos$source == "plasma"])
tmp <- assay(res_pos, "normalized_filled")
tmp[is.na(assay(res_pos, "raw"))] <- NA
rsd_adj_det <- rowRsd(tmp[, res_pos$source == "plasma"])
```

```{r RSD-study-samples plasma, message = FALSE, echo = FALSE, warning = FALSE}
## Calculate RSD on all study samples
rsd_raw_sts <- rowRsd(
    assay(res_pos, "raw_filled")[, res_pos$source != "plasma"])
rsd_scl_sts <- rowRsd(
    assay(res_pos, "median_filled")[, res_pos$source != "plasma"])
rsd_adj_sts <- rowRsd(
    assay(res_pos, "normalized_filled")[, res_pos$source != "plasma"])
```

```{r RSD-internal-standards plasma, message = FALSE, echo = FALSE, warning = FALSE}
## Calculate RSD on internal standards in venous signals
tmp_is <- assay(res_pos, "raw_filled")[is_std$feature_id, ]
rsd_raw_is <- rowRsd(tmp_is[, res_pos$source == "plasma"])
tmp_is <- assay(res_pos, "median_filled")[is_std$feature_id, ]
rsd_scl_is <- rowRsd(tmp_is[, res_pos$source == "plasma"])
tmp_is <- assay(res_pos, "normalized_filled")[is_std$feature_id, ]
rsd_adj_is <- rowRsd(tmp_is[, res_pos$source == "plasma"])

## Calculate RSD on internal standards in study samples
tmp_is <- assay(res_pos, "raw_filled")[is_std$feature_id, ]
rsd_raw_is_sts <- rowRsd(tmp_is[, res_pos$sample != "plasma"])
tmp_is <- assay(res_pos, "median_filled")[is_std$feature_id, ]
rsd_scl_is_sts <- rowRsd(tmp_is[, res_pos$sample != "plasma"])
tmp_is <- assay(res_pos, "normalized_filled")[is_std$feature_id, ]
rsd_adj_is_sts <- rowRsd(tmp_is[, res_pos$sample != "plasma"])
```

```{r norm-rsd-plot plasma, fig.path = IMAGE_PATH, message = FALSE, echo = FALSE, fig.height = 7, fig.width = 7, fig.cap = "Coefficient Of Variation (RSD)."}
par(mfrow = c(2, 3))
boxplot(list(raw = rsd_raw, scaled = rsd_scl, normalized = rsd_adj),
        main = "All signals - plasma samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)

boxplot(list(raw = rsd_raw_det, scaled = rsd_scl_det, normalized = rsd_adj_det),
        main = "Detected signals - plasma samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)

boxplot(list(raw = rsd_raw_sts, scaled = rsd_scl_sts, normalized = rsd_adj_sts),
        main = "All signals - Study samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)

boxplot(list(raw = rsd_raw_is, scaled = rsd_scl_is, normalized = rsd_adj_is),
        main = "IS - plasma samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)

boxplot(list(raw = rsd_raw_is_sts, scaled = rsd_scl_is_sts,
             normalized = rsd_adj_is_sts),
        main = "IS - Study samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)
```


We proceed with the RBC samples:

```{r RSD-RBC, message = FALSE, echo = FALSE, warning = FALSE}
## Calculate RSD on all POOL signals
rsd_raw <- rowRsd(
    assay(res_pos, "raw_filled")[, res_pos$source == "RBC"])
rsd_scl <- rowRsd(
    assay(res_pos, "median_filled")[, res_pos$source == "RBC"])
rsd_adj <- rowRsd(
    assay(res_pos, "normalized_filled")[, res_pos$source == "RBC"])

## Calculate RSD only on detected POOL signals
tmp <- assay(res_pos, "raw_filled")
tmp[is.na(assay(res_pos, "raw"))] <- NA
rsd_raw_det <- rowRsd(tmp[, res_pos$source == "RBC"])
tmp <- assay(res_pos, "median_filled")
tmp[is.na(assay(res_pos, "raw"))] <- NA
rsd_scl_det <- rowRsd(tmp[, res_pos$source == "RBC"])
tmp <- assay(res_pos, "normalized_filled")
tmp[is.na(assay(res_pos, "raw"))] <- NA
rsd_adj_det <- rowRsd(tmp[, res_pos$source == "RBC"])
```

```{r RSD-study-samples RBC, message = FALSE, echo = FALSE, warning = FALSE}
## Calculate RSD on all study samples
rsd_raw_sts <- rowRsd(
    assay(res_pos, "raw_filled")[, res_pos$source != "RBC"])
rsd_scl_sts <- rowRsd(
    assay(res_pos, "median_filled")[, res_pos$source != "RBC"])
rsd_adj_sts <- rowRsd(
    assay(res_pos, "normalized_filled")[, res_pos$source != "RBC"])
```

```{r RSD-internal-standards RBC, message = FALSE, echo = FALSE, warning = FALSE}
## Calculate RSD on internal standards in venous signals
tmp_is <- assay(res_pos, "raw_filled")[is_std$feature_id, ]
rsd_raw_is <- rowRsd(tmp_is[, res_pos$source == "RBC"])
tmp_is <- assay(res_pos, "median_filled")[is_std$feature_id, ]
rsd_scl_is <- rowRsd(tmp_is[, res_pos$source == "RBC"])
tmp_is <- assay(res_pos, "normalized_filled")[is_std$feature_id, ]
rsd_adj_is <- rowRsd(tmp_is[, res_pos$source == "RBC"])

## Calculate RSD on internal standards in study samples
tmp_is <- assay(res_pos, "raw_filled")[is_std$feature_id, ]
rsd_raw_is_sts <- rowRsd(tmp_is[, res_pos$sample != "RBC"])
tmp_is <- assay(res_pos, "median_filled")[is_std$feature_id, ]
rsd_scl_is_sts <- rowRsd(tmp_is[, res_pos$sample != "RBC"])
tmp_is <- assay(res_pos, "normalized_filled")[is_std$feature_id, ]
rsd_adj_is_sts <- rowRsd(tmp_is[, res_pos$sample != "RBC"])
```

```{r norm-rsd-plot RBC, fig.path = IMAGE_PATH, message = FALSE, echo = FALSE, fig.height = 7, fig.width = 7, fig.cap = "Coefficient Of Variation (RSD)."}
par(mfrow = c(2, 3))
boxplot(list(raw = rsd_raw, scaled = rsd_scl, normalized = rsd_adj),
        main = "All signals - RBC samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)

boxplot(list(raw = rsd_raw_det, scaled = rsd_scl_det, normalized = rsd_adj_det),
        main = "Detected signals - RBC samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)

boxplot(list(raw = rsd_raw_sts, scaled = rsd_scl_sts, normalized = rsd_adj_sts),
        main = "All signals - Study samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)

boxplot(list(raw = rsd_raw_is, scaled = rsd_scl_is, normalized = rsd_adj_is),
        main = "IS - RBC samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)

boxplot(list(raw = rsd_raw_is_sts, scaled = rsd_scl_is_sts,
             normalized = rsd_adj_is_sts),
        main = "IS - Study samples")
grid(nx = NA, ny = NULL)
abline(h = 0.3)
```

```{r final-qa-rsd-table, message = FALSE, echo = FALSE, results = "asis", warning = FALSE}
T <- rbind(`mean RSD` = c(raw = mean(rsd_raw, na.rm = TRUE),
                          scaled = mean(rsd_scl, na.rm = TRUE),
                          normalized = mean(rsd_adj, na.rm = TRUE),
                          `raw detected` = mean(rsd_raw_det, na.rm = TRUE),
                          `scaled detected` = mean(rsd_scl_det, na.rm = TRUE),
                          `normalized detected` = mean(rsd_adj_det,
                                                       na.rm = TRUE),
                          `raw - study samples` = mean(rsd_raw_sts,
                                                       na.rm = TRUE),
                          `scaled - study samples` = mean(rsd_scl_sts,
                                                          na.rm = TRUE),
                          `normalized - study samples` = mean(rsd_adj_sts,
                                                              na.rm = TRUE),
                          `raw IS` = mean(rsd_raw_is, na.rm = TRUE),
                          `scaled IS` = mean(rsd_scl_is, na.rm = TRUE),
                          `normalized IS` = mean(rsd_adj_is, na.rm = TRUE),
                          `raw IS - Study samples` = mean(rsd_raw_is_sts,
                                                          na.rm = TRUE),
                          `scaled IS - Study samples` = mean(rsd_scl_is_sts,
                                                             na.rm = TRUE),
                          `normalized IS - Study samples` = mean(rsd_adj_is_sts,
                                                                 na.rm = TRUE)),
           `% RSD > 0.3` = c(c(sum(rsd_raw > 0.3, na.rm = TRUE),
                               sum(rsd_scl > 0.3, na.rm = TRUE),
                               sum(rsd_adj > 0.3, na.rm = TRUE)) *
                                   100 / length(rsd_raw),
                             c(sum(rsd_raw_det > 0.3, na.rm = TRUE),
                             sum(rsd_scl_det > 0.3, na.rm = TRUE),
                             sum(rsd_adj_det > 0.3, na.rm = TRUE)) *
                                 100 / length(rsd_raw_det),
                             c(sum(rsd_raw_sts > 0.3, na.rm = TRUE),
                             sum(rsd_scl_sts > 0.3, na.rm = TRUE),
                             sum(rsd_adj_sts > 0.3, na.rm = TRUE)) *
                                 100 / length(rsd_raw_sts),
                             c(sum(rsd_raw_is > 0.3, na.rm = TRUE),
                             sum(rsd_scl_is > 0.3, na.rm = TRUE),
                             sum(rsd_adj_is > 0.3, na.rm = TRUE)) *
                                 100 / length(rsd_raw_is),
                             c(sum(rsd_raw_is_sts > 0.3, na.rm = TRUE),
                             sum(rsd_scl_is_sts > 0.3, na.rm = TRUE),
                             sum(rsd_adj_is_sts > 0.3, na.rm = TRUE)) *
                                 100 / length(rsd_raw_is_sts)))
cpt <- paste0("Summary of RSD calculations. We show how the RSD changes among ",
              "different groups: all features in POOL samples, only detected ",
              "signals in POOL samples, all features in study samples, ",
              "internal standards in POOL samples and internal standards in ",
              "study samples.")
pandoc.table(T, caption = cpt, style = "rmarkdown")
```

From what we see, there is an improvement in RSD from raw to normalized data in
the POOL samples: this outcome is desired, though also biased, as we fit our
data to these signals. The RSD of study samples is, as expected, much larger
than the RSD of POOL samples. Normalization does not reduce the variance between
study samples, which is desired as any reduction might reduce also biological
variance. Unexpectedly, the RSD for internal standards is much larger in study
samples than in POOL samples.

At last missing values were imputed and the result object saved.

```{r}
assays(res_pos)$normalized_filled_imputed <-
                  imputeRowMinRand(assay(res_pos, "normalized_filled"),
                                   method = "from_to")
save(res_pos, file = paste0(RDATA_PATH, "res_pos.RData"))
```

# Session information

The versions of R and the individually used packges are listed below.

```{r}
sessionInfo()
```
