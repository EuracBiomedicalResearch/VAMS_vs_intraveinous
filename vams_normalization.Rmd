---
title: "Normalization of the vams vs intraveneous untargeted metabolomics data"
author: "Johannes Rainer, Giuseppe Paglia and Sigurdur Smarason"
graphics: yes
output:
  BiocStyle::html_document:
    toc_float: true
bibliography: references.bib
csl: biomed-central.csl
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

```{r biocstyle, echo = FALSE, results = "asis" }
library(BiocStyle)
BiocStyle::markdown() 
```

**Modified**: `r file.info("vams_preprocessing.Rmd")$mtime`<br />
**Compiled**: `r date()`

```{r settings, echo = FALSE, results = "hide", message = FALSE}
## Set general options
options(useFancyQuotes = FALSE)
set.seed(18011977)

## Define paths:
filename <- "vams_normalization"
## Path to save the images; remove all old images.
IMAGE_PATH <- paste0("images/", filename, "/")
if (file.exists(IMAGE_PATH))
    unlink(IMAGE_PATH, recursive = TRUE)
dir.create(IMAGE_PATH, recursive = TRUE)
## Path to store RData files
RDATA_PATH <- paste0("data/RData/", filename, "/")
if (!file.exists(RDATA_PATH)) dir.create(RDATA_PATH, recursive = TRUE)

use_cached <- TRUE
if (!file.exists(paste0(RDATA_PATH, "data_pos.RData")))
    use_cached <- FALSE

## Get the number of cpus allocated or fall back to 3 
ncores <- as.integer(Sys.getenv("SLURM_JOB_CPUS_PER_NODE", 3))
```

# Introduction

In this document we perform the normalization of the feature abundances of the
*MitYOU* project. This comprises quality assessment based on the feature's
abundances, eventual normalization of a injection order-dependent signal drift
within each batch (if this proves to increase signal quality as determined by
the RSD across QC samples) and removal of between batch effects. The
preprocessing of the data is described in file *vams_preprocessing.Rmd*.

# Data import and initial quality assessment

Below we load all libraries required for the analysis and the data. We also
fill-in missing peak values, i.e. for features for which not a peak was
identified in all samples, we integrate the signal from the feature area in
these samples. 

```{r libraries-data, message = FALSE}
library(xcms)
library(RColorBrewer)
library(pander)
library(magrittr)
library(pheatmap)
library(doParallel)
registerDoParallel(ncores)
register(DoparParam(), default = TRUE)

## Define colors for the groups.
col_source <- brewer.pal(5, name = "Set1")
names(col_source) <- c("RBC",           # red
                       "plasma",        # blue
                       "all",           # green
                       "capillary",     # purple
                       "venous")        # orange

load("data/RData/vams_preprocessing/data_pos.RData")
```

We restrict the analysis to features with multiple peaks per sample in less than
10% of samples in which a peak was found (excluding QC samples). In addition we
require a feature to be found in 30% of the samples of at least one group
(excluding QC samples). An overview of features used for the analysis is given
in the table below.

```{r feature-summary, message = FALSE, echo = FALSE}
fsumm <- featureSummary(data_pos, data_pos$source)
study_src <- names(col_source)[names(col_source) != "all"]

## Determine the proportion of samples with multi peaks in the study group.
## Have to relate that to the number of samples in which a peak was found,
## and not to the total number of samples!!!
tmp <- rowSums(fsumm[, paste0(study_src, "_multi_count")]) /
    rowSums(fsumm[, paste0(study_src, "_count")])

## Further require a feature to be cound in more than 30% of samples in at
## least one group.
tmp_perc <- apply(fsumm[, paste0(study_src, "_perc")], 1,
                  function (z) any(z > 30))
fts_used <- rownames(featureDefinitions(data_pos))[which(tmp < 0.1 & tmp_perc)]


tab <- rbind(total_features = length(fts_used),
             `RBC > 50%` = sum(fsumm[fts_used, "RBC_perc"] > 50),
             `plasma > 50%` = sum(fsumm[fts_used, "plasma_perc"] > 50),
             `capillary > 50%` = sum(fsumm[fts_used, "capillary_perc"] > 50),
             `venous > 50%` = sum(fsumm[fts_used, "venous_perc"] > 50))
colnames(tab) <- "count"
pandoc.table(tab, style = "rmarkdown",
             caption = paste("Summary of features used for the analysis. All",
                             "features found more than 30% of samples of at",
                             "least one sample group and with less than 10%",
                             "of samples with multiple peaks per sample among",
                             " those in which a peak was identified are used."))

```

Next we fill-in data for samples in which no peak was detected. The signal
integration bases on the m/z and retention time range of the features, which in
fact represents the extent in which the apexes of the individual peaks differ
between samples. While we will eventually exclude filled-in signals in the
estimation of the normalization factors for the within and between-batch
normalization, we will normalize these intensities as they might be affected by
the same effects than the *real* signal. Imputation of signals that are still
missing after filling in will be performed **after** normalization.

Below we fill-in missing peak data by expanding the retention time window of
each feature by a constant value (1 second on each side) and the m/z by 40 ppm.

```{r fill-in, message = FALSE, warning = FALSE, eval = use_cached}
fcp <- FillChromPeaksParam(ppm = 40, fixedRt = 1)
data_pos <- fillChromPeaks(data_pos, param = fcp)

save(data_pos, file = paste0(RDATA_PATH, "data_pos.RData"))
```

```{r load-again, echo = FALSE, results = "hide"}
load(paste0(RDATA_PATH, "data_pos.RData"))
```

Next we extract the matrix with feature abundances with the integrated peak area
(column `"into"`) used as abundance estimate. The integrated peak area of all
peaks of a sample assigned to a feature are summed for multi-peak features. This
is however matter for change with alternatives being `method = "maxint"` and
`intensity = "maxo"` (select the aggregated intensity of the peak with the
highest intensity at the apex) or `method = "maxint"` and `intensity = "into"`
(select the largest integrated intensity). For comparison reasons we also
extract the feature data without any filled-in information.

```{r extract-featureValues, message = FALSE}
## Use method = "sum"... for now.
fv <- featureValues(data_pos, method = "sum", value = "into")
fv_nofill <- featureValues(data_pos, method = "sum",
                           value = "into", filled = FALSE)

```

Below we plot the number of non-missing values and the distribution of feature
intensities first for the data without and then with filled-in data.

```{r raw-nofill-boxplot, fig.path = IMAGE_PATH, message = FALSE, warning = FALSE, echo = FALSE, fig.cap = "Counts of non-missing values and feature abundance distribution.", fig.width = 10, fig.height = 8}
layout(mat = matrix(1:2, ncol = 1), height = c(0.5, 1))
par(mar = c(1, 4.5, 1, 0.5))
barplot(apply(fv_nofill, MARGIN = 2, function(x) sum(!is.na(x))),
        col = paste0(col_source[data_pos$source], 80), ylab = "features",
        xaxt = "n")
boxplot(log2(fv_nofill), ylab = expression(log[2]~feature~abundance),
        col = paste0(col_source[data_pos$source]), cex = 0.5, pch = 16,
        border = paste0(col_source[data_pos$source], 40))
grid(nx = NA, ny = NULL)
```

Plasma samples (blue) have less valid values for features compared to samples
from other sources. Some of the RBC (red) samples also have a considerably lower
number of detected features.  The distribution of feature intensities seems to
be comparable between samples, sources and batches.

```{r raw-boxplot, fig.path = IMAGE_PATH, message = FALSE, warning = FALSE, echo = FALSE, fig.cap = "Counts of non-missing values and feature abundance distribution for the filled-in data.", fig.width = 10, fig.height = 8}
layout(mat = matrix(1:2, ncol = 1), height = c(0.5, 1))
par(mar = c(1, 4.5, 1, 0.5))
barplot(apply(fv, MARGIN = 2, function(x) sum(!is.na(x))),
        col = paste0(col_source[data_pos$source], 80), ylab = "features",
        xaxt = "n")
boxplot(log2(fv), ylab = expression(log[2]~feature~abundance),
        col = paste0(col_source[data_pos$source]), cex = 0.5, pch = 16,
        border = paste0(col_source[data_pos$source], 40))
grid(nx = NA, ny = NULL)
```

After filling in missing peak values the proportion of detected features is
highly comparable between samples. Plasma samples show however considerably
lower signal intensities than all other samples, which reflects that less peaks
were detected for these features in these samples (and intensities were thus
filled-in).

Next we create relative log abundance plots that represent the difference of the
(log) abundances of each feature in a sample compared to the median abundance of
that feature in samples from the same sample group (source).

```{r raw-nofill-rla-plot, fig.path = IMAGE_PATH, message = FALSE, warning = FALSE, echo = FALSE, fig.cap = "RLA plot for the raw data. Note: outliers are not drawn.", fig.width = 10, fig.height = 5}
boxplot(rowRla(fv_nofill, group = data_pos$source), cex = 0.5, pch = 16, 
        col = col_source[data_pos$source], ylab = "RLA",
        border = paste0(col_source[data_pos$source], 40), notch = TRUE,
        outline = FALSE, xaxt = "n", main = "raw data")
grid(nx = NA, ny = NULL)
abline(v = sum(data_pos$batch == 31012018) + 0.5, col = "grey")
```

The RLA plot above shows some potentially systematic drifts in signal
intensities that includes also consistently lower average RLA values in the
last samples from the first, and consistently higher average RLA values in the
last samples from the second batch. Next we plot the RLA plots after filling-in
missing peak data. 

```{r raw-rla-plot, fig.path = IMAGE_PATH, message = FALSE, warning = FALSE, echo = FALSE, fig.cap = "RLA plot for the raw data after filling-in missing peak data. Note: outliers are not drawn.", fig.width = 10, fig.height = 5}
boxplot(rowRla(fv, group = data_pos$source), cex = 0.5, pch = 16, 
        col = col_source[data_pos$source], ylab = "RLA",
        border = paste0(col_source[data_pos$source], 40), notch = TRUE,
        outline = FALSE, xaxt = "n", main = "raw data, filled-in")
grid(nx = NA, ny = NULL)
abline(v = sum(data_pos$batch == 31012018) + 0.5, col = "grey")
```

The RLA plots after filling-in missing peak data look similar but the trends
become more pronounced.

# Within-batch normalization

- Estimate injection order dependent signal drift on all samples (not just QC
  samples), but not on filled-in data.
- Identify features with a strong injection index dependent drift, plot them.
- Adjust all (including filled-in) based on the estimated factors.
- Estimate within batch and check if per-feature slopes are similar between the
  two batches.

- Check performance of within-batch normalization using the two replicates per
  sample: the difference between abundances should get smaller.
- Use also the QC samples.


# Between-batch normalization

- Overall RSD should reduce.
- RLA plots should show a lower bias.

# Final QA

For samples for which even peak filling does not result in a
signal we impute the data by setting it to half of the smallest value adding
also a random value (from a normal distribution with mean being half of the
smallest value and standard deviation being 1 fourth of the standard deviation
of values for that feature). 

+ Load the data
+ Check average abundances.
+ RLA plots for abundances.
+ Adjust injection order dependent drift... do I have to? Really?
  - In log2 scale.
  - Use all samples, check for QCs if it improved.
  - Overall RSD.
  - Features with an RSD < 0.3, 0.2, 0.1.
+ Adjust batch effect.




```{r}

tmp <- na.omit(fv)
pc <- prcomp(t(log2(tmp)), scale = FALSE, center = TRUE)
par(mfrow = c(1, 2))
BioCHRIStes::plot_pca(pc, col = col_source[data_pos$source],
                      pc_x = 1, pc_y = 2)
BioCHRIStes::plot_pca(pc, col = col_source[data_pos$source],
                      pc_x = 3, pc_y = 4)

```


# References
