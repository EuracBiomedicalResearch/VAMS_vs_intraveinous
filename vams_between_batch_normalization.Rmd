---
title: "vams_between_batch_normalization"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.


# Between-batch normalization

The between-batch normalization aims to remove batch specific effects from the
data. These batch effects are assumed to affect each sample measured in the same
batch (same run, from the same plate) in the same way. The effect is estimated
based on abundances in QC samples and differences of these are leveled between
batches. Note that this between-batch normalization does **not** account for
biases that result from pipetting or injection amount differences. Such effects
would have to be normalized based on a between-sample normalization strategy
similar to what is performed in gene expression experiments. Also, between-batch
normalization will not reduce differences between replicated samples since
abundances for both replicates for each sample are measured in the same batch.

Below we use linear models on (log2 transformed) detected signal in QC samples
to estimate the (per-feature) batch effect. We require at least 6 valid
measurements in QC samples of each batch from all features and mean absolute
residuals that are smaller than 0.5. Also, we flag features for which the ratio
of the average signal between study and QC samples differs by more than two-fold
between the batches. Assuming an unbiased sampling in both batches we expect
this signal to QC ratio the ratio to be comparable between the two batches. For
a considerable number of features this differs however between the batches. A
feature-wise normalization based on QC samples would introduce a bias instead of
removing it for these cases.

Features that do not fulfill the above mentioned criteria will be normalized
with a global model.

```{r estimate-between-batch-effect, message = FALSE, warning = FALSE}
qcs_a <- res_pos$sample == "POOL" & tmp_a
qcs_b <- res_pos$sample == "POOL" & tmp_b

mdls_batch <-
    xcms:::rowFitModel(y ~ batch,
                       data = as.data.frame(colData(res_pos)[qcs_a | qcs_b, ]),
                       y = log2(assay(res_pos, "norm_nofill")[, qcs_a | qcs_b]),
                       method = "lm", minVals = 12)

#' Flag models for features with less than 6 values per batch.
flags_cat_count <- vapply(mdls_batch, flag_model_cat_count, logical(1),
                          variable = "batch", min_count = 6)
mdls_batch[which(flags_cat_count)] <- NA
#' Flag models with large residuals.
flags_res <- vapply(mdls_batch, flag_model_mean_residual, logical(1),
                    cut_off = 0.5)
mdls_batch[which(flags_res)] <- NA

#' Flag models for feature for which the average signal to QC ratio is more
#' two-fold different between the batches.
#' 
#' First calculate mean (log2) abundances for each group within each batch
src_btch <- paste(res_pos$source, res_pos$batch)
src_btch_avg <- apply_colgroup(log2(assay(res_pos, "norm_nofill")), src_btch,
                               function(z) apply(z, 1, mean_if, n = 6))
#' Difference between each source and the pool within each batch
btch_a <- grep("31012018", colnames(src_btch_avg))
src_btch_avg[, btch_a] <- src_btch_avg[, btch_a] -
    src_btch_avg[, "all 31012018"]
btch_b <- grep("1022018", colnames(src_btch_avg))
src_btch_avg[, btch_b] <- src_btch_avg[, btch_b] -
    src_btch_avg[, "all 01022018"]
#' Calculate differences (per group/source) between batches
diff_btch <- src_btch_avg[, paste(c("venous", "RBC", "capillary", "plasma"),
                                  "31012018")] -
    src_btch_avg[, paste(c("venous", "RBC", "capillary", "plasma"),
                         "01022018")]
flags_diff <- abs(rowMeans(diff_btch, na.rm = TRUE)) > 1
mdls_batch[which(flags_diff)] <- NA

#' Fit a global model on all features.
glbl_mdl_batch <-
    xcms:::fitModel(y ~ batch,
                    data = as.data.frame(colData(res_pos))[qcs_a | qcs_b, ],
                    y = log2(assay(res_pos, "norm_nofill")[, qcs_a | qcs_b]),
                    method = "lm", minVals = 12)
```

The plots below show examples for features being flagged because of large
residuals in the linear model fit or large difference in signal to QC ratio. The
last example shows the data for a feature with a large difference in QC values
that will also be adjusted based on these.

```{r between-features-flag-res, echo = FALSE, warning = FALSE, message = FALSE}
#' Plot the data for features with a too large mean residual.
plot_ft_int <- function(x, ft, main = ft, ...) {
    pchs <- ifelse(is.na(assay(res_pos, "raw")[ft, ]), yes = 1, no = 16)
    plot(log2(x[ft, ]), main = main, col = col_source[data_pos$source],
         pch = pchs)
    abline(v = sum(res_pos$batch == res_pos$batch[1]))
}
fts <- names(mdls_batch)[which(flags_res)]
dr <- paste0(IMAGE_PATH, "between-batch/large_mean_residual/")
dir.create(dr, showWarnings = FALSE, recursive = TRUE)
for (ft in fts) {
    png(paste0(dr, ft, ".png"), width = 10, height = 5, pointsize = 6,
        res = 200, units = "cm")
    plot_ft_int(assay(res_pos, "norm_nofill"), ft)
    dev.off()
}
```

```{r large-mean-residual-ex1, out.width = "750px", echo = FALSE, fig.cap = "Feature with large residuals in the feature-wise model. The feature will be adjusted globally."}
knitr::include_graphics(
           paste0(IMAGE_PATH, "between-batch/large_mean_residual/",
                  fts[1], ".png"))
```	

```{r large-difference-sample-qc, echo = FALSE, warning = FALSE, message = FALSE}
diffs <- rowMeans(diff_btch, na.rm = TRUE)[which(flags_diff)]
fts <- names(diffs[order(abs(diffs), decreasing = TRUE)])[1:20]
dr <- paste0(IMAGE_PATH, "between-batch/largest_diff_qc_sample/")
dir.create(dr, showWarnings = FALSE, recursive = TRUE)
for (ft in fts) {
    png(paste0(dr, ft, ".png"), width = 10, height = 5, pointsize = 6,
        res = 200, units = "cm")
    plot_ft_int(assay(res_pos, "norm_nofill"), ft)
    dev.off()
}
```

```{r large-difference-sample-qc-ex1, out.width = "750px", echo = FALSE, fig.cap = "Feature with a large difference in signal to QC ratio between the batches. The feature will be adjusted globally."}
knitr::include_graphics(
           paste0(IMAGE_PATH, "between-batch/largest_diff_qc_sample/",
                  fts[1], ".png"))
```	

```{r between-batch-top-slope-features, echo = FALSE, warning = FALSE, message = FALSE}
#' Plot the data for the top 20 features with the largest slopes.
mdls_slp <- vapply(mdls_batch, function(z) {
    if (length(z) > 1)
        z$coefficients[2]
    else NA_real_
}, numeric(1))

fts <- names(sort(abs(mdls_slp), decreasing = TRUE))[1:20]
dr <- paste0(IMAGE_PATH, "between-batch/largest_slopes/")
dir.create(dr, showWarnings = FALSE, recursive = TRUE)
for (ft in fts) {
    png(paste0(dr, ft, ".png"), width = 10, height = 5, pointsize = 6,
        res = 200, units = "cm")
    plot_ft_int(assay(res_pos, "norm_nofill"), ft)
    dev.off()
}
```

```{r between-batch-top-slope-ex1, out.width = "750px", echo = FALSE, fig.cap = "Feature with a large slope for the between-batch normalization model."}
knitr::include_graphics(
           paste0(IMAGE_PATH, "between-batch/largest_slopes/",
                  fts[11], ".png"))
```	

The table below lists the number of features that are adjusted with feature-wise
models and the number of features for which a global batch correction will be
applied.

```{r between-batch-table, echo = FALSE, results = "asis"}
T <- cbind(`feature-wise` = sum(!is.na(mdls_batch)),
           global = sum(is.na(mdls_batch)))
rownames(T) <- "feature count"
cpt <- paste0("Number of features being between-batch normalized using ",
              "feature-wise or global models.")
pandoc.table(T, style = "rmarkdown", caption = cpt)
```

Next we adjust the data applying the models estimated on the QC samples.

```{r between-batch-normalize, warning = FALSE, message = FALSE}
mdls_batch[is.na(mdls_batch)] <- list(glbl_mdl_batch)
tmp <- 2^xcms:::applyModelAdjustment(
                    y = log2(assay(res_pos, "norm")),
                    data = as.data.frame(colData(res_pos)),
                    lmod = mdls_batch,
                    shiftNegative = "replaceHalfMin")
assays(res_pos)$norm <- tmp
tmp[is.na(assay(res_pos, "raw"))] <- NA
assays(res_pos)$norm_nofill <- tmp
rm(tmp)
```


# Final QA

At last we evaluate the performance of the normalization that includes
between-samples, within-batch and between-batch normalization.

```{r final-qa-boxplots, fig.path = IMAGE_PATH, fig.width = 14, fig.height = 9, fig.cap = "Boxplots representing the per-sample distribution of signal. Shown are log2 abundances before (upper panel) and after normalization (below). Only detected signal is considered.", echo = FALSE}
par(mfrow = c(2, 1), mar = c(1, 4.5, 1, 0.5))
dobox(log2(assay(res_pos, "raw")), main = "raw data")
dobox(log2(assay(res_pos, "norm_nofill")), main = "normalized data")
```

Normalization reduced the between-sample differences in feature abundance
distributions.

Next we create RLA plots.

```{r final-qa-rla, fig.path = IMAGE_PATH, fig.width = 14, fig.height = 9, fig.cap = "RLA plots before and after normalization. Only detected signal is considered.", echo = FALSE}
par(mfrow = c(2, 1), mar = c(1, 4.5, 1, 0.5))
dobox(rowRla(assay(res_pos, "raw"), data_pos$source), main = "raw data",
      ylab = "RLA")
dobox(rowRla(assay(res_pos, "norm_nofill"), data_pos$source),
      main = "normalized data", ylab = "RLA")
```

The RLA plots get slightly better due to the normalization.

In addition we calculate the RSD across QC samples for all features. Note that,
since the normalization is performed on QC samples themselfs, this is not an
unbiased quality criteria.

```{r final-qa-rsd, message = FALSE, warning = FALSE}
rsd_raw <- rowRsd(assay(res_pos, "raw_filled_imputed")[, data_pos$source == "all"])
rsd_adj <- rowRsd(assay(res_pos, "norm")[, data_pos$source == "all"])

#' Only on detected signal
rsd_raw_det <- rowRsd(assay(res_pos, "raw")[, data_pos$source == "all"])
rsd_adj_det <- rowRsd(assay(res_pos, "norm_nofill")[, data_pos$source == "all"])
```

```{r final-qa-rsd-boxplot, fig.path = IMAGE_PATH, echo = FALSE, fig.cap = "RSD across QC samples for the raw and normalized data. Shown are the results for the full data (including filled-in signal) on the left and on only detected signal (right)."}
par(mfrow = c(1, 2))
boxplot(list(raw = rsd_raw, normalized = rsd_adj), main = "All data")
grid(nx = NA, ny = NULL)
abline(h = 0.3)
boxplot(list(raw = rsd_raw_det, normalized = rsd_adj_det),
        main = "Detected signal")
grid(nx = NA, ny = NULL)
abline(h = 0.3)
```

The table below summarizes the RSD calculations.

```{r final-qa-rsd-table, echo = FALSE, results = "asis"}
T <- data.frame(raw = quantile(rsd_raw, na.rm = TRUE),
                normalized = quantile(rsd_adj, na.rm = TRUE),
                `raw detected` = quantile(rsd_raw_det, na.rm = TRUE),
                `normalized detected` = quantile(rsd_adj_det,
                                                 na.rm = TRUE))
T <- rbind(T,
           `% RSD > 0.3` = c(sum(rsd_raw > 0.3, na.rm = TRUE),
                             sum(rsd_adj > 0.3, na.rm = TRUE),
                             sum(rsd_raw_det > 0.3, na.rm = TRUE),
                             sum(rsd_adj_det > 0.3, na.rm = TRUE)) *
               100 / length(rsd_raw))
cpt <- paste0("Summary of RSD calculations on QC samples. Shown are the ",
              "results for all (including filled-in) signals and for only ",
              "detected chromatographic peaks.")
pandoc.table(T, caption = cpt, style = "rmarkdown")
```

The performance of the normalization is also estimated based on the difference
of normalized abundances for replicated samples. Each study sample is
represented twice in the data set, with each replicate, while being from the
same individual), representing the abundance measured on a single, separate,
Mitra tip. We perform the quality assessment only on normalized signal from
detected peaks. Note that, since replicates were measured **within** each batch,
this will only allow to evaluate the **within** batch normalization.

Below we calculate the difference in abundances between replicated measurements
on detected peak data only.

```{r final-qa-mra, message = FALSE, warning = FALSE}
grp <- paste(res_pos$source, res_pos$sample, sep = "-")

mra_raw <- mra_for_mat(assay(res_pos, "raw_filled_imputed"),
                       assay(res_pos, "raw"), grp, "all-POOL")
mra_adj <- mra_for_mat(assay(res_pos, "norm"),
                       assay(res_pos, "raw"), grp, "all-POOL")
```

To evaluate the impact of within-batch normalization we calculate the 75%
quantile of all adjusted features' MRA per sample. 75% of features for a
specific sample have a maximum ratio of abundances between replicated
measurements that is smaller than this value. In addition we calculate the
number and percentages of measurements that are more than two-fold different in
a replicate pair.

```{r final-qa-mra-75, message = FALSE, warnings = FALSE}
mra_raw_q <- mra_summary_quant(mra_raw)
mra_raw_c <- mra_summary_count(mra_raw)
mra_raw_p <- mra_summary_perc(mra_raw)
mra_adj_q <- mra_summary_quant(mra_adj)
mra_adj_c <- mra_summary_count(mra_adj)
mra_adj_p <- mra_summary_perc(mra_adj)
```

A comparison between the raw and adjusted 75% MRAs is shown in the plot below.

```{r final-qa-mra-75-scatterplot, message = FALSE, warning = FALSE, fig.path = IMAGE_PATH, fig.cap = "Raw against adjusted 75% MRA for replicated samples in batch a (left) and batch b (right). Each point represents the 75% MRA for one replicated sample pair. Colors indicate the sample source, the solid line the identity line.", fig.width = 12, fig.height = 6, echo = FALSE}
cols_mra <- col_source[vapply(strsplit(names(mra_adj_q), "-"),
                                function(z) z[1], character(1))]

par(mfrow = c(1, 1), mar = c(4.3, 4.3, 1, 0.5))
YL <- range(c(mra_raw_q_a, mra_adj_q_a), na.rm = TRUE)
plot(mra_raw_q, mra_adj_q, main = "", col = paste0(cols_mra, 80),
     pch = 16, xlim = YL, ylim = YL, xlab = "raw 75% MRA", ylab = "adj 75% MRA")
abline(0, 1)
grid()
legend("topleft", legend = unique(names(cols_mra)),
       col = cols_mra[unique(names(cols_mra))], pch = 16)
```

The 75% MRA of replicated samples is between 1.2 and 2.5 which is actually quite
good, meaning that most samples have a less than 2-fold difference between
replicated measurements.

The boxplot below summarizes the results by comparing the distribution of raw
and adjusted 75% MRA for both batches.

```{r final-qa-within-batch-mra-75-boxplot, message = FALSE, warning = FALSE, fig.path = IMAGE_PATH, fig.cap = "Impact of normalization on differences between replicated measurements. Distribution of 75% MRAs for the raw and adjusted features (left) and numbers of replicates measurements (per sample) with an absolute difference of abundances larger than 2 (right).", fig.width = 6, fig.height = 6, echo = FALSE}
mra_df <- data.frame(raw = mra_raw_q,
                     adj = mra_adj_q)
mra_c_df <- data.frame(raw = mra_raw_c,
                       adj = mra_adj_c)
mra_p_df <- data.frame(raw = mra_raw_p,
                       adj = mra_adj_p)

par(mar = c(6, 4.5, 1, 0.5), mfrow = c(1, 2))
boxplot(mra_df, las = 2, ylab = "75% quantile MRA", ylim = c(1, 3))
grid(nx = NA, ny = NULL)
boxplot(mra_p_df, las = 2, ylab = "% M > 1")
grid(nx = NA, ny = NULL)
```

The table below summarizes the results.

```{r final-qa-within-batch-mra-75-table, echo = FALSE, results = "asis"}
T <- apply(mra_df, 2, quantile, na.rm = TRUE)
T <- rbind(T,
           `% M > 1` = c(mean(mra_raw_p, na.rm = TRUE),
                             mean(mra_adj_p, na.rm = TRUE)))
cpt <- paste0("Distribution of per-replicate 75% MRA quantile for the raw ",
              "and normalized data and average percentage of ",
              "features with a more than 2-fold difference in abundance.")
pandoc.table(T, style = "rmarkdown", caption = cpt)
```

Thus, normalization could improve data quality.

# Averaging replicates

At last we average replicated measurements for each sample. Along with the
average abundances we can also define a *weight* for each measurement depending
on the signal from the replicates:

- `1`: signal from 2 detected peaks present and the RSD of their abundances is <
  30%. The `mean` of the two is reported.
- `0.9`: 1 detected and one filled-in signal present and their RSD is < 30%. The
  `mean` of the two is reported.
- `0.8`: only filled-in signal, but their RSD is < 30%. The `mean` of the two is
  reported.
- `0.7`: signal for two detected peaks but their RSD is >= 30%. The `mean` of
  the two is reported.
- `0.5`: signal from 1 detected peak present (independently of whether a
  filled-in signal is present for the other replicate). Report only
  the value for the detected peak.
- `0.25`: only filled-in signal is present. Either mean or single value
  reported.

```{r average-reps, message = FALSE, warning = FALSE}
grp <- paste0(res_pos$source, "-", data_pos$sample)
res_pos$sample_name <- grp

fv_avg <- matrix(ncol = length(unique(grp)), nrow = nrow(res_pos),
                 dimnames = list(rownames(res_pos), unique(grp)))
fv_avg <- fv_avg[, colnames(fv_avg) != "all-POOL"]
fv_wgt <- fv_avg
fv_avg_raw <- fv_avg
for (z in colnames(fv_avg)) {
    message("Processing ", which(colnames(fv_avg) == z), " of ",
            ncol(fv_avg), " ", appendLF = FALSE)
    dta <- assay(res_pos, "norm")[, res_pos$sample_name == z, drop = FALSE]
    dta_raw <-
        assay(res_pos, "raw_filled_imputed")[, res_pos$sample_name == z,
                                             drop = FALSE]
    dta_det <- assay(res_pos, "norm_nofill")[, res_pos$sample_name == z,
                                             drop = FALSE]
    det_cnt <- apply(dta_det, 1, function(x) sum(!is.na(x)))
    message(".", appendLF = FALSE)
    rsd_all <- rowRsd(dta)
    message(".", appendLF = FALSE)
    rsd_det <- rowRsd(dta_det)
    message(".", appendLF = FALSE)
    wgt <- rep(0, nrow(dta))
    ##' Calculate mean for all, applies also to filled-in-only signal.
    vls <- rowMeans(dta, na.rm = TRUE)
    vls_raw <- rowMeans(dta_raw, na.rm = TRUE)
    wgt[!is.na(vls)] <- 0.25
    ##' Only filled-in, RSD < 0.3
    idx <- which(det_cnt == 0 & rsd_all < 0.3)
    if (length(idx)) wgt[idx] <- 0.8
    ##' Single detected value: use that.
    idx <- which(det_cnt == 1)
    if (length(idx)) {
        vls[idx] <- rowMeans(dta_det[idx, , drop = FALSE], na.rm = TRUE)
        wgt[idx] <- 0.5
    }
    ##' Two detected signals, RSD > 0.3
    idx <- which(det_cnt == 2 & rsd_det >= 0.3)
    if (length(idx)) wgt[idx] <- 0.7
    ##' One detected signal, RSD < 0.3
    idx <- which(det_cnt == 1 & rsd_all < 0.3)
    if (length(idx)) {
        vls[idx] <- rowMeans(dta[idx, , drop = FALSE], na.rm = TRUE)
        wgt[idx] <- 0.9
    }
    ##' Two detected signals, RSD < 0.3
    idx <- which(det_cnt == 2 & rsd_det < 0.3)
    if (length(idx)) wgt[idx] <- 1
    vls[wgt == 0] <- NA_real_
    fv_avg[, z] <- vls
    fv_avg_raw[, z] <- vls_raw
    fv_wgt[, z] <- wgt
    message(" OK")
}
```

Next we summarize the weights per sample. The plot below shows the number of
features with a specific weight per sample. The 3 samples with a considerably
larger number of features with a weight of 0.5 are samples for which the second
replicate had to be removed because of quality issues. 

```{r summarize-weights-plot, message = FALSE, echo = FALSE, fig.path = IMAGE_PATH, fig.cap = "Mean weight of features per sample.", fig.width = 16, fig.height = 6}
table_samples <- apply(fv_wgt, 2, function(z) {
    tbl <- table(z)
    nms <- as.character(c(0.25, 0.5, 0.7, 0.8, 0.9, 1))
    res <- rep(NA_integer_, length(nms))
    names(res) <- nms
    res[names(tbl)] <- as.integer(tbl)
    res
})

par(mfrow = c(1, 1), mar = c(8, 4.5, 1, 0.5))
plot(colMeans(fv_wgt), pch = 16, col = "#00000080", xaxt = "n",
     ylab = "mean weight", xlab = "")
grid()
axis(side = 1, labels = colnames(table_samples), las = 2,
     at = 1:ncol(table_samples))
```

Four samples have on average a much lower weight of features (and thus a lower
feature/measurement quality) than all other samples. These are *capillary-20*,
*RBC-22*, *capillary-12* and *RBC-11*. For all of these samples only a single
replicate is available (explaining their lower feature abundance quality).

The table below summarizes the feature weights for the full data set.

```{r summarize-weights-table, echo = FALSE, message = FALSE, results = "asis"}
T <- rowMeans(table_samples, na.rm = TRUE)
cpt <- paste0("Average (across samples) number of features with different ",
              "weights for the full data set. A description/definition of ",
              "each weight is provided further above.")
pandoc.table(T, caption = cpt, style = "rmarkdown")
```

Most of the features' abundances are from detected chromatographic peaks with
an RSD in their intensities smaller 30% followed by signal from filled-in peaks
with an RSD > 30% (not unexpected for filled-in signal). A surprisingly large
number of features yield consistent abundances, even if their signal comes from
purely filled-in signal (weight of `0.8`).

At last we generate the result object on which all further analysis can be
performed. We add also the per-feature RSD across QC samples to the feature
annotations. This could also be used later to weight or filter features based on
their signals' *stability*.

```{r build-data, message = FALSE}
#' Create phenodata
pd <- colData(res_pos)
grp_fct <- factor(grp, levels = unique(grp))
fls <- vapply(split(pd$mzML_file, grp_fct), paste,
              character(1), collapse = ",")
injs <- vapply(split(pd$inj_idx, grp_fct), paste,
               character(1), collapse = ", ")
pd <- pd[pd$sample_name != "all-POOL", ]
pd <- unique(pd[, c("sample", "sample_name", "batch",
                    "polarity", "source", "age", "sex",
                    "sampling_date")])
rownames(pd) <- pd$sample_name
pd$mzML_files <- fls[rownames(pd)]
pd$inj_idx <- fls[rownames(pd)]

#' Create feature data
fd <- rowData(res_pos)
fd <- cbind(fd[rownames(res_pos), colnames(fd) != "peakidx"],
            featureSummary(data_pos, res_pos$source)[rownames(res_pos), ],
            QC_rsd = rowRsd(assay(res_pos, "norm")[, res_pos$source == "all"]),
            QC_rsd_nofill = rowRsd(
                assay(res_pos, "norm_nofill")[, res_pos$source == "all"]),
            QC_rsd_log2 = rowRsd(
                log2(assay(res_pos, "norm")[, res_pos$source == "all"])))

#' Create and save result object.
vams_pos <- SummarizedExperiment(
    assays = list(norm = fv_avg,
                  raw_filled_imputed = fv_avg_raw,
                  weights = fv_wgt),
    colData = pd,
    rowData = fd,
    metadata = metadata(res_pos))

save(vams_pos, file = paste0(RDATA_PATH, "vams_pos.RData"))
vams_pos_all <- res_pos
save(vams_pos_all, file = paste0(RDATA_PATH, "vams_pos_all.RData"))
```

*Note:* column `"QC_rsd"` contains the RSD for all (normalized!) abundances
across all QC samples, `"QC_rsd_nofill"` the RSD for all normalized abundances
of detected peaks and `"all_rsd"` the RSD for raw abundances of only detected
peaks across all QC samples.

# Session information

```{r sessionInfo}
devtools::session_info()
```

# References
