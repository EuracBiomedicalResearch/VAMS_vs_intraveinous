---
title: "Combine, smooth and mz pick"
author: "Sigurdur Smarason"
graphics: yes
output:
  BiocStyle::html_document:
    toc_float: true
csl: biomed-central.csl
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

```{r  init-workspace, message = FALSE, echo = FALSE, results = "hide" }
## clean up workspace
rm(list = ls())

options(useFancyQuotes = FALSE)
set.seed(18011977)

## Path to store RData files

## Define paths:
filename <- "vams2018_centroiding"
## Define the polarity of the data
MZML_POLARITY <- c("POS","NEG")

IMAGE_PATH <- paste0("~/data/images/", filename, "/")
if (!dir.exists(IMAGE_PATH)) dir.create(IMAGE_PATH, recursive = TRUE)
IMAGE_PATH_BOXPLOTS <- paste0("~/data/images/", filename, "/Boxplots/")
if (!dir.exists(IMAGE_PATH_BOXPLOTS)) {
    dir.create(IMAGE_PATH_BOXPLOTS, recursive = TRUE)
}

## Define the path where we can find the mzML files:
MZML_PATH <- "~/data/vams2018/"

## Define the path where added information is stored
MORE_INFO_PATH <- "~/data/vams2018/csv/"

## define where the resulting files should go
RDATA_PATH <- paste0("~/data/RData/", filename, "/")
if (!dir.exists(RDATA_PATH)) dir.create(RDATA_PATH, recursive = TRUE)
RESULTDATA_PATH <- paste0("~/data/Results/", filename, "/")
if (!dir.exists(RESULTDATA_PATH)) dir.create(RESULTDATA_PATH, recursive = TRUE)

MZML_OUT <- "mzML/"

if (!dir.exists(MZML_PATH))
    stop("Can not find the directory with the mzML files: ", MZML_PATH)
```



# Introduction

Here we start looking at possible batch effects in the data.



# Initial data analysis
First we load the necessary libaries and define a few key variables and 
function(s).

```{r  load-libs, message = FALSE }
library(knitr) 
library(MASS)            
library(xcms)
library(RColorBrewer)
library(pander)
library(doParallel)
#library(beeswarm)
registerDoParallel(4)
register(DoparParam(), default = TRUE)

cw_pw <- c(1.5, 8)

grps <- c("_1_", "_2_", "_3_", "_RBC_", "_POOL")
grps_nams <- c("plasma", "venous", "capillary", "RBC", "POOL")

batches <- data.frame("POL"=c("POS","POS","NEG","NEG"), 
                    "batch"=c("31012018","01022018","06022018","07022018"),
                    stringsAsFactors=FALSE
                    )

Stats <- function(x,prefix=''){
    Mean <- mean(x, na.rm=TRUE)
    SD <- sd(x, na.rm=TRUE)
    Min <- min(x, na.rm=TRUE)
    Max <- max(x, na.rm=TRUE)
    RSD <- 100*SD / Mean
    retVec <- c(Mean, RSD, SD, Min, Max)
    names(retVec) <- c(paste0(prefix,"Mean"), 
                      paste0(prefix,"RSD"), 
                      paste0(prefix,"SD"), 
                      paste0(prefix,"Min"), 
                      paste0(prefix,"Max")
                    )
    return(retVec)
}


```
## Filtering the features
Then we filter the features based on three criteria:

1. The first filter eliminates features where less than 2 are found in the 
pooled sample
2. The second one eliminates features where the % RSD of the feature in the
pooled sample is greater than 30%
3. The third and last eliminiates features that have a high number of 
chromatographic peaks found. Here the ratio of total features divided by the
number of samples where at least one peak is found can not be higher than 1.1


```{r  filter-features, message = FALSE }

feat_list <- vector("list", length(MZML_POLARITY))
farea_list <- vector("list", length(MZML_POLARITY))
obnamer_list <- vector("list", length(MZML_POLARITY))
for(i in 1:length(MZML_POLARITY)) {
    ## define what data we are working with
    onePol<- MZML_POLARITY[i]
    cw_pw <- c(1.5, 8)
    binSize <- 0.005
    bw <- 1.25
    extraDescr <- paste0("_binSize_",binSize,"_bw_",bw)
    obnamer <- paste0("xdata_all_cent_rtcor", cw_pw[1],"_",
                                        cw_pw[2],"_",onePol,extraDescr)
    load(file = paste0(RDATA_PATH, obnamer, ".RData"))
    obnamex <- get(obnamer)

    ## get the feature definitions (including the filled peaks)
    ftd <- featureDefinitions(obnamex)

    ## get the feature chromatographic peak area
    ft <- featureValues(obnamex, value = "into")

    ## limit the areas to the ones where there are more than
    ## two features found in the repeat analysis of the pooled sample
    ft <- ft[ftd$POOL >2,]

    ## find out where the pooled samples are in the dataset
    pool_idx <- which(obnamex$sample_group == "POOL")

    ## calculcate summary statistics for the pool sample
    fti2 <- t(apply(ft[,pool_idx],1, Stats,prefix="pool_area_"))

    ## combine that information with the feature definitions
    fti2 <-
        transform(
        merge(
          ftd[ftd$POOL >2,1:(7+length(unique(obnamex$sample_group)))],
          fti2,
          by="row.names",
          all.x=TRUE
        ), 
        row.names=Row.names,
        Row.names=NULL
        )

    ## add the feature peak ratio for each feature
    fti2$peaks_ratio <- apply(fti2,
                                1,
                                function(x) x["npeaks"]/sum(x[grps_nams]))

    ## apply the seond and third filter
    sel1_idx <- which(fti2$peaks_ratio <= 1.1 & fti2$pool_area_RSD <= 30)
    ft <- ft[sel1_idx,]

    ## storing some values for later
    obnamer_list[[i]] <- obnamer
    feat_list[[i]] <- fti2
    farea_list[[i]] <- ft
}

```

## Injection order sorting

Here we load the two files that contain the injection order for POS and NEG 
respectively.

```{r  injection-sequence, message = FALSE }

all_injections <- vector("list", length(MZML_POLARITY))
for(i in 1:length(MZML_POLARITY)) {
    onePol<- MZML_POLARITY[i]

    all_injections[[i]] <- read.table(
        paste0(MORE_INFO_PATH, "SAMPLELIST_",onePol,".csv"), sep = ",",
             as.is = TRUE, header = TRUE, check.names = FALSE
        )

    all_injections[[i]]$batch <- sapply(all_injections[[i]]$SampleName, 
        function(x) {substr(x,1,8)})
}

```
Here we resort the features based on the injection order within batch.

```{r resort-relative-features, message = FALSE }

for(i in 1:length(MZML_POLARITY)) {
    ## define what data we are working with
    onePol<- MZML_POLARITY[i]
    cnam <- colnames(farea_list[[i]])
    reorder <- sapply(1:dim(all_injections[[i]])[1], function(x){
        grep(paste0(all_injections[[i]]$SampleName[x],"_"),cnam)
        })

    farea_list[[i]] <- farea_list[[i]][,reorder]
}

```

Here we define how to calculate the relative feature area compared to the median 
value of the whole dataset. Note that the relative feature deviation from the 
median is here calculated as the ratio of the feature vs the median rather than 
the logarithmic version of the same as suggested in da silva [ref]

```{r relative-feature-to-mid-feature, message = FALSE }

med_rel <- function(dataf) {
    dataf2 <- dataf
    ft_med <- apply(dataf2,1,median, na.rm=TRUE)
    ft_relmeds <- t(sapply(1:dim(dataf2)[1], function(x) {
        dataf2[x,]/ft_med[x]
    })
    )
    rownames(ft_relmeds) <- rownames(dataf2)
    return(ft_relmeds)
}

```



# Overall trends

Now we plot boxplot for each batch with coloring by sample type. We calculate 
the relative abundance with the function above, but within batch not within 
sample type. 

```{r  generate-per-batch-boxplots, message = FALSE }

grp_cols <- brewer.pal(length(grps_nams)+1, "Set1")
## asign colors to the batch names
names(grp_cols) <- grps_nams

for(i in 1:length(MZML_POLARITY)) {
    ## define what data we are working with
    onePol<- MZML_POLARITY[i]
    ft <- farea_list[[i]]

    ## get the names of the samples in the data frame
    
    
    ## get the batch names for the polarity that we have
    bnames <- batches[batches$POL==onePol,"batch"]

    ## go through each batch and color the boxplots by sample type
    for(n in 1:length(bnames)) {
        batch <- bnames[n]
        samples <- colnames(ft)
        plot_columns <- which(grepl(batch,samples))

        ## get the batch specific data
        ft2 <- med_rel(ft[,plot_columns])
        samples <- colnames(ft2)
        
        ## get the type of the sample
        plot_colors <- grps_nams[sapply(samples, function(x) {
            which(sapply(grps, function(y) {
                length(grep(y,x))>0
            }))
        })
        ]

        ## then finally generate the boxplot
        fl <- paste0(IMAGE_PATH_BOXPLOTS, "Batch_rel_",batch,"_", 
                        onePol, ".png")
        png(fl, width = 16, height = 12, units = "cm", res = 300, 
                    pointsize = 6)
                   
        boxplot(ft2, col=grp_cols[plot_colors], 
                    ylab="area / med_area", 
                    xlab="files", 
                    main=paste0("Boxplot of feature areas for batch ", batch,
                                " (in ",onePol, ")"),
                    outline=FALSE
                )
        colmeds <- apply(ft2,2,median, na.rm=TRUE)
        fm.rlm <- rlm(colmeds ~ plot_columns)
        ypoints <- predict(fm.rlm)
        lines(1:length(plot_columns), 
                    ypoints,
                    col=grp_cols[(length(grps_nams)+1)],
                    lty=3, lwd=3
                    )
        
        dev.off()
    }
}
```

As can be see in the plots below there are no strong trends observed within
the batch. There seems to be a slight injection order sensitivity in the initial
batch for both POS and NEG but it seems to be rather limited.

There is however a very strong sample type effect that can be seen.
Especially the red blood cells are showing a lot of variation.

Also note that the outliers are not plotted in these pictures as they are quite
numerous and have a high variability and make the graphs rather useless.

`r paste0("![Boxplot for batch 31012018](",
                    path.expand(IMAGE_PATH_BOXPLOTS),
                    "Batch_rel_31012018_POS.png)")`

`r paste0("![Boxplot for batch 01022018](",
                    path.expand(IMAGE_PATH_BOXPLOTS),
                    "Batch_rel_01022018_POS.png)")`

`r paste0("![Boxplot for batch 06022018](",
                    path.expand(IMAGE_PATH_BOXPLOTS),
                    "Batch_rel_06022018_NEG.png)")`

`r paste0("![Boxplot for batch 07022018](",
                    path.expand(IMAGE_PATH_BOXPLOTS),
                    "Batch_rel_07022018_NEG.png)")`



# Per sample type boxplots
To look at the trend in the data more carefully we split the data by sample 
type and generate another round of boxplots.

Each sample type is plotted seperately but both batches fit now in one graph.
The samples are now groupped and colored by the analysis batch they are in. 

We now generate relative feature areas based on the sample type but not the
batch. If there is a real batch effect one would expect all sample types to
show the same effect.

```{r  generate-plot-rel-boxplots, message = FALSE }

all_rel_boxplot_paths <- vector("list", length(MZML_POLARITY))
for(i in 1:length(MZML_POLARITY)) {
    ## define what data we are working with
    onePol<- MZML_POLARITY[i]
    ft <- farea_list[[i]]

    ##initialize the boxplot path vector
    all_rel_boxplot_paths[[i]]<-rep(" ", length(grps_nams))

    ## get the names of the samples in the data frame
    samples <- colnames(ft)
    
    ## get the batch names for the polarity that we have
    bnames <- batches[batches$POL==onePol,"batch"]

    ## asign colors to the batch names
    names(grp_cols) <- bnames

    ## go through each group and plot up a boxplot of the log10
    ## transformed area per sample in each group of samples
    ## colored and groupped by the batch they belong to
    for(j in 1:length(grps_nams)) {
        group <- grps[j]
        plot_columns <- c()
        plot_colors <- c()
        possibles <- grepl(group,samples)
        ## add the samples based on the batch
        batch_run_ids <-vector("list",length(bnames))
        for(n in 1:length(bnames)) {
            batch <- bnames[n]
            founds <- which(possibles & grepl(batch,samples))
            plot_columns <- c(plot_columns, founds)
            plot_colors <- c(plot_colors, rep(batch, length(founds)))
            batch_run_ids[[n]] <- founds

        }
        
        ft2 <- med_rel(ft[,plot_columns])
        ## then finally generate the boxplot
        fl <- paste0(IMAGE_PATH_BOXPLOTS, "Sampletype_rel_", grps_nams[j],
                        "_", onePol, ".png")
        all_rel_boxplot_paths[[i]][j] <- path.expand(fl)
        png(fl, width = 16, height = 12, units = "cm", res = 300, 
                    pointsize = 6)
                             
        boxplot(ft2, col=grp_cols[plot_colors], 
                    ylab="area / med_area", 
                    xlab="files", 
                    main=paste0("Boxplot of feature areas for ",
                                    grps_nams[j], 
                                    " in ",onePol),
                    outline=FALSE
                )
        offset <- 0
        for(n in 1:length(bnames)) {
            ft3 <- ft2[,colnames(ft[,batch_run_ids[[n]]])]
            colmeds <- apply(ft3,2,median, na.rm=TRUE)
            fm.rlm <- rlm(colmeds ~ batch_run_ids[[n]])
            ypoints <- predict(fm.rlm)
            lines(offset+(1:length(batch_run_ids[[n]])), 
                    ypoints,
                    col=grp_cols[length(grps_nams)+1],
                    lty=3, lwd=3
                    )
            offset <- offset+length(batch_run_ids[[n]])
        }
        
        dev.off()
    }
}
```

## Relative area boxplots for POS
```{r  show-plot-rel-boxplots-pos, results='asis', echo=FALSE}
i <- 1
onePol<- MZML_POLARITY[i]
for(j in 1:length(grps_nams)) {
    cat("![Boxplot for ",grps_nams[j]," in ",onePol,
        " polarity](", all_rel_boxplot_paths[[i]][j],")")
}
```

## Relative area boxplots for NEG
```{r  show-plot-rel-boxplots-neg, results='asis', echo=FALSE}
i <- 2
onePol<- MZML_POLARITY[i]
for(j in 1:length(grps_nams)) {
    cat("![Boxplot for ",grps_nams[j]," in ",onePol,
        " polarity](", all_rel_boxplot_paths[[i]][j],")")
}
```

# Conclusion
Although there is not a strong overall batch effect in the data it would be 
worth it to investigate if there are features with strong effects or if the
general trend is also observed in most of the individual features.
