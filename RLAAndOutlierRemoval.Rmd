---
title: "RLA filtering and outlier removal"
author: "Sigurdur Smarason"
graphics: yes
output:
  BiocStyle::html_document:
    toc_float: true
csl: biomed-central.csl
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

```{r  init-workspace, message = FALSE, echo = FALSE, results = "hide" }
## clean up workspace
rm(list = ls())

options(useFancyQuotes = FALSE)
set.seed(18011977)

## Path to store RData files

## Define paths:
filename <- "vams2018_centroiding"
## Define the polarity of the data
MZML_POLARITY <- c("POS","NEG")

IMAGE_PATH <- paste0("~/data/images/", filename, "/")
if (!dir.exists(IMAGE_PATH)) dir.create(IMAGE_PATH, recursive = TRUE)
IMAGE_PATH_BOXPLOTS <- paste0("~/data/images/", filename, "/Boxplots/")
if (!dir.exists(IMAGE_PATH_BOXPLOTS)) {
    dir.create(IMAGE_PATH_BOXPLOTS, recursive = TRUE)
}

## Define the path where we can find the mzML files:
MZML_PATH <- "~/data/vams2018/"

## Define the path where added information is stored
MORE_INFO_PATH <- "~/data/vams2018/csv/"

## define where the resulting files should go
RDATA_PATH <- paste0("~/data/RData/", filename, "/")
if (!dir.exists(RDATA_PATH)) dir.create(RDATA_PATH, recursive = TRUE)
RESULTDATA_PATH <- paste0("~/data/Results/", filename, "/")
if (!dir.exists(RESULTDATA_PATH)) dir.create(RESULTDATA_PATH, recursive = TRUE)

MZML_OUT <- "mzML/"

if (!dir.exists(MZML_PATH))
    stop("Can not find the directory with the mzML files: ", MZML_PATH)
```



# Introduction

Here we start looking at possible batch effects in the data.
We use relative log abundance (RLA) rather than relative median abundance as it
seems to be more sensitive to outliers and thus should give clearer results
there.


# Initial data analysis
First we load the necessary libaries and define a few key variables and 
function(s).

```{r  load-libs, message = FALSE }
library(knitr) 
library(MASS)            
library(xcms)
library(RColorBrewer)
library(pander)
library(doParallel)
#library(beeswarm)
registerDoParallel(4)
register(DoparParam(), default = TRUE)

cw_pw <- c(1.5, 8)

grps <- c("_1_", "_2_", "_3_", "_RBC_", "_POOL")
grps_nams <- c("plasma", "venous", "capillary", "RBC", "POOL")

batches <- data.frame("POL"=c("POS","POS","NEG","NEG"), 
                    "batch"=c("31012018","01022018","06022018","07022018"),
                    stringsAsFactors=FALSE
                    )

Stats <- function(x,prefix=''){
    Mean <- NA
    SD <- NA
    Min <- NA
    Max <- NA
    RSD <- NA
    if(length(x)!=0 & !all(is.na(x)) ){
        Mean <- mean(x, na.rm=TRUE)
        SD <- sd(x, na.rm=TRUE)
        Min <- min(x, na.rm=TRUE)
        Max <- max(x, na.rm=TRUE)
        RSD <- 100*SD / Mean
        
    }
    retVec <- c(Mean, RSD, SD, Min, Max)
    names(retVec) <- c(paste0(prefix,"Mean"), 
                      paste0(prefix,"RSD"), 
                      paste0(prefix,"SD"), 
                      paste0(prefix,"Min"), 
                      paste0(prefix,"Max")
                    )
    return(retVec)
}
```

## Filtering the features:

```{r  filter-criteria, message = FALSE, echo = FALSE,}
## constants used for the next section
minFound <- 3
maxRSD <- 30
maxRatio <- 1.1
minPercentFoundPool <- 60

```
The features are filtered with the following criteria:

1. Eliminate features that are found less than *minFound*=`r minFound` times in 
the pooled sample
2. Eliminate features that have % RSD  in the pooled sample greater than 
*maxRSD*=`r maxRSD`%
3. Eliminiate features that have a high number of chromatographic peaks found. 
Here the ratio of total number of peaks found in all samples divided by the 
number of samples where at least one peak is found can not be higher than 
*maxRatio*=`r maxRatio`
4. Since metabolites in low concentration in the plasma samples might not be 
detected in the pool we also include any features from the plasma samples that
are found in at least *minPercentFoundPool*=`r minPercentFoundPool`% of samples.

```{r  filter-features, message = FALSE }

feat_list <- vector("list", length(MZML_POLARITY))
farea_list <- vector("list", length(MZML_POLARITY))
obnamer_list <- vector("list", length(MZML_POLARITY))
feat_num <- data.frame()
for(i in 1:length(MZML_POLARITY)) {
    ## define what data we are working with
    onePol<- MZML_POLARITY[i]
    cw_pw <- c(1.5, 8)
    binSize <- 0.005
    bw <- 1.25
    extraDescr <- paste0("_binSize_",binSize,"_bw_",bw)
    obnamer <- paste0("xdata_all_cent_rtcor", cw_pw[1],"_",
                                        cw_pw[2],"_",onePol,extraDescr)
    load(file = paste0(RDATA_PATH, obnamer, ".RData"))
    obnamex <- get(obnamer)

    ## get the feature definitions (including the filled peaks)
    ftd <- featureDefinitions(obnamex)

    ## get the feature chromatographic peak area
    ft <- featureValues(obnamex, value = "into")

    ## limit the areas to the ones where there are more than
    ## x features found in the repeat analysis of the pooled sample
    ## or are found only in the plasma
    plasmaCnt <- length(which(obnamex$sample_group == "plasma"))
    minFounds <- (ftd$POOL >minFound) | (100.0*ftd$plasma/plasmaCnt > minFound)
    ft <- ft[minFounds,]

    ## find out where the pooled samples are in the dataset
    pool_idx <- which(obnamex$sample_group == "POOL")
    
    ## calculcate summary statistics for the pool sample
    fti2 <- t(apply(ft[,pool_idx],1, Stats,prefix="pool_area_"))

    ## combine that information with the feature definitions
    fti2 <-
        transform(
        merge(
          ftd[minFounds,1:(7+length(unique(obnamex$sample_group)))],
          fti2,
          by="row.names",
          all.x=TRUE
        ), 
        row.names=Row.names,
        Row.names=NULL
        )

    ## add the feature peak ratio for each feature
    fti2$peaks_ratio <- apply(fti2,
                                1,
                                function(x) x["npeaks"]/sum(x[grps_nams]))

    ## apply the seond and third filter
    sel1_idx <- which(fti2$peaks_ratio <= maxRatio & 
                                fti2$pool_area_RSD <= maxRSD)
    ft <- ft[sel1_idx,]

    ## storing some values for later
    obnamer_list[[i]] <- obnamer
    feat_list[[i]] <- fti2
    farea_list[[i]] <- ft

    feat_num <- rbind(feat_num, data.frame("before"=dim(ftd)[1], 
                                        "after"=length(sel1_idx)) )
}
rownames(feat_num) <- MZML_POLARITY

```
With the filtering applied we have reduced the number of fetures as shown in the 
table below for each polarity.
 
```{r  filter-results, message = FALSE, echo = FALSE, results = "asis" }

 pandoc.table(feat_num, caption ="Filter results.")

```




## Injection order sorting

Here we load the two files that contain the injection order for POS and NEG 
respectively.

```{r  injection-sequence, message = FALSE }

all_injections <- vector("list", length(MZML_POLARITY))
for(i in 1:length(MZML_POLARITY)) {
    onePol<- MZML_POLARITY[i]

    all_injections[[i]] <- read.table(
        paste0(MORE_INFO_PATH, "SAMPLELIST_",onePol,".csv"), sep = ",",
             as.is = TRUE, header = TRUE, check.names = FALSE
        )

    all_injections[[i]]$batch <- sapply(all_injections[[i]]$SampleName, 
        function(x) {substr(x,1,8)})
}

```
Here we resort the features based on the injection order within batch.

```{r resort-relative-features, message = FALSE }

for(i in 1:length(MZML_POLARITY)) {
    ## define what data we are working with
    onePol<- MZML_POLARITY[i]
    cnam <- colnames(farea_list[[i]])
    reorder <- sapply(1:dim(all_injections[[i]])[1], function(x){
        grep(paste0(all_injections[[i]]$SampleName[x],"_"),cnam)
        })

    farea_list[[i]] <- farea_list[[i]][,reorder]
}

```

Here we define how to calculate the relative feature area. 
One way is to calculate the relative median abundance compared to the median 
value of the whole dataset. 

```{r relative-feature-to-mid-feature, message = FALSE }

med_rel <- function(dataf) {
    dataf2 <- dataf
    ft_med <- apply(dataf2,1,median, na.rm=TRUE)
    ft_relmeds <- t(sapply(1:dim(dataf2)[1], function(x) {
        dataf2[x,]/ft_med[x]
    })
    )
    rownames(ft_relmeds) <- rownames(dataf2)
    return(ft_relmeds)
}

```

Another way is to calculate the relative feature area is the relative 
logarithmic abundance as suggested in da silva [ref]. 

```{r log-relative-feature-to-mid-feature, message = FALSE }

log_med_rel <- function(dataf) {
    dataf2 <- log2(dataf)
    ft_med <- apply(dataf2,1,median, na.rm=TRUE)
    ft_relmeds <- t(sapply(1:dim(dataf2)[1], function(x) {
        dataf2[x,]-ft_med[x]
    })
    )
    rownames(ft_relmeds) <- rownames(dataf2)
    return(ft_relmeds)
}

```

# Overall trends

Now we plot boxplot for each batch with coloring by sample type. We calculate 
the relative abundance with the function above, for both batches and all sample
types. Both batches for a polarity are fit on one plot to see if there is an
overall batch effect in the data. The boxes are colored by the matrix type of 
the sample.

```{r  generate-per-polariy-boxplots, message = FALSE }

grp_cols <- brewer.pal(length(grps_nams)+1, "Set1")
## asign colors to the batch names
names(grp_cols) <- grps_nams

for(i in 1:length(MZML_POLARITY)) {
    ## define what data we are working with
    onePol<- MZML_POLARITY[i]
    ft <- farea_list[[i]]

    ## get the names of the samples in the data frame
    
    
    ## get the batch names for the polarity that we have
    bnames <- batches[batches$POL==onePol,"batch"]

    ## go through the batches and collect the columns to plot
    plot_columns <-c()
    batch_cnt <- c()
    samples <- colnames(ft)
    for(n in 1:length(bnames)) {
        batch <- bnames[n]
        newcols <- which(grepl(batch,samples))
        plot_columns <- c(plot_columns, newcols)
        batch_cnt <- c(batch_cnt, length(newcols))
    }
    ## now get the sample information
    ft2 <- log_med_rel(ft[,plot_columns])
    samples <- colnames(ft2)
    ## get the type of the sample
    plot_colors <- grps_nams[sapply(samples, function(x) {
        which(sapply(grps, function(y) {
            length(grep(y,x))>0
        }))
    })
    ]

    ## then finally generate the boxplot
    fl <- paste0(IMAGE_PATH_BOXPLOTS, "Batch_relAll_", 
                    onePol, ".png")
    png(fl, width = 16, height = 12, units = "cm", res = 300, 
                pointsize = 6)
               
    boxplot(ft2, col=grp_cols[plot_colors], 
                ylab="area / med_area", 
                xlab="files", 
                main=paste0("Boxplot of feature areas for polariy ", onePol),
                outline=FALSE
            )
    colmeds <- apply(ft2,2,median, na.rm=TRUE)
    startCnt <-1
    for(oneCnt in batch_cnt) {
        idxs <- startCnt:(startCnt+oneCnt-1)
        fm.rlm <- rlm(colmeds[idxs] ~ idxs)
        ypoints <- predict(fm.rlm)
        lines(idxs, 
                    ypoints,
                    col=grp_cols[(length(grps_nams)+1)],
                    lty=3, lwd=3
                    )
        startCnt <- startCnt + oneCnt
    }
    middle <- batch_cnt[1]+0.5
    lines(c(middle,middle),c(0,10), col="red", lty=3)
    dev.off()

}
```

As can be see in the plots below there is a high variability seen in the whole
dataset. This can also be seen but to a lesser extent when the boxplots are 
generated per sample type as is done later.

`r paste0("![Boxplot for POS](",
                    path.expand(IMAGE_PATH_BOXPLOTS),
                    "Batch_relAll_POS.png)")`

`r paste0("![Boxplot for NEG](",
                    path.expand(IMAGE_PATH_BOXPLOTS),
                    "Batch_relAll_NEG.png)")`


# Per sample type boxplots
To look at the trend in the data more carefully we split the data by sample 
type and generate another round of boxplots.

Each sample type is plotted seperately and again both batches are plotted in the
same graph. The boxes are now colored by the analysis batch they 
are in. 

```{r  generate-plot-rel-boxplots, message = FALSE }

all_rel_boxplot_paths <- vector("list", length(MZML_POLARITY))
for(i in 1:length(MZML_POLARITY)) {
    ## define what data we are working with
    onePol<- MZML_POLARITY[i]
    ft <- farea_list[[i]]

    ##initialize the boxplot path vector
    all_rel_boxplot_paths[[i]]<-rep(" ", length(grps_nams))

    ## get the names of the samples in the data frame
    samples <- colnames(ft)
    
    ## get the batch names for the polarity that we have
    bnames <- batches[batches$POL==onePol,"batch"]

    ## asign colors to the batch names
    names(grp_cols) <- bnames

    ## go through each group and plot up a boxplot of the log10
    ## transformed area per sample in each group of samples
    ## colored and groupped by the batch they belong to
    for(j in 1:length(grps_nams)) {
        group <- grps[j]
        plot_columns <- c()
        plot_colors <- c()
        possibles <- grepl(group,samples)
        ## add the samples based on the batch
        batch_run_ids <-vector("list",length(bnames))
        for(n in 1:length(bnames)) {
            batch <- bnames[n]
            founds <- which(possibles & grepl(batch,samples))
            plot_columns <- c(plot_columns, founds)
            plot_colors <- c(plot_colors, rep(batch, length(founds)))
            batch_run_ids[[n]] <- founds

        }
        
        ft2 <- log_med_rel(ft[,plot_columns])
        ## then finally generate the boxplot
        fl <- paste0(IMAGE_PATH_BOXPLOTS, "Sampletype_rel_", grps_nams[j],
                        "_", onePol, ".png")
        all_rel_boxplot_paths[[i]][j] <- path.expand(fl)
        png(fl, width = 16, height = 12, units = "cm", res = 300, 
                    pointsize = 6)
                             
        boxplot(ft2, col=grp_cols[plot_colors], 
                    ylab="area / med_area", 
                    xlab="files", 
                    main=paste0("Boxplot of feature areas for ",
                                    grps_nams[j], 
                                    " in ",onePol),
                    outline=FALSE
                )
        offset <- 0
        for(n in 1:length(bnames)) {
            ft3 <- ft2[,colnames(ft[,batch_run_ids[[n]]])]
            colmeds <- apply(ft3,2,median, na.rm=TRUE)
            fm.rlm <- rlm(colmeds ~ batch_run_ids[[n]])
            ypoints <- predict(fm.rlm)
            lines(offset+(1:length(batch_run_ids[[n]])), 
                    ypoints,
                    col=grp_cols[length(grps_nams)+1],
                    lty=3, lwd=3
                    )
            offset <- offset+length(batch_run_ids[[n]])
        }
        
        dev.off()
    }
}
```

## Relative area boxplots for POS
Here the variation is much less as the RLA is calculated within matrix type.
Outliers are however more visible in these plots as can be seen in the plot for
RBC. 

```{r  show-plot-rel-boxplots-pos, results='asis', echo=FALSE}
i <- 1
onePol<- MZML_POLARITY[i]
for(j in 1:length(grps_nams)) {
    cat("![Boxplot for ",grps_nams[j]," in ",onePol,
            " polarity](", all_rel_boxplot_paths[[i]][j],")\n\n")
}
```

## Relative area boxplots for NEG
The same as in the positive can bee observed here, and obvious outliers are also
present in the RBC samples as well as one in the pool.

```{r  show-plot-rel-boxplots-neg, results='asis', echo=FALSE}
i <- 2
onePol<- MZML_POLARITY[i]
for(j in 1:length(grps_nams)) {
    cat("![Boxplot for ",grps_nams[j]," in ",onePol,
            " polarity](", all_rel_boxplot_paths[[i]][j],")\n\n")
}
```

# Outlier removal

In order to see what happens if we remove the outliers that are so visibly 
present we apply median absolute deviation filtering on the median value for 
each sample. We do this on per matrix basis as otherwise we would potentially
remove too much.


```{r MAD-filtering-outliers, message = FALSE }

all_relfilt_boxplot_paths <- vector("list", length(MZML_POLARITY))
mad_filter <- data.frame()
filtered_columns <- c()
for(i in 1:length(MZML_POLARITY)) {
    ## define what data we are working with
    onePol<- MZML_POLARITY[i]
    ft <- farea_list[[i]]

    ##initialize the boxplot path vector
    all_relfilt_boxplot_paths[[i]]<-rep(" ", length(grps_nams))

    ## get the names of the samples in the data frame
    samples <- colnames(ft)
    
    ## get the batch names for the polarity that we have
    bnames <- batches[batches$POL==onePol,"batch"]

    ## asign colors to the batch names
    names(grp_cols) <- bnames

    ## go through each group 
    mad_filter_pol <- data.frame()
    for(j in 1:length(grps_nams)) {
        group <- grps[j]
        plot_columns <- c()
        plot_colors <- c()
        possibles <- grepl(group,samples)
        ## add the samples based on the batch
        batch_run_ids <-vector("list",length(bnames))
        filter_cnts <- c()
        for(n in 1:length(bnames)) {
            batch <- bnames[n]
            founds <- which(possibles & grepl(batch,samples))

            ft2 <- log_med_rel(ft[,founds])
             ## generate the boxplot statistics
            bpl <- boxplot(ft2, plot=FALSE)

            ## calculate the median and the MAD
            sampleMedians <- bpl$stats[3,]
            sMedianMedian <- median(sampleMedians)
            sampleMAD <- abs(sampleMedians - sMedianMedian)

            ## do the MAD filter
            founds2 <- founds[sampleMAD < 6 * median(sampleMAD)]

            plot_columns <- c(plot_columns, founds2)
            plot_colors <- c(plot_colors, rep(batch, length(founds2)))
            batch_run_ids[[n]] <- founds2
            filter_cnts <- c(filter_cnts, length(founds), length(founds2))
            filtered_columns <- c(filtered_columns, founds2)
        }
        
        mad_filter_pol <- rbind(mad_filter_pol, data.frame("1"=filter_cnts[1], 
                                                            "2"=filter_cnts[2],
                                                            "3"=filter_cnts[3],
                                                            "4"=filter_cnts[4]
                                                            ))

        ft2 <- log_med_rel(ft[,plot_columns])

        ## and now redo the plots
        fl <- paste0(IMAGE_PATH_BOXPLOTS, "Sampletype_relfilt_", grps_nams[j],
                        "_", onePol, ".png")
        all_relfilt_boxplot_paths[[i]][j] <- path.expand(fl)
        png(fl, width = 16, height = 12, units = "cm", res = 300, 
                    pointsize = 6)
                             
        boxplot(ft2, col=grp_cols[plot_colors], 
                    ylab="area / med_area", 
                    xlab="files", 
                    main=paste0("Boxplot of feature areas for ",
                                    grps_nams[j], 
                                    " in ",onePol),
                    outline=FALSE
                )
        offset <- 0
        for(n in 1:length(bnames)) {
            finalIDxs <- which(plot_columns %in% batch_run_ids[[n]] )
            ft3 <- ft2[,finalIDxs]
            colmeds <- apply(ft3,2,median, na.rm=TRUE)
            xpoints <- offset+1:length(finalIDxs)
            fm.rlm <- rlm(colmeds ~ xpoints)
            ypoints <- predict(fm.rlm)
            lines(xpoints, 
                    ypoints,
                    col=grp_cols[length(grps_nams)+1],
                    lty=3, lwd=3
                    )
            offset <- offset+length(xpoints)
        }
        
        dev.off()
    }
    mad_filter <- rbind(mad_filter, mad_filter_pol)
}

roNam <- c(paste0(MZML_POLARITY[1], "_",grps_nams), paste0(MZML_POLARITY[2],"_",grps_nams))
rownames(mad_filter) <- roNam
colnames(mad_filter) <- c("before (1)", "after (1)", "before (2)", "after (2)")
```


## Summary of MAD filtering
Below we see the result of applying a 6 * MAD filter to the individual matrix
classess.  The visual outliers are removed while keeping everything else. If a
more conservative 3 * MAD is applied then several other samples are removed 
(data not shown).

```{r  MAD-filter-results, message = FALSE, echo = FALSE, results = "asis" }

 pandoc.table(mad_filter, caption ="MAD filter results.  The number in 
    paranthesis indicates the batch number")

```

## Relative area boxplots for filtered POS
Here are the plots as before for the ones that changed in positive polarity.

```{r fig.width=3, show-plot-relfilt-boxplots-pos, results='asis', echo=FALSE}
i <- 1
onePol<- MZML_POLARITY[i]
for(j in 1:length(grps_nams)) {
    dfil <- diff(unlist(mad_filter[j,]))
    if(!all(dfil[c(1,3)]==0))
    cat("![Boxplot for ",grps_nams[j]," in ",onePol,
            " polarity](", all_relfilt_boxplot_paths[[i]][j],")\n\n")
}
```

## Relative area boxplots for filtered NEG
And here are the plots as before for the ones that changed for negative 
polarity.

```{r show-plot-relfilt-boxplots-neg, results='asis',echo=FALSE}
i <- 2
onePol<- MZML_POLARITY[i]
pltStr <-c()
for(j in 1:length(grps_nams)) {
    dfil <- diff(unlist(mad_filter[j+5,]))
    if(!all(dfil[c(1,3)]==0))
    cat(paste0("![Boxplot for ",grps_nams[j]," in ",onePol,
        " polarity](", all_relfilt_boxplot_paths[[i]][j],")\n\n"))

}
```


# Overview plots after filtering

And last but not least the overview plots shown after removing the outliers.

```{r  generate-per-polariy-boxplots-after-filtering, message = FALSE }

grp_cols <- brewer.pal(length(grps_nams)+1, "Set1")
## asign colors to the batch names
names(grp_cols) <- grps_nams

for(i in 1:length(MZML_POLARITY)) {
    ## define what data we are working with
    onePol<- MZML_POLARITY[i]
    ft <- farea_list[[i]]

    ## get the names of the samples in the data frame
    
    
    ## get the batch names for the polarity that we have
    bnames <- batches[batches$POL==onePol,"batch"]

    ## go through the batches and collect the columns to plot
    plot_columns <-c()
    batch_cnt <- c()
    samples <- colnames(ft)
    for(n in 1:length(bnames)) {
        batch <- bnames[n]
        newcols <- which(grepl(batch,samples))
        ##filtering out the outliers
        newcols <- newcols[ newcols %in% filtered_columns]
        plot_columns <- c(plot_columns, newcols)
        batch_cnt <- c(batch_cnt, length(newcols))
    }
    
    ## now get the sample information
    ft2 <- log_med_rel(ft[,plot_columns])
    samples <- colnames(ft2)
    ## get the type of the sample
    plot_colors <- grps_nams[sapply(samples, function(x) {
        which(sapply(grps, function(y) {
            length(grep(y,x))>0
        }))
    })
    ]

    ## then finally generate the boxplot
    fl <- paste0(IMAGE_PATH_BOXPLOTS, "Batch_relAllFilt_", 
                    onePol, ".png")
    png(fl, width = 16, height = 12, units = "cm", res = 300, 
                pointsize = 6)
               
    boxplot(ft2, col=grp_cols[plot_colors], 
                ylab="area / med_area", 
                xlab="files", 
                main=paste0("Boxplot of filtered feature areas for polariy ", 
                        onePol),
                outline=FALSE
            )
    colmeds <- apply(ft2,2,median, na.rm=TRUE)
    startCnt <-1
    for(oneCnt in batch_cnt) {
        idxs <- startCnt:(startCnt+oneCnt-1)
        fm.rlm <- rlm(colmeds[idxs] ~ idxs)
        ypoints <- predict(fm.rlm)
        lines(idxs, 
                    ypoints,
                    col=grp_cols[(length(grps_nams)+1)],
                    lty=3, lwd=3
                    )
        startCnt <- startCnt + oneCnt
    }
    middle <- batch_cnt[1]+0.5
    lines(c(middle,middle),c(0,10), col="red", lty=3)
    dev.off()

}
```

As can be seen there the greates difference is still present between matrixes as 
expected. This is something to think about when thinking about normalization 
strategies.

`r paste0("![Boxplot for POS](",
                    path.expand(IMAGE_PATH_BOXPLOTS),
                    "Batch_relAllFilt_POS.png)")`

`r paste0("![Boxplot for NEG](",
                    path.expand(IMAGE_PATH_BOXPLOTS),
                    "Batch_relAllFilt_NEG.png)")`


# Final summary
To see better the overall trend of the sample matrixes overshaddowing other 
effects two PCA plots are produced. 

# Conclusion
Although there is not a strong overall batch effect in the data it is worth it
to investigate the batch effect in more detail. In that investigation one will
have to pay special attention to the fact that the different matrixes seem to 
have quite different ranges for the features detected.