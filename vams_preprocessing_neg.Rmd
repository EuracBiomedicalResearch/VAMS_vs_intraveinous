---
title: "Preprocessing of the vams vs intraveneous untargeted metabolomics data, negative polarity"
author: "Christa Malfertheiner, Johannes Rainer, Giuseppe Paglia and Sigurdur Smarason"
graphics: yes
output:
  BiocStyle::html_document:
    toc_float: true
bibliography: references.bib
csl: biomed-central.csl
references:
- id: dummy
  title: no title
  author:
  - family: noname
    given: noname
---

```{r biocstyle, echo = FALSE, results = "asis" }
library(BiocStyle)
BiocStyle::markdown() 
```

**Modified**: `r file.info("vams_preprocessing_neg.Rmd")$mtime`<br />
**Compiled**: `r date()`

```{r settings, echo = FALSE, results = "hide", message = FALSE}
## Set general options
options(useFancyQuotes = FALSE)
set.seed(18011977)

## Define paths:
filename <- "vams_preprocessing_neg"
## Path to save the images; remove all old images.
IMAGE_PATH <- paste0("C:/Users/User/Documents/Masterarbeit/R/images/", filename, "/")
if (file.exists(IMAGE_PATH))
    unlink(IMAGE_PATH, recursive = TRUE)
dir.create(IMAGE_PATH, recursive = TRUE)
## Path to store RData files
RDATA_PATH <- paste0("data/RData/", filename, "/")
if (!file.exists(RDATA_PATH)) dir.create(RDATA_PATH, recursive = TRUE)

## Define the path where we can find the mzML files:
MZML_PATH <- "C:/Users/User/Documents/mzML_neg"
if (!file.exists(MZML_PATH))
    stop("Can not find the directory with the mzML files: ", MZML_PATH)

## Whether peak detection should be performed or loaded form a previous run.
cached_peak_detection = FALSE

## Where to cut the chromatogram (i.e. subset to spectra within rt 0-rt_cut)
rt_cut <- 250

## Get the number of cpus allocated or fall back to 3 
ncores <- as.integer(Sys.getenv("SLURM_JOB_CPUS_PER_NODE", 3))
```

# Introduction

In this section we perform the pre-processing of negative polarity untargeted
metabolomics data of the *MitYOU* project.  This comprises an initial quality
assessment, chromatographic peak detection, alignment (retention time
correction) and correspondence (chromatographic peak grouping across
samples). The analysis is performed analogously to the analysis described in
*vams_preprocessing.Rmd*. General data descriptions are thus not repeated here.

# Negative polarity

The preprocessing of data in negative ion mode is performed with the same
principles of the analysis in postive ion mode: we start with loading the data,
then we carry out peak detection, alignment and correspondence. The main
libraries used for preprocessing are `MSnBase` and `xcms`.

## Raw data import and initial quality assessment

Below we load all required libraries for the analysis as well as the *phenodata*
file defining the experiment's layout. Also, we set up the parallel processing,
define colors to be used for the various experimental groups throughout the
experiment and finally read the raw data.

```{r neg-libraries-data, message = FALSE}
library(xcms)
library(RColorBrewer)
library(pander)
library(readxl)
library(CompMetaboTools)
library(doParallel)
library(magrittr)
library(pheatmap)
library(MsCoreUtils)
library(magick)
registerDoParallel(ncores)
register(DoparParam(), default = TRUE)
source("util-functions.R")

pd <- read.table("data/phenodata.txt", sep = "\t", as.is = TRUE, header = TRUE)
pd_neg <- pd[pd$polarity == "NEG", ]

## Define colors for the groups.
col_source <- brewer.pal(5, name = "Set1")
names(col_source) <- c("RBC",           # red
                       "plasma",        # blue
                       "all",           # green
                       "capillary",     # purple
                       "venous")        # orange
## Read the data
data_neg <- readMSData(paste0(MZML_PATH, "/", pd_neg$mzML_file),
                       pdata = as(AnnotatedDataFrame(pd_neg),
                                  "NAnnotatedDataFrame"), mode = "onDisk")
data_neg <- filterRt(data_neg, rt = c(0, rt_cut))

#' Add the time stamp from the individual files and check if they
#' match the injection index
time_stamp <- extract_time_stamp(fileNames(data_neg))
data_neg$time_stamp <- time_stamp
stopifnot(!is.unsorted(time_stamp))
```
# Explorative analysis

All samples of the experiment are listed below.

```{r neg-phenodata, message = FALSE, results = "asis", echo = FALSE}
validatePdata <- function(x) {
    src <- c(`1` = "plasma", `2` = "venous", `3` = "capillary", RBC = "RBC")
    fn <- strsplit(x$mzML_file, split = "_")
    for (i in 1:nrow(x)) {
        splt <- fn[[i]]
        if (substr(splt[1], 2, nchar(splt[1])) != x$batch[i])
            message("Row ", i, ": batch wrong")
        if (length(splt) == 5) {
            if (as.numeric(splt[2]) != x$sample[i])
                message("Row ", i, ": sample wrong")
            if (src[splt[3]] != x$source[i])
                message("Row ", i, ": source wrong")
            if ((splt[4] == "a" & x$replicate[i] != 1) ||
                (splt[4] == "b" & x$replicate[i] != 2))
                message("Row ", i, ": replicate wrong")
        } else {
            if (x$sample[i] != "POOL")
                message("Row ", i, ": sample wrong")
        }
    }
}
## validatePdata(pData(data_neg))

tab <- pData(data_neg)[, -4]
pandoc.table(tab, style = "rmarkdown",
             caption = paste0("Data files and samples for negative polarity"))

```

The data set consists thus of samples from in total 22 individuals, with
measurements performed on plasma, venous and capillary blood samples as well as
on red blood cells for each. Measurements were performed in two runs, with each
sample measured in duplicates within each run. A pool of all samples (all
sources and samples) was used as quality control and repeatedly measured (every
9 injections) during a measurement run. The injection order layout of one
measurement run is visualized below.

```{r neg-run-plot, fig.width = 10, fig.height = 2, fig.path = IMAGE_PATH, fig.cap = "Layout of a measurement run."}
tmp <- pData(data_neg)[data_neg$batch == 6022018, ]
par(mar = c(2, 0, 2, 0))
plot(3, 3, pch = NA, xaxt = "n", yaxt = "n", ylim = c(0, 2),
     xlim = c(0.5, nrow(tmp) + 0.5), bty = "n")
rect(xleft = tmp$inj_idx - 0.5, xright = tmp$inj_idx + 0.5, ybottom = 0,
     ytop = 1, col = col_source[tmp$source], border = "grey")
axis(side = 1, line = 0, las = 2)
text(x = tmp$inj_idx, y = rep(0.5, nrow(tmp)), labels = tmp$sample,
     srt = 90, cex = 0.7)
legend("top", col = col_source, legend = names(col_source), horiz = TRUE,
       pch = 15)
```

Sample source type and individuals are randomly distributed along the injection
order.

## Base peak chromatogram

Next we perform an initial quality assessment by comparing the distribution of
TIC and BPC values from the spectra between all samples.

```{r neg-calc-tic, message = FALSE}
chrs_tic <- chromatogram(data_neg, aggregationFun = "sum")
chrs_bpc <- chromatogram(data_neg, aggregationFun = "max")
```

The base peak chromatogram for the full experiment is shown below.

```{r neg-bpc-plot, message = FALSE, echo = FALSE, fig.path = IMAGE_PATH, fig.width = 12, fig.height = 5, fig.cap = "Base peak chromatograms for all samples of the experiment (negative polarity)."}
plot(chrs_bpc, col = paste0(col_source[chrs_bpc$source], "60"))
abline(v = rt_cut)
legend("topright", col = col_source, legend = names(col_source), lwd = 2)

```
```{r}
# Export PDF plot
pdf(file = paste0(IMAGE_PATH, "chrs_bpc_neg.pdf"), height = 5, width = 9)
  plot(chrs_bpc, col = paste0(col_source[chrs_bpc$source], "60"))
  abline(v = rt_cut)
  legend("topright", col = col_source, legend = names(col_source), lwd = 2)
dev.off()
```

The base peak chromatograms are quite different between the different sample
sources. Similar to the positive polarity mode, the largest differences between
sample sources can be observed in the retention time range from 170 to 210
seconds. Especially capillary samples show much lower signal in that area. We
next cluster samples based on pair-wise correlations of their (log2) base peak
intensities.

## Heatmap

A heatmap is now generated: this helps us to find clusters of samples with
similar behaviour and characteristics. We proceed with binning the chromatograms
and calculating the correlation among samples and clustering these with complete
linkage hierarchical clustering.

```{r neg-bin-chr, echo = FALSE, message = FALSE, warning = FALSE, fig.width = 12, fig.height = 12, fig.cap = "Samples clustered by base peak chromatogram. Clustering bases on complete linkage hierarchical clustering of pairwise correlations of log2 base peak signals."}
## Bin the chromatograms to force them to have the same retention times
chrs_bin <- MSnbase::bin(chrs_bpc)
## Calculating the correlation on the log2 transformed bp signals
cormat <- cor(log2(do.call(cbind, lapply(chrs_bin, intensity))))
colnames(cormat) <- rownames(cormat) <- sampleNames(data_neg)
ann <- pData(data_neg)[, c("batch", "source")]
#rownames(ann) <- colnames(cormat)
res <- pheatmap(cormat, annotation_col = ann, cutree_cols = 3,
                annotation_color = list(group = col_source))

```
```{r export heatmap, echo = FALSE, results = "hide"}
# Export PDF plot
pdf(file = paste0(IMAGE_PATH, "heatmap_neg.pdf"), height = 15, width = 15)
  res <- pheatmap(cormat, annotation_col = ann, cutree_cols = 3,
                  annotation_color = list(group = col_source))
dev.off()
```


The base peak chromatograms cluster mainly by the sample source, separating all
capillary samples and most red blood cell samples from other sources
(i.e. plasma, all, and venous samples). No clear separation by batch is present.

In contrast to the positive polarity data, no clear set of outlier samples can
be identified.

## Principal component analysis

In order to confirm the hypothesis formulated in the previous steps, we also
perform PCA. This way we can visualize the clusters by reducing the number
of characteristics of the dataset retaining the most important information.

```{r, echo = FALSE, eval = FALSE}
## Perform the PCA
pc <- prcomp(t(log2(do.call(cbind, lapply(chrs_bin, intensity)))),
             scale = FALSE, center = TRUE)
par(mfrow = c(1, 2))
plot_pca(pc, col = col_source[as.character(data_neg$source)],
         pc_x = 1, pc_y = 2, labels = data_neg$inj_idx)
legend("topleft", col = col_source, legend = names(col_source), lwd = 2, cex=0.4)
plot_pca(pc, col = col_source[as.character(data_neg$source)],
         pc_x = 3, pc_y = 4, labels = data_neg$inj_idx)
legend("topleft", col = col_source, legend = names(col_source), lwd = 2, cex=0.4)
plot_pca(pc, col = col_source[as.character(data_neg$source)],
         pc_x = 2, pc_y = 3, labels = data_neg$inj_idx)
legend("topleft", col = col_source, legend = names(col_source), lwd = 2, cex=0.4)


## cols <- rep("#00000040", length(chrs_bin$source))
## keep_idx <- c(166, 169, 133, 192, 111, 125, 113, 157)
## rem_idx <- c(74, 158, 172, 174, 194, 177, 149, 186, 188, 167, 178)
## cols[keep_idx] <- "#0000ff80"
## cols[rem_idx] <- "#ff000080"

## BioCHRIStes::plot_pca(pc, col = cols, pc_x = 2, pc_y = 3)

## plot(chrs_bpc, col = cols)

```
```{r export pca, echo = FALSE, results = "hide"}
# Export PDF plot
pdf(file = paste0(IMAGE_PATH, "pca_neg.pdf"), height = 7, width = 8)
  pc <- prcomp(t(log2(do.call(cbind, lapply(chrs_bin, intensity)))),
              scale = FALSE, center = TRUE)
  par(mfrow = c(2, 2))
 plot_pca(pc, col = col_source[as.character(data_neg$source)],
         pc_x = 1, pc_y = 2, labels = data_neg$inj_idx)
legend("topleft", col = col_source, legend = names(col_source), lwd = 2, cex=0.4)
plot_pca(pc, col = col_source[as.character(data_neg$source)],
         pc_x = 3, pc_y = 4, labels = data_neg$inj_idx)
legend("topleft", col = col_source, legend = names(col_source), lwd = 2, cex=0.4)
plot_pca(pc, col = col_source[as.character(data_neg$source)],
         pc_x = 2, pc_y = 3, labels = data_neg$inj_idx)
legend("topleft", col = col_source, legend = names(col_source), lwd = 2, cex=0.4)
```

## Boxplots and RLA-values

Next we evaluate the distribution of base peak and total ion values per sample
to identify potentially problematic samples/injections. In addition we calculate
per-sample RLA (relative log abundance) [@DeLivera:2012bw] values representing
average log2 signal (either base peak or total ion) of each sample relative to
the median log2 signal of all samples within the same group. The per sample RLA
values help to spot samples with an overall different average signal compared to
all other samples within the same sample group, which is in our case the sample
source.
```{r tic-boxplot, message = FALSE, echo = FALSE, fig.path = IMAGE_PATH, fig.height = 5, fig.width = 10 * phi, fig.cap = "Distribution of the signal intensities of all samples."}
## Extract the total ion current by file
tc <- split(tic(data_neg), f = fromFile(data_neg))

## Boxplot tc
boxplot(lapply(tc, log2), col = col_source[as.character(data_neg$source)],
        xlab = "sample number",
        ylab = "intensity", main = "Total ion current")
```
```{r Export pdf}
pdf(file = paste0(IMAGE_PATH, "total_ion_content_neg.pdf"), height = 7, width = 15)
boxplot(lapply(tc, log2), col = col_source[as.character(data_neg$source)],
        xlab = "sample number",
        ylab = "intensity", main = "Total ion current")
legend("topleft", col = col_source, legend = names(col_source), lwd = 2, cex=0.4)
```


```{r neg-bpc-boxplot, message = FALSE, fig.path = IMAGE_PATH, fig.width = 12, fig.height = 6, fig.cap = "Distribution of the spectras' base peak signal per sample (top) and average RLA of base peak signals per sample (bottom). Potential outlier samples identified based on their base peak intensities are indicated with squares."}
bpcs <- lapply(chrs_bpc, intensity)
xl <- c(1, length(bpcs))
par(mfrow = c(2, 1), mar = c(0, 4.3, 0, 0.1))
boxplot(lapply(bpcs, log2), col = paste0(col_source[chrs_bpc$source], 60),
        pch = NA, xaxt = "n", ylab = expression(log[2]~base~peak~intensity),
        xlim = xl)
grid(nx = NULL)
par(mar = c(3, 4.3, 0.5, 0.1))
bpcs_rla <- rla(vapply(bpcs, mean, numeric(1)), f = chrs_bpc$source)
pch <- rep(16, length(bpcs_rla))
plot(bpcs_rla, xlab = "", ylab = "average RLA", xlim = xl,
     col = paste0(col_source[chrs_bpc$source], 80), pch = pch)
grid(nx = NULL)

```
```{r export rla-plot, echo = FALSE, results = "hide"}
# Export PDF plot
pdf(file = paste0(IMAGE_PATH, "rla.pdf"), height = 5, width = 10)
par(mfrow = c(2, 1), mar = c(0, 4.3, 0, 0.1))
boxplot(lapply(bpcs, log2), col = paste0(col_source[chrs_bpc$source], 60),
        pch = NA, xaxt = "n", ylab = expression(log[2]~base~peak~intensity),
        xlim = xl)
grid(nx = NULL)
par(mar = c(3, 4.3, 0.5, 0.1))
bpcs_rla <- rla(vapply(bpcs, mean, numeric(1)), f = chrs_bpc$source)
pch <- rep(16, length(bpcs_rla))
plot(bpcs_rla, xlab = "", ylab = "average RLA", xlim = xl,
     col = paste0(col_source[chrs_bpc$source], 80), pch = pch)
grid(nx = NULL)

```


The (base peak) signal from capillary blood samples is generally lower than that
of all other sample types. According to the RLA, only 3 samples, all
representing red blood cell-samples show a generally lower intensity than all
other samples from the same sample type. Below we list the samples with a more
than two-fold lower signal compared to other samples of the same source/matrix.

```{r neg-bpc-outlier, echo = FALSE, message = FALSE, results = "asis"}
outl <- abs(bpcs_rla) > 1
outl_smps <- paste0(chrs_bpc$sample[outl], chrs_bpc$source[outl])
all_outl <- paste0(chrs_bpc$sample, chrs_bpc$source) %in% outl_smps
tab <- cbind(pData(chrs_bpc)[all_outl, ], bpc_rla = bpcs_rla[all_outl])

pandoc.table(tab[order(abs(tab$bpc_rla), decreasing = TRUE), ],
             style = "rmarkdown",
             caption = paste0("Samples for which one replicated measurement ",
                              "had a more than two-fold difference in average",
                              " base peak intensity."))
```

For all of the above samples one of the two replicates yielded a more than
two-fold difference in average base peak intensity, while the other did
not. Also, two of the above outlier samples (second replicates for individuals
22 and 11) were also identified as outliers in the positive polarity mode
arguing for a problem with the respective Mitra tip. We will remove the 3
affected outlier samples from the further analysis.

### Summary

The base peak and total ion chromatogram of capillary blood samples are
different to those from all other matrices/sample types. Also, their average
base peak signal is considerably lower, but consistent between samples of the
same type. 3 Potentially problematic samples have been identified, two of which
were also identified as outliers in the positive polarity data. These will be
excluded from the further analysis.


## Chromatographic peak detection

Key parameters for the *centWave* [@Tautenhahn:2008fx] chromatographic peak
detection algorithm are `ppm` and `peakwidth`, the first defining the allowed
scattering in m/z dimension of valid chromatographic peaks and the second
defining the lower and upper bound of chromatographic peak width (in
seconds). We empirically determine the *best* values for these parameters by
evaluating the raw MS data for selected known compounds in QC samples. We thus
load below the list of known compounds with the theoretical m/z value of the
most likely ion adduct and their expected retention time window.

```{r known-cmps, message = FALSE, warning = FALSE}
library("MetaboCoreUtils")
library(Rdisop)
std_info <- read.table(
    "https://raw.githubusercontent.com/EuracBiomedicalResearch/lcms-standards/master/data/standards_dilution.txt",
    ## "data/standards_dilution.txt",
    sep = "\t", header = TRUE, as.is = TRUE)
std_info <- std_info[!is.na(std_info[, "NEG"]), ]
rownames(std_info) <- 1:nrow(std_info)
std_info$mzneut = NA
std_info$mz_ion = NA

for (i in seq(nrow(std_info))) {
    if (grepl("C", std_info$formula[i])){
        std_info$mzneut[i] <- getMolecule(
            as.character(std_info$formula[i]))$exactmass
    } else {
        std_info$mzneut[i] = as.numeric(std_info$formula[i])
    }
    ## Calculate also the m/z
    std_info$mz_ion[i] <- mass2mz(std_info$mzneut[i],
                                  adduct = std_info[i, "NEG"])[1, 1]
}

```

After reading the data on standard molecules, we apply the `centWave` algorithm
on our data: this allows us to find Regions Of Interest (ROIs) in the m/z
domain, onto which we apply a Continuous Wavelet Transform to detect
chromatographic peaks.
The parameters used for the analysis are the following: \
- `ppm` = 50 \
- `peakwidth` = 2, 20 \
- `snthresh` = 10 \
- `prefilter` = 3, 800 \
- `mzCenterFun` = "wMean" \
- `integrate` = 2 \
- `mzdiff` = 0.001 \
- `fitgauss` = FALSE \
- `noise` = 100 \
- `verboseColumns` = FALSE \
- `roiList` = Listlength 0 \
- `firstBaselineCheck` = TRUE \
- `roiScales` = 0 \

We apply then the `findChromPeaks` function to detect chromatographic peaks.

```{r neg-centWave, message = FALSE, warning = FALSE, eval = !file.exists(paste0(RDATA_PATH, "data_neg_cwp.RData"))}
cwp <- CentWaveParam(ppm = 50,
                     peakwidth = c(2, 20),
                     snthresh = 10,
                     mzdiff = 0.001,
                     prefilter = c(4, 200),
                     noise = 100,
                     integrate = 1)
data_neg <- findChromPeaks(data_neg, param = cwp)
save(data_neg, file = paste0(RDATA_PATH, "data_neg_cwp.RData"))

```

```{r centWave-cached, echo = FALSE, eval = file.exists(paste0(RDATA_PATH, "data_neg_cwp.RData"))}
load(paste0(RDATA_PATH, "data_neg_cwp.RData"))
```
The following step in the analysis is done to remove potential artifacts that
arose during peak detection, as a result of largely overlapping peaks. The `MergeNeighboringPeaksParam` function is used to eliminate such artifacts.
```{r neg-centWave-refine, message = FALSE, warning = FALSE, eval = !file.exists(paste0(RDATA_PATH, "data_neg_refined.RData"))}
mnp <- MergeNeighboringPeaksParam(expandRt = 2.5, expandMz = 0.001,
                                  minProp = 3/4)
data_neg <- refineChromPeaks(data_neg, param = mnp)
save(data_neg, file = paste0(RDATA_PATH, "data_neg_refined.RData"))
```

```{r eval = file.exists(paste0(RDATA_PATH, "data_neg_refined.RData")), echo = FALSE}
load(paste0(RDATA_PATH, "data_neg_refined.RData"))
```

The result of the chromatographic peak detection is an `XCMSnExp` object which
contains all preprocessing results. For each identified peak, the m/z (`"mz"`),
retention time (`"rt"`), the range of RT and m/z (`"rtmin"`, `"rtmax"`,
`"mzmin"`, `"mzmax"`), the integrated signal of the peak (`"into"`), the maximal
signal of the peak (`"maxo"`), the signal to noise ratio (`"sn"`) and the index
of the sample in which the peak was identified (`"sample"`) are reported.

In the following loop, we want to plot the Extracted Ion Chromatograms (EICs)
of the identified peaks. First we have to extract the m/z range, then we
extract the chromatograms. A solid black vertical line is drawn to indicate
the theoretical retention time which was determined by measuring the standard
for the respective compound solved in water.

```{r neg-centWave-eic-plots, echo = TRUE, eval = plot_eics}
std_info_mz_rt <- matrix(
    ncol = 4, nrow = nrow(std_info),
    dimnames = list(std_info$name, c("mzmin", "mzmax", "rtmin", "rtmax")))
std_info_mz_rt <- chromPeakArea(data_neg, mz = std_info$mz_ion,
                                rt = std_info$RT, diffRt = 30,
                                ppm = 50)
std_info <- std_info[!is.na(std_info_mz_rt[, "mzmin"]), ]
std_info_mz_rt <- std_info_mz_rt[!is.na(std_info_mz_rt[, "mzmin"]), ]
## Extract the ion chromatogram for each standard
rtr <- std_info_mz_rt[, c("rtmin", "rtmax")]
rtr[, 1] <- rtr[, 1] - 10
rtr[, 2] <- rtr[, 2] + 10
std_info_chr <- chromatogram(
    data_neg, mz = std_info_mz_rt[, c("mzmin", "mzmax")],
    rt = rtr, aggregationFun = "max")
## Plot the extracted ion chromatograms
dr <- paste0(IMAGE_PATH, "peakdetection/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
sample_colors <- col_source[as.character(data_neg$source)]
for (i in 1:nrow(std_info)) {
    cmpname <- std_info$name[i]
    filename <- paste0(dr, gsub("%", "n", cmpname, fixed = TRUE),
                       "_NEG.png")
    png(file = filename, width = 16, height = 8, units = "cm",
        res = 300, pointsize = 4)
    chr <- std_info_chr[i, ]
    pks <- chromPeaks(chr)
    plot(chr, col = "#00000040",
         main = paste0(std_info$name[i], ": ",
                       format(mz(chr)[1], digits = 6), "-",
                       format(mz(chr)[2], digits = 6)),
         peakCol = paste0(sample_colors[pks[, "column"]], 50),
         peakBg = paste0(sample_colors[pks[, "column"]], 10))
    ## This is just to indicate identified peaks with a rectangle.
    xcms:::.add_chromatogram_peaks(
               chr, pks,
               col = paste0(sample_colors[pks[, "column"]], 40),
               bg = NA,
               type = "rectangle")
    abline(v = std_info$RT[i])
    dev.off()
}
```

All the plotted EICs have been visually inspected to discriminate high quality
(and intensity) peaks from potentially problematic peaks (unclear, multi-peak
signal, low intensity or absent signal). During this process, we annotated the
observed RT, whether the peak was ok or not and some additional notes about the
shape of the peak: these observations have been manually inserted in a table,
where each line represents each of the peaks discovered through the preliminary
peak detection run.


```{r neg-centWave-manual-check, echo = FALSE, eval = FALSE}
## Go manually through all generated plots above and determine which peaks
## look OK.
std_info$RT_obs <- NA_real_
std_info$is_ok <- FALSE
std_info$peak_note <- NA_character_
write.table(std_info, file = "data/std_info_neg.txt", row.names = FALSE, sep = "\t")
```

170 peaks for `r nrow(std_info)` compounds have been detected at this stage.

As for the preprocessing of data colleced in positive ion mode, we found peaks
with different characteristics: some of them are looking as expected, where a
single peak is detected, said peak exhibits a high-intensity signal and the
retention time is close to the theoretical one. One example is ketoleucine. Such
peaks were considered to be *OK* and have been flagged with a value of `TRUE` in
the `"is_ok"` column of the table: by doing this we keep these signals for
future analyses.
 
The observations made for each compound are written in the
*std_info_neg_checked.txt* file, which is then loaded and used to continue the
study. Of the `r nrow(std_info)` identified molecules, only 57 were considered
suitable to remain under investigation.

Next, we import the collected data and we extract the chromatograms where the
peak from the standards and the experimental data overlap in the retention time
dimension. In the resulting chromatograms, we annotate `rt_min` and `rt_max`;
also, the observed retention time is depicted with a black vertical dashed line.

```{r neg-centWave-manual-check-import, echo = FALSE}
std_info <- read.table("data/std_info_neg_check.txt", sep = "\t",
                       as.is = TRUE, header = TRUE)
std_info <- std_info[std_info$is_ok, ]
## Select for each standard the peaks overlapping with the observed rt.
std_info_mz_rt <- matrix(nrow = nrow(std_info), ncol = 4,
                         dimnames = list(std_info$name,
                                         c("mzmin", "mzmax", "rtmin", "rtmax")))
for (i in 1:nrow(std_info)) {
    pks <- chromPeaks(data_neg, mz = std_info$mz_ion[i], ppm = 50,
                      rt = std_info$RT_obs[i])
    if (nrow(pks)) {
        mzr <- range(pks[, c("mzmin", "mzmax")])
        rtr <- range(pks[, c("rtmin", "rtmax")])
        std_info_mz_rt[i, ] <- c(mzr, rtr)
    }
}
std_info <- std_info[!is.na(std_info_mz_rt[, "mzmin"]), ]
std_info_mz_rt <- std_info_mz_rt[!is.na(std_info_mz_rt[, "mzmin"]), ]
```

```{r neg-centWace-eics-refined, echo = FALSE, eval = plot_eics, warning = FALSE, message = FALSE}
## Extract the ion chromatogram for each standard
rtr <- std_info_mz_rt[, c("rtmin", "rtmax")]
rtr[, 1] <- rtr[, 1] - 10
rtr[, 2] <- rtr[, 2] + 10
std_info_chr <- chromatogram(
    data_neg, mz = std_info_mz_rt[, c("mzmin", "mzmax")],
    rt = rtr, aggregationFun = "max")
## Plot the extracted ion chromatograms
dr <- paste0(IMAGE_PATH, "peakdetection-standards/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
sample_colors <- col_source[as.character(data_neg$source)]
for (i in 1:nrow(std_info)) {
    cmpname <- gsub("L-", "", std_info$name[i])
    cmpname <- tolower(gsub(" .*", "", cmpname))
    filename <- paste0(dr, i, "-", cmpname, "_", "NEG", ".png")
    png(file = filename, width = 16, height = 8, units = "cm",
        res = 300, pointsize = 4)
    chr <- std_info_chr[i, ]
    pks <- chromPeaks(chr)
    plot(chr, col = "#00000040",
         main = paste0(std_info$name[i], ": ",
                       format(mz(chr)[1], digits = 6), "-",
                       format(mz(chr)[2], digits = 6)),
         peakCol = paste0(sample_colors[pks[, "column"]], 50),
         peakBg = paste0(sample_colors[pks[, "column"]], 10))
    ## This is just to indicate identified peaks with a rectangle.
    xcms:::.add_chromatogram_peaks(
               chr, pks,
               col = paste0(sample_colors[pks[, "column"]], 40),
               bg = NA,
               type = "rectangle")
    ## abline(v = std_info$RT[i])
    abline(v = std_info$RT_obs[i], lty = 2)
    dev.off()
}
```

As the last step for the peak detection procedure, we want to evaluate the
number of peaks detected in each sample, their width and the distribution of
integrated peak signals.

```{r neg-peaks-summary-plot, warning = FALSE, message = FALSE, echo = FALSE, fig.cap = "Summary of identified chromatographic peaks. The upper plot displays the number of the detected peaks, the middle plot shows their m/z width and the lower barplot represents the distribution of integrated peak signals.", fig.width = 7 * phi, fig.height = 7, fig.path = IMAGE_PATH}
## Split the peaks per sample.
pk_list <- split.data.frame(chromPeaks(data_neg),
                            chromPeaks(data_neg)[, "sample"])
## Calculate mz and rt widths
pk_list <- lapply(pk_list, function(z) {
    cbind(z, mz_width = z[, "mzmax"] - z[, "mzmin"],
          mz_width_ppm = (z[, "mzmax"] - z[, "mzmin"]) * 1e6 / z[, "mz"],
          rt_width = z[, "rtmax"] - z[, "rtmin"])
})
par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1))
barplot(unlist(lapply(pk_list, nrow)),
        col = paste0(col_source[as.character(data_neg$source)], 80),
        ylab = "peak count", main = "Peak detection summary, NEG",
        ylim = c(0, 6000), xaxt = "n")
grid()
legend("top", horiz = TRUE, col = col_source, pch = 15,
       legend = names(col_source))
par(mar = c(0, 4.3, 0, 0.1))
boxplot(lapply(pk_list, function(z) z[, "mz_width_ppm"]), outline = FALSE,
        ylab = "m/z width [ppm]", varwidth = TRUE, xaxt = "n",
        col = paste0(col_source[as.character(data_neg$source)], 80))
## boxplot(lapply(pk_list, function(z) z[, "rt_width"]), outline = FALSE,
##         ylab = "rt width", varwidth = TRUE, xaxt = "n",
##         col = paste0(col_group[data_neg$group], 80))
boxplot(lapply(pk_list, function(z) log2(z[, "into"])), outline = FALSE,
        ylab = expression(log[2]~intensity), varwidth = TRUE, xaxt = "n",
        col = paste0(col_source[as.character(data_neg$source)], 80))
```

```{r export summary plots, echo = FALSE, results = "hide"}
# pdf export plot
pdf(file = paste0(IMAGE_PATH,"summary_preprocessing_change.pdf"), height = 7, width = 7)
  par(mfrow = c(3, 1), mar = c(0, 4.3, 1.5, 0.1))
  barplot(unlist(lapply(pk_list, nrow)),
          col = paste0(col_source[as.character(data_neg$source)], 80),
          ylab = "peak count", main = "Peak detection summary, NEG",
          ylim = c(0, 12000), xaxt = "n")
  grid()
  legend("top", horiz = TRUE, col = col_source, pch = 15,
        legend = names(col_source))
  par(mar = c(0, 4.3, 0, 0.1))
  boxplot(lapply(pk_list, function(z) z[, "mz_width_ppm"]), outline = FALSE,
          ylab = "m/z width [ppm]", varwidth = TRUE, xaxt = "n",
          col = paste0(col_source[as.character(data_neg$source)], 80))
  boxplot(lapply(pk_list, function(z) log2(z[, "into"])), outline = FALSE,
          ylab = expression(log[2]~intensity), varwidth = TRUE, xaxt = "n",
          col = paste0(col_source[as.character(data_neg$source)], 80))
dev.off()
```



The numbers of detected peaks is with 8000 to 10000 slightly higher than for the
positive-mode data, with the most peaks being found in venous samples and the
fewest in RBC samples. Also, RBC samples show the highest variability in the
numbers of identified peaks with three samples yielding a very low number of
peaks (between 4000 and 6000). These are the second replicate for sample 11, 16
and 22, the same samples that have already been identified further above.

```{r neg-peaks-summary-table, echo = FALSE, message = FALSE, results = "asis"}
#' Calculate per sample mean of
#' - peak count
#' - m/z width
#' - rt width
#' Aggregate these per sample group.
smpl_summary <- cbind(peak_count = vapply(pk_list, nrow, numeric(1)),
                      do.call(rbind, lapply(pk_list, function(z) {
                          c(median_mz_width = median(z[, "mz_width_ppm"]),
                            median_rt_width = median(z[, "rt_width"]))
                      })))
tab <- aggregate(smpl_summary, by = list(source = data_neg$source), quantile)
rownames(tab) <- tab[, 1]
tab <- tab[, -1]
pandoc.table(t(tab), style = "rmarkdown", 
             cap = paste("Summary of peak detection results. Shown are the",
                         "per-source quantiles of the numbers of identified",
                         "peaks, of the median m/z (in ppm) and rt widths",
                         " per sample."))
```


The per-sample median m/z width of the identified peaks is on average quite
low and consistent across sample types, same as the retention time width. The
only apparent differences are for the numbers of detected peaks. Here plasma
samples show the lowest and venous samples the highest numbers.

### Summary

The settings for the centWave-based chromatographic peak detection might still
have to be slightly modified, specifically the `ppm` and the `mzdiff`
parameters.

On average about 9000 chromatographic peaks were identified per sample, with the
median m/z width of these peaks being quite small.


## Alignment

After detection, chromatographic peaks have to be aligned to adjust for any
retention time differences due to shifts or biases of the LC. We will use the
*peak groups* method, that aligns samples based on *hook* peaks that are present
in most samples. We thus first group chromatographic peaks requiring them to be
present in 80% of the samples within each group and use these as the *hook*
peaks. Most of the settings for the peak grouping can then be reused for the
correspondence analysis in the next section. Note that before alignment we
remove potentially problematic samples. We are setting `binSize = 0.02` to
avoid chromatographic peaks with highly similar m/z values (within the same
file) to be grouped into the same feature. This has been defined by evaluating
the distance in m/z between chromatographic peaks in the same file in a region
with a high peak density (see plot below).

```{r neg-mz-distance-peaks-plot, message = FALSE, warning = FALSE, fig.cap = "Position of detected chromatographic peaks within a sample. Shown are chromatographic peaks in a region with high peak density. The horizontal blue line represents the bin width if binSize = 0.02 was used."}
plotChromPeaks(filterMz(data_neg, mz = c(756, 758)), 1)
abline(h = c(757, 757.02), col = "#0000ff80")

```

```{r neg-alignment-group, message = FALSE, warning = FALSE}
## Remove potentially problematic samples. These were manually defined.
##bad_idx <- c(74, 152, 178)

##data_neg <- filterFile(data_neg, file = seq_along(data_neg$sample)[-bad_idx])

## Define the peak grouping parameters to define the hook peaks
## These should be peaks present in most samples
pdp <- PeakDensityParam(sampleGroups = data_neg$source,
                        minFraction = 0.95,
                        minSamples = 5,
                        binSize = 0.02,
                        bw = 2)
data_neg <- groupChromPeaks(data_neg, param = pdp)

## Next we perform the alignemnt.
pgp <- PeakGroupsParam(minFraction = 0.9, extraPeaks = 50, span = 0.3)
data_neg <- adjustRtime(data_neg, param = pgp)

```

The results from the alignment are shown below. The base peak chromatograms are
slightly more overlapping after alignment. Also, adjustment of retention time is
smaller 5 seconds for most of the signal, which is what we would expect from
such a small experiment consisting of only two measurement runs.

```{r neg-alignment-rtime-plot, message = FALSE, warning = FALSE, echo = FALSE, fig.width = 12, fig.height = 10, fig.cap = "Alignment result. Shown are the raw base peak chromatogram, the base peak chromatogram after alignment and the difference between the adjusted and raw retention time. Grey dots indicate hook peaks on which the alignment based."}

chr_raw <- chromatogram(data_neg, aggregationFun = "max", adjustedRtime = FALSE)
chr_adj <- chromatogram(data_neg, aggregationFun = "max")
par(mfrow = c(3, 1), mar = c(0, 4.3, 2, 0.1))
plot(chr_raw, col = paste0(col_source[chr_raw$source], 40), peakType = "none",
     main = "BPC, raw")
plot(chr_adj, col = paste0(col_source[chr_raw$source], 40), peakType = "none",
     main = "BPC, adjusted")
plotAdjustedRtime(data_neg, col = paste0(col_source[data_neg$source], 80))

```

```{r export alignment-plot, echo = FALSE, results = "hide"}
# pdf export plot
pdf(file = paste0(IMAGE_PATH, "alignment_neg.pdf"), height = 7, width = 15)
  par(mfrow = c(2, 1), mar = c(4, 4.5, 1, 0.5))
  plot(chr_raw, col = paste0(col_source[chr_raw$source], 40), peakType = "none",
     main = "BPC, raw")
  plot(chr_adj, col = paste0(col_source[chr_raw$source], 40), peakType = "none",
     main = "BPC, adjusted")
plotAdjustedRtime(data_neg, col = paste0(col_source[data_neg$source], 80))
dev.off()
```


At last we generate extracted ion chromatogram plots of the raw and adjusted
data for the list of known compounds. These are visually inspected to evaluate
the impact of the alignment. The plots for some representative compounds are
shown below.

```{r neg-alignment-kc-plots, echo = FALSE, warning = FALSE, message = FALSE}

dr <- paste0(IMAGE_PATH, "alignment/")
dir.create(dr, recursive = TRUE, showWarnings = FALSE)
## Extract the ion chromatogram for each standard
rtr <- std_info_mz_rt[, c("rtmin", "rtmax")]
rtr[, 1] <- rtr[, 1] - 10
rtr[, 2] <- rtr[, 2] + 10
std_info_chr_adj <- chromatogram(
    data_neg, mz = std_info_mz_rt[, c("mzmin", "mzmax")],
    rt = rtr, aggregationFun = "max")
sample_colors <- col_source[as.character(data_neg$source)]
for (i in 1:nrow(std_info)) {
    cmpname <- std_info$name[i]
    filename <- paste0(dr, gsub("%", "p", cmpname, fixed = TRUE),
                       "_NEG.png")
    png(file = filename, width = 16, height = 8, units = "cm",
        res = 300, pointsize = 4)
    chr <- std_info_chr[i, ]
    pks <- chromPeaks(chr)
    plot(chr, col = "#00000040",
         main = paste0(std_info$name[i], ": ",
                       format(mz(chr)[1], digits = 6), "-",
                       format(mz(chr)[2], digits = 6)),
         peakCol = paste0(sample_colors[pks[, "column"]], 50),
         peakBg = paste0(sample_colors[pks[, "column"]], 10))
    abline(v = std_info$RT_obs[i])
    abline(v = std_info$RT[i], lty = 3, col = "grey")
    dev.off()
}

```

For almost all compounds the retention time correction resulted in better
aligned chromatograms.

```{r load the stored alignment data}
load(paste0(RDATA_PATH, "data_neg_align.RData"))
```


### Summary

We used the peak groups method for alignment that uses *hook* peaks expected to
be present in all samples for the alignment.

## Correspondence

Correspondence aims to group chromatographic peaks of the same ion across
samples. We re-use settings for the grouping performed already in the previous
section (i.e. the bandwidth parameter) but reduce the `binSize` parameter to
ensure that peaks from different ions possibly close in m/z dimension are not
grouped. Also, we reduce the `minFraction` parameter to allow definition of
features that are present in fewer individuals.

```{r neg-correspondence}
## Define settings for the correspondence and perform the analysis
pdp <- PeakDensityParam(sampleGroups = data_neg$source,
                        minFraction = 1/3,
                        minSamples = 3,
                        binSize = 0.01,
                        bw = 2)
data_neg <- groupChromPeaks(data_neg, param = pdp)

```

```{r neg-correspondence-kc-plots, echo = FALSE, warning = FALSE, message = FALSE}
dr <- paste0(IMAGE_PATH, "correspondence_vams/")
dir.create(dr, recursive = TRUE,
           showWarnings = FALSE)
rtr <- std_info_mz_rt[, c("rtmin", "rtmax")]
rtr[, 1] <- rtr[, 1] - 6
rtr[, 2] <- rtr[, 2] + 6
std_info_chr_cor <- chromatogram(
    data_neg, mz = std_info_mz_rt[, c("mzmin", "mzmax")],
    rt = rtr, aggregationFun = "max")
for (i in 1:nrow(std_info)) {
    cmpname <- gsub("L-", "", std_info$name[i])
    cmpname <- tolower(gsub(" .*", "", cmpname))
    filename <- paste0(dr, i, "-", cmpname, "_", "NEG", ".png")
    png(file = filename, width = 16, height = 8, units = "cm",
        res = 300, pointsize = 4)
    chr <- std_info_chr[i, ]
    col_samples <- col_source[as.character(chr$source)]
    pks <- chromPeaks(chr)
    if (nrow(featureDefinitions(chr))) {
        plotChromPeakDensity(
            chr, simulate = FALSE, col = "#00000040",
            ylab = "", main=std_info$name[i],
            peakCol = paste0(col_samples[chromPeaks(chr)[, "column"]], 60),
            peakBg = paste0(col_samples[chromPeaks(chr)[, "column"]], "10"))
    } else {
        plotChromPeakDensity(
            chr, simulate = TRUE, col = "#00000040",
            ylab = "", main=std_info$name[i],
            peakCol = paste0(col_samples[chromPeaks(chr)[, "column"]], 60),
            peakBg = paste0(col_samples[chromPeaks(chr)[, "column"]], "10"),
            param = pdp)
    }
    abline(v=std_info$RT[i], lty = 2)
    legend("topright", legend= names(col_source), col = col_source, pch = 16)
    dev.off()
}
```



The table below summarizes the results from the correspondence analysis.

```{r neg-correspondence-summary-table, echo = FALSE, message = FALSE, warning = FALSE, results = "asis"}
feat_summ <- featureSummary(data_neg, group = data_neg$source)

#' Summarized the feature summary table by breaking it down to certain
#' categories that represent the total number of features, total number of
#' features with as well as fetures present in certain percentages of samples
#' with the percentages defined with `percentages`.
#'
#' @param x `matrix` such as returned by the [featureSummary] function.
#'
#' @param percentages `numeric` defining the percentages for which counts
#'     should be reported.
#'
#' @return `matrix` with total counts of features and counts of features for
#'     which peaks have been found in certain percentages of samples. Rows
#'     `"multi"` refer to features for which multiple chromatographic peaks
#'     are present in a sample.
#'
#' @author Johannes Rainer
featureSummaryTable <- function(x, percentages = c(10, 25, 50, 90)) {
    ## Check input table.
    if (!is.matrix(x) ||
        !all(c("count", "multi_count", "multi_perc", "perc") %in% colnames(x)))
        stop("'x' is supposed to be a matrix as returned by the ",
             "'featureSummary' function")
    trues <- list(total = feat_summ[, "count"] > 0,
                  `single peaks` = feat_summ[, "multi_count"] == 0,
                  `multi peaks` = feat_summ[, "multi_perc"] > 0
                  )
    if (length(percentages)) {
        for (perc in percentages) {
            trues <- c(trues, list(feat_summ[, "multi_perc"] > perc))
        }
        names(trues) <- c("total", "single peaks", "multi peaks",
                          paste0("multi in > ", percentages, "% of samples"))
    }
    do.call(rbind, lapply(trues, function(is_true) {
        cnt <- c(count = sum(is_true))
        for (perc in percentages) {
            nms <- names(cnt)
            cnt <- c(cnt, sum(x[is_true, "perc"] > perc))
            names(cnt) <- c(nms, paste0("in > ", perc, "%"))
        }
        cnt
    }))
}

pandoc.table(featureSummaryTable(feat_summ), style = "rmarkdown", 
             caption = paste("Summary of the correspondence analysis. Shown",
                             "are counts of features, counts of features with",
                             "at least one samples in which multiple peaks",
                             "are present (column multi peaks) and counts",
                             "of features with different amount of samples",
                             "having multiple peaks."))

```

Three quarters of the features are *single peak features*, i.e. have only a
single chromatographic peak assigned per sample. The number of features present
in more than 90% of samples is low, but not unexpected, since we do have a
relatively heterogeneous group of individuals, and are also comparing different
sample sources.

Next we evaluate the integrated signal for features in QC samples. This is
expected to be similar between QC samples. Differences can, besides batch
effects or injection order dependent effects, also be caused by differences in
the identified chromatographic peak boundaries. We thus extract below feature
intensities and subset these to QC samples.

```{r feature-vals-QC, message = FALSE}
## We extract the integrated original signal and use the signal from the peak
## with the larger signal for multi-peak features.
fmat <- featureValues(data_neg, value = "into", method = "maxint")

## Subset to QC samples and remove features not present in 90% of the samples
fmat_qc <- fmat[, data_neg$source == "all"]
nsamp <- ncol(fmat_qc)
fmat_qc <- fmat_qc[apply(fmat_qc, MARGIN = 1,
                         function(z) (sum(!is.na(z)) / nsamp) >= 0.9), ]
```

Next we determine per-row differences that will be used to asses overall
similarity between replicates. In log2 scale, we calculate the maximal
difference (`M_range`) and, to avoid results being influenced by outliers,
differences between abundances after removing the lower and upper 1% of signals
(`diff_98`. These `M` values represent thus log fold change differences in
abundances.

```{r feature-vals-diff, message = FALSE}
## Calculat maximal differences...
diff_fun <- function(z) {
    c(M_range = diff(range(z, na.rm = TRUE)),
      M_98 = unname(diff(quantile(z, probs = c(0.01, 0.99), na.rm = TRUE))),
      M_90 = unname(diff(quantile(z, probs = c(0.05, 0.95), na.rm = TRUE))))
}
QC_diffs <- t(apply(log2(fmat_qc), MARGIN = 1, FUN = diff_fun))

```

The table below lists the quantiles of these differences.

```{r feature-vals-diff-table, message = FALSE, echo = FALSE, results = "asis"}
tab <- apply(QC_diffs, MARGIN = 2, quantile)
pandoc.table(tab, style = "rmarkdown",
             caption = paste("Overview of the abundance differences between",
                             "QC samples. Shown are quantiles for the M_range",
                             "(log2 difference between the most extreme values",
                             "for a feature), M_98 (log2 difference after",
                             "removing the top 1% and lowest 1% of values for",
                             "a feature) and M_90 (log2 difference after",
                             "removing the top and lowest 5% of values per",
                             "feature). The analysis bases on", nrow(QC_diffs),
                             "features."))
```

The plot below shows the distribution of log2 ratios in abundances and their
dependency on average abundance.

```{r feature-vals-diff-plot, echo = FALSE, fig.cap = "Distribution of log2 ratios in abundances between QC samples and their dependency on their average abundance.", fig.widht = 10, fig.height = 5}
par(mfrow = c(1, 2), mar = c(4, 4.5, 1, 1))
boxplot(QC_diffs, ylab = expression(log[2]~abundance~ratio))
grid(nx = NA, ny = NULL)
plot(rowMeans(log2(fmat_qc), na.rm = TRUE), QC_diffs[, 1],
     xlab = expression(log[2]~average~abundance),
     ylab = expression(log[2]~abundance~ratio), pch = 16, col = "#00000060")
grid()
```

Next we inspect the data for features from 3 different classes, i.e. features
with single peaks, features having occasionally additional peaks and peaks with
additional peaks in more than 50% of samples. Also, we aim to identify features
that have single peaks in samples from one source, but multiple in others.


### Single peak features

These are supposedly higher quality features. We below identify these peaks and
subsequently create extracted ion chromatograms for 30 randomly chosen ones, 10
with low (signal below 10000), 10 with intermediate (10000 to 20000) and 10 with
high signal intensities (above 2000). For the selection we focus in addition on
features that are present in at least one third of samples.

```{r neg-single-peak-features, message = FALSE}
## Selecting features with a single peak being present
## in more than 33% of samples.
feats <- rownames(feat_summ)[feat_summ[, "multi_count"] == 0 &
                             feat_summ[, "perc"] > 100/3]
rms <- rowMeans(fmat[feats, ], na.rm = TRUE)
feats_low <- sample(feats[rms < 10000], 10)
feats_int <- sample(feats[rms > 10000 & rms < 20000], 10)
feats_high <- sample(feats[rms > 20000], 10)

```

```{r neg-single-peak-features-plot, echo = FALSE, message = FALSE, warning = FALSE}
#' Plot the data for a feature. This includes the identified chromatographic
#' peaks per sample (only of that feature) and the correspondence results.
plot_feature <- function(x, feature) {
    ft <- featureDefinitions(x)[feature, ]
    pks <- chromPeaks(x)[unlist(ft$peakidx), , drop = FALSE]
    ## mzr <- range(pks[, c("mzmin", "mzmax")])
    mzr <- c(ft$mzmin[1], ft$mzmax[1])
    rtr <- range(pks[, c("rtmin", "rtmax")])
    chr <- chromatogram(x, mz = mzr, rt = rtr)
    pk_col <- rep("#000000", nrow(chromPeaks(chr)))
    names(pk_col) <- rownames(chromPeaks(chr))
    pk_col[rownames(pks)] <- brewer.pal(3, "Set1")[2]
    plotChromPeakDensity(chr, peakBg = paste0(pk_col, 10), peakPch = 16,
                         peakCol = paste0(pk_col, 40), simulate = FALSE)
}

##feats_sel <- unique(c(feats_sel, "FT01984"))
dr <- paste0(IMAGE_PATH, "single_peak_fts/")
dir.create(dr, showWarnings = FALSE)

for (feat in feats_low) {
    fn <- paste0(dr, "low-", feat, ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    plot_feature(data_neg, feat)
    dev.off()
}
for (feat in feats_int) {
    fn <- paste0(dr, "int-", feat, ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    plot_feature(data_neg, feat)
    dev.off()
}
for (feat in feats_high) {
    fn <- paste0(dr, "high-", feat, ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    plot_feature(data_neg, feat)
    dev.off()
}

```

The chromatograms for most of these peaks look OK, especially for the high
intensity group. Potentially problematic could be the occasional very broad
chromatographic peaks in some samples for low and intermediate abundance
features.

### Features having occasionally additional peaks

These are features that have an additional peak in less than 10% of
samples. Again we require the features to have a peak in more then 30% of
samples and select 10 random features for low, intermediate and high
intensities.

```{r neg-occasional-multi-features, message = FALSE}
## Selecting features with occacional multiple peaks
## being present. A peak has to be present also in more than 33% of samples.
feats <- rownames(feat_summ)[feat_summ[, "multi_count"] > 0 &
                             feat_summ[, "multi_perc"] < 10 &
                             feat_summ[, "perc"] > 100/3]
rms <- rowMeans(fmat[feats, ], na.rm = TRUE)
feats_low <- sample(feats[rms < 10000], 10)
feats_int <- sample(feats[rms > 10000 & rms < 20000], 10)
feats_high <- sample(feats[rms > 20000], 10)

```

```{r neg-occasional-multi-features-plot, echo = FALSE, message = FALSE, warning = FALSE}
dr <- paste0(IMAGE_PATH, "occasional_multi_peak_fts/")
dir.create(dr, showWarnings = FALSE)

for (feat in feats_low) {
    fn <- paste0(dr, "low-", feat, ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    plot_feature(data_neg, feat)
    dev.off()
}
for (feat in feats_int) {
    fn <- paste0(dr, "int-", feat, ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    plot_feature(data_neg, feat)
    dev.off()
}
for (feat in feats_high) {
    fn <- paste0(dr, "high-", feat, ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    plot_feature(data_neg, feat)
    dev.off()
}

```

Some of the features represent signal from isomers with multiple peaks, with
some of the peaks being assigned to one feature. For others the peak shape shows
plateu which represents most likely to the identified peak being split into two.
Examples for isomers with separate features, for which some peaks overlap
however the other feature are shown below.

```{r manual-isomers, echo = FALSE, message = FALSE, warning = FALSE, fig.width = 12, fig.height = 10, fig.cap = "Examples of isomers for which chromatographic peaks overlap both features."}
par(mfrow = c(2, 1), mar = c(4, 4.5, 1, 1))
chrs <- chromatogram(data_neg, mz = c(356.836, 356.864), rt = c(148, 163))
pk_col <- rep("#000000", nrow(chromPeaks(chrs)))
for (i in 1:nrow(featureDefinitions(chrs))) {
    pk_col[featureDefinitions(chrs)$peakidx[[i]]] <- brewer.pal(9, "Set1")[i]
}
plot(chrs, peakCol = paste0(pk_col, 80), peakBg = paste0(pk_col, 10))

chrs <- chromatogram(data_neg, mz = c(179.056, 179.058), rt = c(160, 170))
pk_col <- rep("#000000", nrow(chromPeaks(chrs)))
for (i in 1:nrow(featureDefinitions(chrs))) {
    pk_col[featureDefinitions(chrs)$peakidx[[i]]] <- brewer.pal(9, "Set1")[i]
}
plot(chrs, peakCol = paste0(pk_col, 80), peakBg = paste0(pk_col, 10))


```

Note however that there is not much we can do to avoid the above
cases. Eventually we might want to *fuse* such features into a single feature.


### Features with many peaks per sample

Here we want to characterize features that have more than one chromatographic
peak assigned in more than 50% of samples.

```{r neg-multi50-features, message = FALSE}
## Selecting features with multiple peaks
## being present. A peak has to be present also in more than 33% of samples.
feats <- rownames(feat_summ)[feat_summ[, "multi_perc"] > 50 &
                             feat_summ[, "perc"] > 100/3]

```

```{r neg-multi50-features-plot, echo = FALSE, message = FALSE, warning = FALSE}
dr <- paste0(IMAGE_PATH, "multi_50_peak_fts/")
dir.create(dr, showWarnings = FALSE)

for (feat in feats) {
    fn <- paste0(dr, feat, ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    plot_feature(data_neg, feat)
    dev.off()
}

```

Some of these features combine peaks from isomers for which correspondence
failed to separate them into different features while most combine signal from
presumably background ions.


### Features with different number of peaks depending on the source

In this section we identify features that have multiple peaks in one sample
group but only single peaks in other groups. For each feature we require to have
peaks in at least 50% of samples. For multi-peaks we require a feature to have
multiple peaks in at least 75% of the samples (in which a peak was detected),
and for single peaks to have less than 5% of samples with an additional peak.

```{r multi-single-define, echo = FALSE, results = "asis", warning = FALSE, message = FALSE}
srcs <- unique(data_neg$source)
srcs <- srcs[srcs != "all"]
mlts <- do.call(cbind, lapply(srcs, function(src) {
    feat_summ[, paste0(src, "_perc")] > 50 &
        feat_summ[, paste0(src, "_multi_perc")] > 75
}))
colnames(mlts) <- srcs

sngls <- do.call(cbind, lapply(srcs, function(src) {
    feat_summ[, paste0(src, "_perc")] > 50 &
        feat_summ[, paste0(src, "_multi_perc")] < 5
}))
colnames(sngls) <- srcs

sngls_mlt <- sngls[rowSums(mlts) > 0, ]
fts_sel <- rownames(sngls_mlt)[rowSums(sngls_mlt) > 0]

tab <- feat_summ[fts_sel, paste0(rep(srcs, each = 2),
                                 c("_perc", "_multi_perc"))]
pandoc.table(tab, style = "rmarkdown", 
             caption = paste("Features with single peaks for some sources and",
                             "multiple peaks for others. Shown are percentages",
                             "of samples per source in which peak(s) were",
                             "found and percentage among those in which",
                             "multiple peaks were present."))

```

```{r multi-single-plot, echo = FALSE, results = "silent", message = FALSE, warning = FALSE}
dr <- paste0(IMAGE_PATH, "source-dependent-multi-peaks/")
dir.create(dr, showWarnings = FALSE)

for (feat in rownames(tab)) {
    fn <- paste0(dr, feat, ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    plot_feature(data_neg, feat)
    dev.off()
}

```

### Features close on m/z and with partially overlapping chromatographic peaks

At last we evaluate features that are overlapping on m/z and retention time with
or without extending their region. If only the feature boundaries are
considered, overlapping features will necessarily share one or more peaks with
each other. Below we identify overlapping features, but also features that are
close on retention time, m/z or both dimensions.

```{r overlapping-features, message = FALSE, warning = FALSE}
ovlap_fts <- overlappingFeatures(data_neg)
ovlap_fts_rt <- overlappingFeatures(data_neg, expandRt = 2) # isomers?
ovlap_fts_mz <- overlappingFeatures(data_neg, ppm = 40)
ovlap_fts_rt_mz <- overlappingFeatures(data_neg, ppm = 40, expandRt = 2)

```

```{r overlapping-features-table, message = FALSE, echo = FALSE, results = "asis"}
tab <- rbind(overlapping = length(ovlap_fts),
             overlapping_within_4seconds = length(ovlap_fts_rt),
             overlapping_50ppm = length(ovlap_fts_mz),
             overlapping_4seconds_100ppm = length(ovlap_fts_rt_mz))
pandoc.table(tab, style = "rmarkdown",
             caption = paste("Summary of overlapping or close features.",
                             "Listed are the total number of overlapping",
                             "features, features that are within 4 seconds to",
                             "each other, features that are overlapping if the",
                             "m/z width is extended by 100 ppm and features",
                             "overlapping if both their retention time range",
                             "and m/z width is extended."))
```

While no features are directly overlapping, quite some are very close in
retention time and/or m/z dimension. The largest part of the feature groups
that are close on retention time consists of only two features. There are
however some groups that consist of more than 5 features.

```{r feature-groups-close-rt, message = FALSE, echo = FALSE, warning = FALSE}
ft_grps <- ovlap_fts_rt[lengths(ovlap_fts_rt) > 5]

dr <- paste0(IMAGE_PATH, "overlapping_close_rt/")
dir.create(dr, showWarnings = FALSE)

for (i in seq_along(ft_grps)) {
    fn <- paste0(dr, "feature-group-", i, ".png")
    png(fn, width = 10, height = 8, units = "cm", res = 200, pointsize = 6)
    plot_feature(data_neg, ft_grps[[i]])
    dev.off()
}

```


```{r feature-groups-close-ppm, echo = FALSE, results = "hide", message = FALSE, warning = FALSE}
## Randomly choosing among features that are less than 50 ppm apart.
set.seed(123)

fts_grps <- ovlap_fts_mz[sample(seq_along(ovlap_fts_mz), 20)]

dr <- paste0(IMAGE_PATH, "overlapping_close_mz/")
dir.create(dr, showWarnings = FALSE)
data_qc <- filterFile(dropChromPeaks(data_neg),
                      file = which(data_neg$source == "all"))
for (i in seq_along(fts_grps)) {
    fn <- paste0(dr, "feature-group-", i, ".png")
    png(fn, width = 20, height = 16, units = "cm", res = 200, pointsize = 6)
    fts_def <- featureDefinitions(data_neg)[fts_grps[[i]], ]
    pks <- chromPeaks(data_neg)[unlist(fts_def$peakidx), ]
    tmp <- filterMz(filterRt(data_qc, range(pks[, c("rtmin", "rtmax")])),
                    mz = range(pks[, c("mzmin", "mzmax")]))
    plot(tmp, type = "XIC", cex = 1)
    dev.off()
}

```


```{r save-data, echo = FALSE, results = "hide"}
save(data_neg, file = paste0(RDATA_PATH, "data_neg.RData"))

```

### Summary

# References
